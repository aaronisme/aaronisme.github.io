[ { "title": "EIP-7702 浅析", "url": "/posts/eip-7702/", "categories": "Thinking", "tags": "Blockchain", "date": "2025-04-14 09:15:00 +0800", "snippet": "概述随着以太坊Pectra升级的临近，EIP-7702也将随之到来。作为一个重要的更新，它将影响智能合约钱包和账户抽象领域。然而，在中文社区中关于这一议题的讨论相对较少。本文旨在简要介绍EIP-7702及其带来的一些思考。如果你对EIP-7702已经非常了解，可以跳过背景部分，直接查看我对这一提案的思考。背景以太坊在面向大众使用（Mass Adoption）过程中面临一个挑战——账户问题。普通的EOA（外部拥有账户）功能相对较弱，且EOA账户与私钥绑定。私钥的存储和使用对用户来说具有一定的挑战性，尤其是对于新手用户来说，如何安全地存储和使用私钥是一个需要解决的问题。为了解决这些问题，以太坊提出了智能合约账户（Smart Contract Account）。与EOA相比，智能合约账户具有更强的编程能力，可以实现更多复杂的逻辑（例如批量转账、替换授权Key、账户恢复等）。EIP-4337的提出和推广正是为了推动智能合约账户的落地和普及。EIP-7702虽然智能合约账户的开发进展较快，但目前EOA账户仍然占据主流地位。EIP-7702的提出旨在加速用户从EOA账户向智能合约账户的迁移，甚至可以预见，在未来某个时刻，以太坊可能会“淘汰”EOA账户，完全转向智能合约账户。那么，EIP-7702到底是什么呢？EIP-7702交易结构EIP-7702是Vitalik提出的一项以太坊改进提案，它引入了一种全新的交易类型。通过这种交易，EOA地址可以将自己委托给某个智能合约账户，从而拥有智能合约账户的高级功能。接下来，让我们具体看看交易的内容。EIP-7702引入了一种新的交易类型SET_CODE_TX_TYPE(0x04)，其交易Payload格式如下：rlp([chain_id, nonce, max_priority_fee_per_gas, max_fee_per_gas, gas_limit,destination, value, data, access_list, authorization_list, signature_y_parity,signature_r, signature_s])authorization_list = [[chain_id, address, nonce, y_parity, r, s], ...]与常规交易相比，需要注意的是authorization_list。它是一个二维数组，数组中的每个元素都是一个包含六个元素的数组，分别是chain_id、address、nonce、y_parity、r和s。其中chain_id是链ID，address是被授权的合约地址，nonce是EOA的nonce值，y_parity、r和s是EOA地址的签名信息。从上述交易结构可以看出，在一笔EIP-7702的交易中，可以包含多个EOA地址的授权信息。需要指出的是，一笔EIP-7702交易不一定需要由授权的EOA地址发送，任何地址都可以发送此交易。更有趣的是，交易负载中并未明确包含EOA地址信息，那么这个交易是如何与EOA账户关联起来的呢？答案很简单：通过authorization_list中的签名信息，可以恢复出EOA账户的地址信息。EOA = ecrecover(msg, y_parity, r, s)由于任何地址都可以发送EIP-7702交易，我们可以预见，在EIP-7702生效后，智能合约钱包的开发者可以主动帮助用户通过EIP-7702交易，将他们的EOA账户升级为智能合约钱包。EIP-7702交易的执行过程当一笔EIP-7702交易被发送后，首先会经过交易验证过程，验证内容包括： 验证chainId是否有效 验证nonce是否有效 验证authorization_list中每个元素的签名是否有效 通过签名恢复EOA地址，并验证其有效性这些验证通过后，交易将继续执行。我们来回顾一下以太坊的账户状态模型。在EIP-7702之前，EOA账户的Code hash并不重要，因为EOA账户没有代码。然而，在EIP-7702之后，如果EOA账户授权某个智能合约账户，其EOA账户的code hash将被设置为0xef0100 || address，其中0xef0100是DelegationPrefix，address是被授权的智能合约账户的地址。值得注意的是，EOA的代理关系是可以改变的。用户可以重新授权给其他智能合约地址，或者完全取消代理关系。EIP-7702后的EOA账户当一个EOA账户被设置代理关系后，若交易发送至该EOA账户，首先会检查该账户是否存在代理关系。如果存在代理关系，交易将会被转发至被授权的智能合约账户进行执行。这样会带来一些变化：首先，EOA账户的余额不仅会因为自己发出的交易而发生变化，也可能因其他交易而变化。同时，EOA账户的nonce机制也会变得更加复杂，新增了更多的场景。思考以上就是EIP-7702的一个大致介绍。如果你想了解更多细节，可以参考EIP-7702。那么，EIP-7702到底意味着什么？会带来哪些变化呢？以下是我的一些简单思考。 EIP-7702无疑是以太坊迈向账户抽象的又一重要一步。它为智能合约钱包的推广和普及提供了更多的方法。如果未来以太坊真的想“淘汰”EOA账户，我也不会感到惊讶。 EIP-7702为EOA账户赋予了更多功能的可能性。通过将EOA账户委托给智能合约账户，EOA账户可以实现更多的功能。不过，这也带来了一些潜在风险。作为普通用户，我们应该注意什么呢？一个显著的风险是，目前缺乏对授权签名过程的明确流程定义。EIP-7702中并未详细定义授权签名的流程，同时任何人都可以发送EIP-7702交易。如果黑客通过钓鱼等手段骗取签名，授权到恶意合约地址，那么EOA账户的控制权可能完全落入黑客手中。这与最近的Bybit攻击方式类似，实际上也是通过盗取签名来转移账户控制权。那么，我们该如何应对呢？ 社区应该为授权签名过程提供明确的流程规范，比如如何组织签名请求、如何显示关键信息、如何提示用户风险。 钱包开发者应建立智能合约白名单，对可以被授权的合约地址进行限制，防止授权到恶意合约地址。 钱包开发者应持续提示用户是否已授权某个合约地址，并清晰展示相关信息。 用户应特别注意每一次签名信息，避免盲签。总之，希望以太坊的账户功能越来越强大，越来越安全。" }, { "title": "BitBox02固件代码浅析", "url": "/posts/bitbox02/", "categories": "Thinking", "tags": "BlockChain", "date": "2023-02-08 09:15:00 +0800", "snippet": "简述BitBox02 是瑞士钱包公司Shift Crypto推出的一款硬件钱包, 目前有两种两个版本, 多币种版本，BTC的单币种版本。多币种版本支持BTC, ETH, ADA, BSC, FTM等一系列的区块链。BTC版本支持多签, Taproot等功能。BitBox02的代码完全开源, 可以在Github上找到。通过阅读代码, 我做了些总计和分析。下边通过几个方面做一个简单的介绍。硬件设计BitBox02采用MCU+SE的硬件设计, MCU采用Microchip的ATSAMD51J20A. 安全芯片采用Microchip的ATECC608B。MCU主要负责USB和上位机通讯. MCU采用I2C和安全芯片通讯. ATSAMD51J20A是一款ARM Cortex M4F核的MCU, 最大主频120MHz, 1M的Flash空间, 256KB的SRAM, 下文中简称为MCU。ATECC608B是一款安全芯片一般用于安全验证领域, 完成安全验证的相关操作, 下文中简称为608B。用户私钥的保存对于硬件钱包来说, 如何安全保存用户的私钥是一个核心问题。对于BitBox2来说, 关于密钥的相关逻辑都集中在keystore.c 这个文件中。可以找到用户seed存储的关键逻辑是 keystore_encrypt_and_store_seed 这个方法.keystore_error_t keystore_encrypt_and_store_seed( const uint8_t* seed, size_t seed_length, const char* password){ if (memory_is_initialized()) { return KEYSTORE_ERR_MEMORY; } keystore_lock(); if (!_validate_seed_length(seed_length)) { return KEYSTORE_ERR_SEED_SIZE; } // Update the two kdf keys before setting a new password. This already // happens on a device reset, but we do it here again anyway so the keys are // initialized also on first use, reducing trust in the factory setup. if (!securechip_update_keys()) { return KEYSTORE_ERR_SECURECHIP; } uint8_t secret[32] = {0}; UTIL_CLEANUP_32(secret); keystore_error_t res = _stretch_password(password, secret, NULL); if (res != KEYSTORE_OK) { return res; } size_t encrypted_seed_len = seed_length + 64; uint8_t encrypted_seed[encrypted_seed_len]; UTIL_CLEANUP_32(encrypted_seed); if (!cipher_aes_hmac_encrypt(seed, seed_length, encrypted_seed, &amp;amp;encrypted_seed_len, secret)) { return KEYSTORE_ERR_ENCRYPT; } if (encrypted_seed_len &amp;gt; 255) { // sanity check, can&#39;t happen Abort(&quot;keystore_encrypt_and_store_seed&quot;); } uint8_t encrypted_seed_len_u8 = (uint8_t)encrypted_seed_len; if (!memory_set_encrypted_seed_and_hmac(encrypted_seed, encrypted_seed_len_u8)) { return KEYSTORE_ERR_MEMORY; } if (!_verify_seed(password, seed, seed_length)) { if (!memory_reset_hww()) { return KEYSTORE_ERR_MEMORY; } return KEYSTORE_ERR_MEMORY; } return KEYSTORE_OK;}分析这个方法可以发现,BitBox02是使用用户的密码通过KDF函数生一个加密私钥, 然后通过AES加密的方式将用户的Seed进行加密. 最后将加密后的数据保存在MCU的flash中.分析这个过程的细节, 可以发现BitBox02使用安全芯片608B生成了两把密钥，rollKey和kdf Key,他们都会参与到密钥衍生中。BitBox02将用户密码加盐做哈希作为输入,首先使用608B指令进行密钥衍生操作, 然后在利用kdf Key再次进行2轮的HKDF的密钥衍生, 生成的数据最后进行HMAC-SHA256的计算, 得到最后用于加密的用户Seed的密钥。 通过KDF函数， 基于用户密码得到一把可以用于加密的密钥, 是安全产品上常见的方法。对于BitBox02来说, 用户的私钥(Seed)是加密后放在MCU的flash里进行存储, 加密用的密钥是通过608B中的Key来进行生成的。由于安全芯片的特点，608B中key是无法读出的。 BitBox02中利用安全芯片608B的特点, 来进行用户私钥的存储。签名过程的实现作为一个硬件钱包另外一个重要的问题就是如何使用用户的私钥进行签名的操作, BitBox02依赖libwally-core 进行钱包相关的业务逻辑计算。 例如:BIP-32, BIP-39和secp256k1签名相关计算。bool keystore_secp256k1_sign( const uint32_t* keypath, size_t keypath_len, const uint8_t* msg32, const uint8_t* host_nonce32, uint8_t* sig_compact_out, int* recid_out){ if (keystore_is_locked()) { return false; } struct ext_key xprv __attribute__((__cleanup__(keystore_zero_xkey))) = {0}; if (!_get_xprv_twice(keypath, keypath_len, &amp;amp;xprv)) { return false; } const secp256k1_context* ctx = wally_get_secp_context(); secp256k1_ecdsa_signature secp256k1_sig = {0}; if (!secp256k1_anti_exfil_sign( ctx, &amp;amp;secp256k1_sig, msg32, xprv.priv_key + 1, // first byte is 0 host_nonce32, recid_out)) { return false; } if (!secp256k1_ecdsa_signature_serialize_compact(ctx, sig_compact_out, &amp;amp;secp256k1_sig)) { return false; } return true;}BitBox02的签名过程, 大致过程是这样的, 当用户输入密码后, 利用608B，计算得加密seed的AES key, 解密得到用户Seed, 然后根据需要的key path 计算得到对应的子私钥, 完成secp256k1的签名。有意思的是BitBox02在secp256k1的签名中引入了Anti-klepto的签名算法, 用来解决硬件钱包在Nonce选择时, 可能的作恶风险。简单来说secp256k1签名中有个核心问题就是Nonce的选择问题, 如果Nonce的选择不随机, 那么就有可能导致私钥的泄漏。具体可以参考这篇文章。目前主流钱包的实现方法都是使用符合RFC6979规范的确定性 ECDSA的签名算法。这个算法可以保证，同一把私钥在签同一个消息的时候，Nonce是确定性的。但是这也会引入另外一个问题,就是用户需要相信硬件钱包厂商没有作恶,他们的Nonce计算的确是符合RFC6979规范的。Anti-klepto protocol的提出就是为了最大化的减小对硬件钱包的信任。简单来说就是将Nonce的产生过程分为两个部分，一部分Host机器产生, 另一部分是硬件钱包产生。 Host机器会验证最后签名中的Nonce是符合要求, 这样Nonce的产生不完全依赖于硬件钱包, 达到减少信任的目的。Anti-klepto protocol充分体现了区块链世界中的Don‘t trust, verify的底层逻辑。关于anti-klepto protocol这里就不特别展开, 未来会写一篇新的文章来进行讨论.Rust 和 CBitBox02的另外一个有意思的地方就是引入了Rust语言, Rust语言作为一门年轻的系统开发语言, 最近几年的发展十分迅猛, 它的一个重要的方法就是在嵌入式开发中的应用。但是目前为止,在嵌入式领域将Rust引入到生产系统中, BitBox02是我看到的第一家。BitBox02中Rust主要负责区块链相关的业务逻辑开发,相关的代码都组织在src/rust的文件夹中,例如Bitcoin,Ethereum,Cardano相关逻辑。在BitBox02中C的代码主要负责MCU的主体逻辑, Rust代码主要负责链相关的业务逻辑。C和Rust通过FFI来进行相互调用。// Process a sign message request.////// The result contains a 65 byte signature. The first 64 bytes are the secp256k1 signature in/// compact format (R and S values), and the last byte is the recoverable id (recid).pub async fn process(request: &amp;amp;pb::EthSignMessageRequest) -&amp;gt; Result&amp;lt;Response, Error&amp;gt; { if request.msg.len() &amp;gt; 9999 { return Err(Error::InvalidInput); } .... // Verify address. We don&#39;t need the actual result, but we have to propagate validation or user // abort errors. super::pubrequest::process(&amp;amp;pub_request).await?; verify_message::verify(&amp;amp;request.msg).await?; let mut msg: Vec&amp;lt;u8&amp;gt; = Vec::new(); msg.extend(b&quot;\\x19Ethereum Signed Message:\\n&quot;); msg.extend(format!(&quot;{}&quot;, request.msg.len()).as_bytes()); msg.extend(&amp;amp;request.msg); let sighash: [u8; 32] = sha3::Keccak256::digest(&amp;amp;msg).as_slice().try_into().unwrap(); let host_nonce = match request.host_nonce_commitment { // Engage in the anti-klepto protocol if the host sends a host nonce commitment. ... }; let sign_result = bitbox02::keystore::secp256k1_sign(&amp;amp;request.keypath, &amp;amp;sighash, &amp;amp;host_nonce)?; let mut signature: Vec&amp;lt;u8&amp;gt; = sign_result.signature.to_vec(); signature.push(sign_result.recid); Ok(Response::Sign(pb::EthSignResponse { signature }))}上边这个方法BitBox02中定义的一个签名message的代码片段, 主要业务逻辑用Rust进行编写, 在签名的时候调用了在keystore.c中C的签名方法完成签名。随着Rust生态的不断发展, 相信未来也会有越来越多的嵌入式项目会引入Rust作为开发语言进行开发。小结以上就是对BitBox02中的代码的一个简单分析, BitBox02整体代码清晰易读的, 也有一些比较有意思的设计和实践, 值得学习和研究。上文分析仅针对这个代码节点。" }, { "title": "理解 Web 3", "url": "/posts/blockchain3/", "categories": "Thinking", "tags": "blockchain", "date": "2022-02-08 11:15:00 +0800", "snippet": " 编者注：文中绝大多数超链接都可以在 EthFans 站内找到中译本，因此统一放到文末，不再一一说明。-通用标准和新工程带来的网络效应-因特网又变了。在过去的几十年里，基于互联网的服务朝着中心化的方向发展。今天，那少数几个大公司，掌握着我们用于信息搜索、存储个人数据、管理个人线上身份、公开或秘密交流的平台。同时，一些看起来不相关的边缘科技正在发展，包括从加密信息到数字货币。在松散的社区里，“Web 3” 成为了一个包罗万象的术语，描述了一个新一代更好的互联网：一个支付和资金为数字原生的互联网、一个”去中心化“应用程序与中心化应用程序竞争的互联网、一个用户能对自己的身份和数据有更多控制权的互联网。然而，我们通常难以清楚的表达这一切意味这什么。Web 3 与之前的互联网时代有什么不同？什么是“去中心化”，为什么“去中心化”这么重要？这些新技术如何应用到实际当中？我们花了好几年的时间构建让区块链更具扩展性的基础架构，但谁会实际应用这些基础架构，用它们来干什么，以及为什么有人用？本文试图用清晰简单的语言解释 Web 3 的愿景。我们将讨论构成 Web 3 项目的核心生动的理念，并调查三个主要趋势。本文不是对未来的预测。未来不是固定的：我们必须做出正确的选择，才能得到我们想要的世界。本文的重点是描述一个可能的未来，一个足够吸引值得建设的未来，一个足够清晰让我们知道第一步怎么走的未来。Web 3 变革互联网之前已经经历过重大的换代，扩展了网路性能、功能和规模。网络已经从纯文本网站变为流媒体视频，从静态网页变为通过浏览器远程提供服务的功能齐全的应用程序，从仅有的几个服务器变为能推动现代政治和文化发展的全球社交网络。随着网络的成熟，我们越来越多地依赖少数几家大公司。 谷歌打造了又快又方便的搜索引擎，控制了 74％ 以上的搜索流量。 Facebook 打造了非常受欢迎的社交网络，获得了 22 亿人线上身份的控制权。Web 3 与之前的互联网换代 不同， Web 3 的核心不在于速度、性能或便利性。实际上，至少到目前为止，许多 Web 3 应用程序比现有产品更慢而且更不方便。而 Web 3 关注的是所有权，是关于谁能 控制 我们天天都在使用的技术和应用程序的。它打破了过去十年互联网发展的动态平衡：便利与控制之间的权衡。我们已经习惯了这种状态，这似乎不可避免的：当然，上网就意味着被监视，当然，注册一个社交网络账号将意味着把个人数据卖给广告商或者会更糟。怎么还会其他办法呢？Web 3 对这种说法是拒绝的。我们可以在 不 把控制权交给那几个大公司的前提下，上网。上述动态平衡并不是网络的铁律，它只是当时可用技术的产物，也是我们在发展过程中做出的选择。“Web 3”是一场构建不同技术并做出更好选择的改革。我们不是试图 取代 现在的网络，而是在改变基础架构的同时保留我们喜欢的东西——是改革，而不是革命。里面的项目看起来毫不相干，但它们都有一个共同的主题。Web 3 是一套重组互联网控制权的技术，从金融项目（加密货币），到基本通信技术（端到端加密消息传递），到大众消费者用例（开放社交网络和P2P市场），到互联网主要基础设施（去中心化 DNS），Web 3都包括。Web 3 不仅有加密货币，区块链以及其他加密经济产品产品，它包含任何改革集中式互联网的技术，让用户重新控制他们的数字世界。但我们认为这些技术是当今 Web 3 改革的最重要贡献者，因此本文将重点放在这些技术上。Web 3 的三个趋势在本文中，我们调查了三种趋势，并讨论了它们如何随着时间的推移而发展： 首先，货币将成为互联网的一个原生功能。 其次，“去中心化”应用程序将为用户提供新功能。 第三，用户将对他们的数字身份和数据信息有更多地控制权。重要的是要记住，上述的趋势都是我的猜测。不可避免地，Web 3 将包含我们无法预测到的技术和应用，而且我们下面讨论的技术和应用将来可能会与我们今天能想象到的不一样。1. 货币在 Web 3 中，货币将是互联网的一个原生功能。在过去，互联网只是线下传统金融系统的门户。但加密货币本质上就是数字化的——发送一笔交易不需要与某些线下系统交互，它 仅仅 需要在网上发送一个消息。我们很快就会习惯，”钱“就是由网络产生的： 收付款现在是 任何软件 都可以做的事情，并且通过扩展，任何人有一部联网的手机就能完成。 数字支付将解锁以前无法实践的新商业模式。它们将大大降低某些交易（例如跨境汇款）的成本，实现新的用例（例如机器支付），并可用于大型新市场（例如以前无法进入传统金融系统的人）。 一个由基本金融原语组成的生态系统——贷款、衍生品、交易所——提供了任何人都能使用的、更复杂的金融应用程序的基本构件。 随着技术人员对加密经济设计领域的探索，我们将创造 新的货币类型。我们才刚开始探索新货币，例如协议代币和不可替代数字资产。加密货币之所以成为可能，是因为Satoshi发明了一种支持加密货币支付的网络，而且无需将控制权交给任何一家集中式的公司。比特币是 去中心化 的，因为它是由多个参与者“控制”的，包括从大型挖矿公司到个体节点运营者，再到核心协议开发者。他们都以不同方式、不同程度影响着整个网络，但没有一个个体拥有独占网络的权力。“去中心化”已成为 Web 3 的核心理念。但是，通常它更多地用作口号而不是精确的技术描述。去中心化可以指代各种各样的可能性。如果一个平台由20个实体控制，那么它是去中心化的吗？100个实体呢？或者1万个？ 我们考虑的是什么样的去中心化呢？去中心化不是二元状态——它是一系列可能性的方向。说一个系统应该“去中心化”就有点像告诉工程师一座桥应该建得很“大”。毫无疑问，但它本身不是一个非常有用的信息——我们还需要知道你想要跨的河和你需要承受的负载。Web 3 的要点并不在于所有系统都应该尽可能地去中心化，而在于我们能够在去中心化上探索出更多的重点。有用或者说必要的去中心化程度取决于具体的应用程序。比特币就是一个例子：其去中心化程度足以抵抗支付审查，且很难改变加密货币的基本参数，即通货紧缩的货币政策：比特币的总量是有限的。其他人尝试过创造类似的全球加密货币，对其他特征进行去中心化，例如 Dai 这样试图解决币值波动问题的稳定币。因为比特币是第一个出现的加密货币，有人认为这是加密货币 唯一 可行的设计。结果，“加密货币”已成为某些对于货币的特定政治观点的同义词，例如通货紧缩货币的优点。理解数字解密货币有许多可能的设计是非常重要的，不同的加密货币可能有不同的用途。 比特币神教认为，加密货币的目的是让人们选择加入他们喜欢的货币政策，其优势是不言而喻的。一个更为谦虚的解释是，加密货币的创新是，人们可以选择任何一种货币政策，什么样的政策都有可能。 他们所需要的只是一个互联网和一部手机。2. 去中心化应用和服务现如今构成互联网的产品和服务往往由个别公司生产和控制。如果你用一个基于互联网的应用程序，很可能有个合法的实体在某个地方控制着它。这个公司会雇员工，确定优先功能，控制托管应用程序数据的服务器，并决定如何更新产品。Web 3 的承诺是，可能还有其他选择。也许我们可以构建不受任何一家公司控制的产品和服务，但仍然具有与集中式公司相当的实用性。正如比特币一样，这些产品将是“去中心化”的，尽管不同产品的去中心化理由及其带来的好处可能会大有不同。例如，想象一下，“去中心化发布平台”可能是什么样子。 这将是一个像 Twitter 或 Medium 这样的社交平台，允许用户分享内容、评论，并对他们喜欢的内容“点赞”。这个平台有内置的激励机制，鼓励用户做出贡献。除了点赞，用户还可以互相发送小额支付，或者为他们想要支持的作者设置定期付款。最好的 Twitter 和 Medium 账户可以直接从平台中获得报酬，而不必通过其他方式来兑现其巨大的关注量。即使每点一个赞只值几美分，这仍然是对像 YouTube 这样的中心化平台的改进，在中心化平台中，每百万次浏览作者只能赚几千美元。在我们去中心化的平台上，没有任何一个中心实体能窃取用户交易的钱。平台甚至可以用通胀资金创造一个奖励池，奖励最高推送。管理我们的去中心化服务的核心规则是在开源协议中定义的。用户使用他们选择的客户端软件与协议进行 交互。换句话说，会有各种各样的APP，虽然这些APP是由不同的人开发的，但都连到同一个社交网络中。这些客户端软件可能会提供互不相同的功能，但都符合相同的协议，类似于电子邮件客户端使用相同标准收发邮件的方式。用户可以选择任何一种客户端，不同客户端可以实现不同的功能或三方服务。因为我们建立在去中心化协议的基础上，所以客户端开发者不需要寻求任何中心实体的同意，他们可以安心的构建他们的产品，而不必担心有一天他们的 API 访问会被撤销。用户无需等待 Twitter 公司添加新的反垃圾邮件或反骚扰功能，他们只需要选一个有这种功能的客户端即可。一个服务的生态系统正逐渐在开放协议的基础上发展，让用户可以做在 Twitter 上能做的一切，甚至比 Twitter 能做的更多。这说明了去中心化平台的一个被低估的好处：可持续的三方服务生态系统。应用程序开发者可以在去中心化协议的基础 之上 构建有用的产品，而不用担心有一天他们的 API 访问将被关掉，因为没有人 可以 关了它。平台保持中立，这意味着会有更多的开发者在它上面将投入时间和金钱，开发属于自己的服务。Chris Dixon 的《为什么分布式重要》深入探讨了这一论点。当然，我们仍将使用中心化公司创建的产品和服务。但这些公司也有可能减少他们对产品的控制 类型，将更多的控制权交给用户。这在加密的消息通信 APP 中已经存在，其中像 Signal（由 Open Whisper Systems 打造的）这样的应用，这些应用看不到、也不保留任何客户通信。通过使用端到端加密方式设计他们的应用程序，他们有意 限制 了自己对用户的控制。相比致力于“不作恶”的早期互联网初创公司，Web 3 公司有更高的目标，尝试并确保它们无法作恶——至少在特定的方面。Web 3包含一些技术，通过事先拒绝开发者的一些权力来限制他们对客户控制。这并不意味着我们不必在某种程度上信任中心化公司，但这意味着我们对他们的信任无需那么多。3. 用户对身份和数据的控制在 Web 3 中，用户对他们的身份和数据有更多的控制权。今天，我们的大多数线上身份属于其他人，比如 Gmail 地址或 Facebook 帐户。 Web 3 正在为个人控制线上身份奠定基础。在某种程度上，这是加密货币基础架构构建的结果。持有加密货币要求持有私钥，数百万人会使用允许他们这样做的应用程序。但是同样的技术可以让人管理任何基于区块链的数据，包括个人身份信息。我们把这种 APP 叫做 “钱包” 并不是巧合，将来他们存的不仅仅是你的钱，还有你的 ID。同时，Web 3 使得用户可以保留对自己数据的控制。首先，因为用户有选择使用自己身份而不是由第三方提供的权力，这样就限制了像 Facebook 这样的三方提供者捕获用户数据的机会。其次，由于去中心化服务的出现，意味着在某些情况下，当你用社交媒体、租房或者打车回家时，没有一家中心化公司能收集、存储、售卖你的信息。一般来说，我们将要用的大部分的系统平台收集不到我们的数据。最后，Web 3 技术提供的新能力，即控制我们的身份和数据信息、以及全球可用的支付网络，将使得个人用户更容易获取内容的价值，使社交媒体公司成为10亿美元企业的价值。你的数据因为它是有价值的。而在 Web 3 中，是用户收集了这些价值。如果你想卖掉你个人的浏览习惯数据，你可以直接卖掉，是你拿到这些数据信息的报酬，而不是像 Facebook 这样的公司。而且随着我们对数字资产所有权新机制的实验，个人用户会得到实际拥有他们每天用的技术的新方法——目前只有企业家、风险资本家和授权投资者才有机会。结论Web 3 不是不可避免的。上述对潜在未来的描述还面临许多障碍，其中一些可能永远无法克服。Web 3 中的一些要解决的问题： 企业家是否真的有动力去构建去中心化应用？谁给他们资金支持？现在，这些应用的盈利和风险回报的途径尚不明确，而传统的“中心化”商业模式更可靠。 去中心化 APP 会比中心化的差吗？由单个公司控制的 APP 可能具有更加一致的产品愿景，并且能快速的迭代更新。中心化 APP 可能会有更好的用户体验，更易于安装。 去中心化应用的加密组件对大多数用户来说是否太具有挑战性？用户如何以一种安全可恢复的方式管理私钥？如果不回到中心化的服务，这有可能吗？ 去中心化应用的使用成本会更高吗？低层次的去中心化系统（如文件存储、计算、可信数据喂养）是有许多冗余的。这些层会使去中心化的应用程序过于昂贵吗? 用“智能合约”构建的去中心化应用程序有意义吗？是否有可能编写永久性满足程序需求的“不可变”代码？如果我们要升级智能合约，那么谁来决定这些升级，它又与中心化应用程序有什么不同？ 如何“管理”去中心化系统？由拥有完全控制权的中心化公司进行决策，要比在一群拥有不同利益和优先级的参与者之间达成共识容易得多。基础层的治理将如何在不同的政治意识形态和文化下发挥作用? 是否有足够的用户真正关心隐私、个人数据的控制或开放金融服务的访问？还是说Web 3 的目标总是一个小众的关注点？ 政府和监管机构将对 Web 3 做出怎样的反应？实现新功能的技术不可避免的给人们带来紧张。Web 3 里包含避免审查和监管的技术，并且能用来逃避金融监管和执法。 Web 3应用程序所使用的底层区块链能够扩展到为数百万或数十亿用户服务吗？即使有这些不确定之处，Web 3 也是一个有价值的未来愿景。对于加密货币和区块链的爱好者的批评正中要害，我们不应该短视地把注意力集中在技术上，而应该放在技术可以解决的问题上。加密货币和区块链本身不会自己结束：它们只有在解决问题时才是有价值的。Web 3 的愿景很有帮助，因为它使我们重新定位到这个问题：互联网已经变得过于中心化，需要开放。关注 Web 3 的愿景而不是任何特定的技术也能帮助我们走出仅限于加密货币领域里的党派政治。Web 3 并不知道最终使用的是谁的平台，Web 3 的重点在于这种技术 在现实中能做什么，为人们解决了什么问题。以太坊和比特币可能会失败，但即使失败了，web 3 的愿景也不会消亡。我们将使用过去 8 年来我们开发的应用知识体系——加密经济学——来构建新这些系统的新的更好的版本，这将持续下去。Web 3 不会是一个乌托邦，我们不应该自我幻灭，认为它将会是乌托邦。如果非说有什么，那么过去 20 年应该已经教会了我们，技术不是什么灵丹妙药，人类面临的问题在互联网上同样也到处都存在。政治、权力与控制并没有随着网络的发明而消失，它们只是以不同的形式出现在网络中。Web 3 的承诺是，至少在这一次，对权力和控制权的限制是设计上的要求，而不是事后的补救。我们有第二次机会来构建互联网，可能，不会有第三次机会了，所以让我们充分利用这次机会。想帮助构建这个未来的互联网吗？L4 正在火热招聘。如果你有兴趣加入我们的团队，可以发送邮件到 careers@l4v。原文链接: https://medium.com/l4-media/making-sense-of-web-3-c1a9e74dcae作者: Josh Stark、Pannshe Mahachi 和 Liam Horne翻译&amp;amp;校对: 刘艳安 &amp;amp; Elisa本文由作者授权 EthFans 翻译及再出版。你可能还会喜欢： [干货 理解以太坊的第 2 层扩展方案](https://ethfans.org/posts/making-sense-of-ethereums-layer-2-scaling-solutions) [观点 弄清加密经济学](https://ethfans.org/posts/making-sense-of-cryptoeconomics) [教程 剖析 ERC721——了解非同质以太坊代币](https://ethfans.org/posts/the-anatomy-of-erc721) [观点 Vitalik：去中心化的意涵](https://ethfans.org/posts/the-meaning-of-decentralization) " }, { "title": "如何妥善备份你的以太坊钱包?", "url": "/posts/blockchain2/", "categories": "Thinking", "tags": "blockchain", "date": "2022-02-08 10:15:00 +0800", "snippet": "新世界大门当你打开数字货币新世界大门时，你需要学会一项在这世界生存的技能， 如何妥善的备份你的钱包 。在过去的世界中，当你把密码弄丢时，你仅需要向服务商提交忘记密码的申请，稍过一会，你就会收到一封邮件，拿起键盘，输入你的新密码。这过程就像魔法一样，你重新获得账户的支配权。这么理所当然的功能，在新世界中，你再也见不着踪影。这是你看到数字货币诸多不方便的一面，也是它令人着迷的另一面。因为这是人类历史上，第一次通过技术彻底、纯粹地保障「私有财产神圣不可侵犯」。而这一切，都建立在你如何妥善地保管你的私钥的基础上。私钥，即财富。钱包生成机制在数字货币世界中，你的钱包由私钥，公钥构成。在学会保管钱包前，你需要明白私钥与公钥的生成机制: 非对称加密算法。在 1976 年以前，所有的加密方式都是同一种模式： 甲方选择一种加密规则，对信息进行加密； 乙方使用同一种规则，对信息进行解谜；由于加密与解密皆为同一种规则，被称为「对称加密算法」。此加密算法的最大弱点就是甲乙双方都需要了解解密规则，而保存和传递解密规则的过程存在极高的安全风险。直到 1977 年，Ron Rivest、Adi Shamir 和 Leonard Adleman 设计了一种非对称加密算法，此算法以他们三人名字命名，被称为「RSA 算法」。以上图为例，解释非对称加密模式的流程： Bob 与 Alice 通过非对称算法生成各自的私钥和公钥（公钥可以通过私钥推导）； Bob 想给 Alice 发送一份加密信息； Bob 用 Alice 的公钥对信息进行加密； 加密的信息仅能通过 Alice 的私钥解密；当前数字货币（比特币、以太币等）采用的是「椭圆曲线算法」，椭圆曲线算法同样也是非对称算法，相比起 RSA 算法有更多的优势，比如安全性能高、计算量小、存储空间占用小、带宽要求低等。每一个钱包账户包含一份密钥对，即私钥与公钥。私钥（k）是一个数字，通常是随机选出的。有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数生成一个公钥（K）。有了公钥（K），我们就可以使用一个单向加密哈希函数生成该账户地址（A）。当你发生交易时，每笔交易都需要一个有效的签名才会被存储在区块链。只有有效的私钥才能产生有效的数字签名，因此拥有钱包账户的私钥就拥有了该账户的支配权。钱包形态在了解钱包的生成机制后，我们很快就明白一点，我们备份钱包，就是备份私钥，但因保管方式不同，所表现的形态也不一样。目前常见的私钥形态： Private Key Keystore &amp;amp;&amp;amp; Password Mnemonic SeedPrivate KeyPrivate Key 就是一份随机生成的 256 位二进制数字，你甚至可以用硬币、铅笔和纸来随机生成你的私钥：掷硬币 256 次，用纸和笔记录正反面并转换为 0 和 1，随机得到的 256 位二进制数字可作为私钥。这 256 位二进制数字，就是私钥原始的状态。Keystore &amp;amp;&amp;amp; Password在以太坊官方钱包中，私钥与公钥将会以加密（创建钱包时设置的密码，请务必记住！）的方式保存为一份 JSON 文件，存储在 /Users/yourname/Library/Ethereum/keystore 中。 这份 JSON 文件就是 keystore，所以你需要同时备份 keystore 和对应的 password。Mnemonic codeMnemonic code 由 BIP 39 提案提出，目的是通过随机生成 12 ~ 24 个容易记住的单词，单词序列通过 PBKDF2 与 HMAC-SHA512 函数创建出随机种子，该种子通过 BIP-0032 提案的方式生成确定性钱包。BIP 39 定义助记码创建过程如下： 创造一个 128 到 256 位的随机顺序（熵）。 提出 SHA256 哈希前几位，就可以创造一个随机序列的校验和。 把校验和加在随机顺序的后面。 把顺序分解成 11 位的不同集合，并用这些集合去和一个预先已经定义的 2048个单词字典做对应。 生成一个 12 至 24 个单词的助记码。所以当你记住 12 ~ 24 个助记码后，就相当于记住私钥。助记码要比私钥更方便记忆和保管。目前支持助记码的钱包有 imToken 和 jaxx 。钱包备份方式因为钱包的形态多样（本质一样），所以备份的方式也同样多点，但最终的目的： 防盗，防丢，分散风险 。 防盗：分离备份，假如 keystore 或密码被盗，但对应的密码 和 keystore 依然安全； 防丢：多处备份，降低丢失所有对应的 keystore &amp;amp;&amp;amp; password 、助记码、私钥等等风险； 分散风险：将资金适当分散，降低损失程度，同时采取多重签名方式，提取超过限制金额，需要多把私钥授权； 下面为大家介绍常见的备份方式： 多处和分离备份 keystore &amp;amp;&amp;amp; password 纸钱包 脑钱包 多重签名多处和分离备份 keystore &amp;amp;&amp;amp; password 打开以太坊官方钱包，在菜单栏中选择 ACCOUNTS -&amp;gt; BACKUP -&amp;gt; ACCOUNTS，你会看到一个 keystore 文件夹，在里面保存你创建过的钱包账户，以 UTC–2016-08-16……. 格式命名的 JSON 文件，这就是你的 keystore 文件。 将 keystore 文件放置多处安全的位置，如离线的 USB 以及你信任的云存储服务商。 keystone 对应的 password，你应该采用强密码，同样多处且与 keystore 分离备份。纸钱包备份纸钱包实质就是将 keystore 或 私钥以纸质化形式保存，一般为二维码形式。你可以通过命令行的方式cat /Users/yourname/Library/Ethereum/keystore/&amp;lt;key_file&amp;gt; | qrencode -o keystore.png也可以到 MyEtherWallet: Open Source JavaScript Client-Side Ether Wallet 离线提交你的 keystore 或 私钥，就可以直接打印对应的二维码纸钱包。脑钱包我们所说的脑钱包并不是由用户自身输入自定义的词句生成私钥（因为这并不安全），而是通过 BIP 39 提案的方式生成足够随机的，可记忆的助记码。这是一个方案，但不是一个非常好的方案，因为人类的大脑并不总是靠谱。多重签名多重签名是一个不错的选择，它的优势是当你需要提取超过限制的金额时，需要多把私钥同时授权，同时提升防盗，防丢的安全性。在以太坊官方钱包中，你可以在 Wallet Contracts 下方中选择 Add Wallet Contract，前提是你用来创建 Wallet Contract 的 account 有不少于 0.02 ETH，足以支付交易所需的费用。当你选择 MULTISIGNATURE WALLET CONTRACT ，将会看到如下提示： “This is a joint account controlled by X owners. You can send up to Y ether per day. Any transaction over that daily limit requires the confirmation of Z owners.”X 代表此钱包合约由多少账户控制Y 代表在单个账户授权情况下，每日可提款的上限Z 代表突破提款上限，需要多少账户授权默认我们采取 X = 3 ，Z =2 的方式，钱包合约由三个账户管理，需突破取款上限需要两个账户同时授权。采取多重签名的机制后，你可以多处且分离的方式保管你的 keystore 和 password，提升防盗，防丢的安全性。关于更多多重签名的详情可看官方文档： Account Management — Ethereal Homestead 0.1 documentation结语不管你用任何方式备份钱包，达到 防盗，防丢，分散风险 的目的即可。参考： Account Management — Ethereum Homestead 0.1 documentation Technical background of version 1 Bitcoin addresses - Bitcoin Wiki GitHub - bitcoinbook/bitcoinbook: Mastering Bitcoin - Unlocking digital currencies wallets - What is the recommended way to safely store Ether? - Ethereum Stack Exchange accounts - How to backup mist wallets? - Ethereal Stack Exchange security - Is there a way to generate ethereum paper wallets? - Ethereum Stack Exchange contract design - How can I create a multi signature address on Ethereal? - Ethereal Stack Exchange Do you need to backup ETH Wallet Contracts? - Support - DAOhub.org作者：阿树本文于一年前首发于 EthFans 论坛，现重发于文章板块。" }, { "title": "区块链是什么鬼?", "url": "/posts/blokchain1/", "categories": "Thinking", "tags": "blockchain", "date": "2022-02-08 09:15:00 +0800", "snippet": "-&amp;lt;http://www.forexnewsnow.com/top-stories/bitcoin-2016-summary-2017-forecasts/&amp;gt;-除非你是山顶洞人，我确信你已经听说了比特币（Bitcoins）和区块链。毕竟，它们是热点，是这几天媒体最喜欢的话题，也是年度流行词。连那些从来没有听过加密货币（cryptocurrency）、根本不知道它如何运行的家伙们也在谈论它。我的朋友中，非技术宅可比技术宅要多。为了让我给他们解释这个新流行词，他们已经骚扰我好几个星期了。我猜，成千上万人跟我有着同样的感受。当这种情形出现，是时候要写一些东西了，好让每个人都能戳醒那些糊涂蛋——这就是这篇推送的目的——以浅白的英文写作，让任何普通的网友都能理解。区块链：为什么我们需要这么复杂的东西？ “每一个复杂的问题都有一个清晰、简单并且是错误的答案。”——H.L.Mencken*与互联网上的其它任何推送相反，我们不会一开始就定义什么是区块链，我们会先认识它要解决的问题。想象一下，Joe 是你最好的朋友。他正在海外旅游。在他假期的第五天，他给你一个电话，“Dude，我把钱花光了，江湖救急。”你回答”马上汇款“然后挂掉电话。然后你打电话给你银行账户的经理，”请从我的账户转 1000 美元到 Joe 的账户上“。你的账户经理回复，”收到，先生“。他打开账簿，查看你的账户以确定你有足够的余额转出 1000 美元给 Joe。因为你是个土豪，账上还有大量余额，因此，他在账簿上登记了一个条目，正如下图所示：注意：我们不提计算机，只是为了让例子简单一点。你打电话给 Joe，告诉他，“我已经转账了。下一次你去银行的时候，你就可以取出我刚刚转过去的 1000 美元。”发生了什么事？你和 Joe 都委托银行来管理你们的钱。并没有物理票据的实际流动来转移你们的钱。所需的一切不过是账簿上的一个条目。或者更准确一点，账簿上的一个既不受你和 Joe 控制、也不被你们所拥有的条目。这就是现有体系的问题。为了在我们之间建立互信，我们依赖于独立第三方。多少年了，我们依赖于这些中介以信任彼此。你也许会问，“依赖他们有什么毛病？”毛病在于，它们清一色只是数字。要在社会上引发一场混乱，所需的不过是一个人或者一个机构走向贪腐堕落，无论是有意识地，还是无意识地。 要是记录下这笔转账的账簿在一场大火中烧成灰烬了呢？ 要是，你的银行经理搞错了，写了个 1500 美元而不是 1000 美元呢？ 要是，他根本就是有意为之呢？多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。会有这样一个系统吗，在那里我们无需银行就可以转账？要回答这个问题，我们需要挖得更深，问自己一个更好的问题（毕竟，只有更好的问题才会导向更好的答案）。想一下，转账意味着什么？只是账簿上的一个条目而已。那么更好的问题将是—— 是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？现在，总算有一个值得探究的问题了。而答案你或许已经猜到了。区块链就是这个深奥问题的答案。它就是一种在我们中间维护账簿而非依赖其他人来为我们代劳的方法。你能跟上来吗？很好。因为现在许多问题已经开始在你脑海中爆炸，我们将学习这一分散式账簿是如何工作的。好吧，告诉我，它是怎么工作的？这一方法的要求是：必须有足够的人不想依赖第三方。只有这样，这群人才能靠自己来维护他们的账簿。 “只让人们在比特币带来的交易中获取比特币，或许是有意义的。一旦有足够的人这样想，它就会变成一个自我实现的预言。”——中本聪，2009*多少人才算是够？至少要 3 个。打个比方，我们假设有 10 个人想抛弃银行以及任何第三方。根据相互之间的协议，他们可以一直拥有彼此的账号信息——但不知道其他人的真实身份。1.一个空的文件夹一开始的时候，每个人都掌握着一个空文件夹。正如我们要进行的那样，这 10 个人都将持续向他们的当前的文件夹中添加纸张。而这些纸张的集合将形成追踪交易的账簿。2.一笔交易发生的时候然后，这个网络中的每个人都将有纸笔在手。每个人都准备着记录下该系统内部发生的任何交易。现在，假设 #2 想要转 10 美元 给 #9。为了完成这次交易，#2 吼了一嗓子，告诉每个人，“我想转 10 美元给 #9。大家都在自己的小本本上记下来！”每个人都瞄一下 #2 是不是有足够的余额可以转 10 美元给 #9。如果她有足够的钱，每个人都在自己的空白页上为这笔交易做了一个记录。这样，一笔转账就被认为是完成了。3.交易继续发生时间过得很快，这个网络中的更多人想要转账给其他人。无论什么时候他们想要做一笔交易，他们就向其他所有人宣告这笔交易。无论是谁，一听到这个宣言，就在他/她自己的纸张上写下来。这样的实践持续进行，直到每个人都用完了他们当前页的空间。假设 1 页纸可以记录 10 笔交易，一旦10笔交易完成，每个人就都用完了空间。-纸张被写满的时候-那么，是时候该将这页纸存到文件夹里面，然后拿出一张新的纸、重复上述步骤2了。4.存放纸张在你将这页纸存入我们的文件夹之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。通过密封，我们可以保证，一旦该页纸的备份已经被存入每一个人的文件夹，没有人能够对它作出任何更改——不止今天，不止明天，也不止是一年以后。一旦放入文件夹中，它将永远呆在文件夹里面——被封存起来。而且，如果每个人都信任这个封条，那么每个人都会相信该页纸中的内容。而这页纸的封存手法，就是这一方法的关键。 [术语箱] 这一用来保护纸张内容的东西被人们称为“矿”，但为了简化它，我们还是称之为“封条”。早些时候，第三方/中介为我们赋予信任，其形式是：无论它们在账簿上已经写了什么，都永远不可变更。在一个分散式的、去中心化的系统中，就像上述我们的系统一样，这种封条将提供信任替代。因缺斯汀！那我们怎么密封这份记录呢？在我们学习如何能密封这页纸之前，我们要知道，一般而言，封条是怎么工作的。要做到这些，先决条件是学习一些东西，我喜欢称之为……魔法机器想象一个被厚墙围起来的机器。如果你从左边塞一个存有东西的盒子进去，它就会吐出一个带着其它东西的盒子。 [术语箱] 这个机器被称为“哈希方程”，但我们又没有心情搞得那么专业。所以，今天，它们就叫“魔法机器”。-魔法机器（又叫做 哈希方程）-假设，我们从左边塞了个数字 4 进去，我们会发现，它在右边吐出了下列字串：‘dcbea’。数字 4 是在怎么转化成这串字符的？没有人知道。而且，这个过程是不可逆的。得到了这串字符 ‘dcbea’，也不可能搞清楚这机器从左边接收到了什么。但是，任何时候，你输入数字4给这台机器，它都总是会吐出同样的字符，‘dcbea’。- hash(4) == dcbea -来试试发送一个别的数字进去。26，怎么样？- hash（26）==94c8e -这次我们得到了 ‘94c8e’，看来字符同样可以包含数字。有意思！假如我现在问你如下问题，事情会变成什么样？ “你能不能告诉我，要想在机器右边得到三个 0 开头的一串字符，我该从左边输入什么东西进去呢？比如，000ab，或者，00098，或者，000fa，或者其它情况中的任何一个。”想一想这个问题吧。我已经告诉过你，这台机器有个属性：在我们从右边得到期望的输出值之后，我们无法计算出来什么是我们必须从左边输入进去的。给我们这样一台机器，我们如何能回答我问的那个问题？我可以想出一个办法。为什么我们不一个接一个地遍历宇宙中所有数字，直到我们得到一个三个 0 开头的一串字符？-尝试所有数字以算出需要的输入值-乐观估计，经过几千次尝试之后，我们最终会得到将在右边产生要求的输出值的一个数字。在给定输出值的时候，要算出输入值是极其艰难的。但与此同时，如果预测的输入值可以产生需要的输出值的话，它又是极为容易验证的。要记住，投入一个同样数字，这台机器每一次都会吐出同样的字符。如果我给你一个数字，比如 72533，然后问你一个问题：“这个数字，输入这台机器之后，会产生一个以三个 0 开头的字符串吗”，你觉得要得出答案有多难呢？你要做的一切，不过是丢这个数字进去，然后查看我们在右边得到了什么。就这样。这样的机器最重要的属性就是——“给定一个输出值，要算出输入值是极端困难的。但是，给定输入值和输出值，要检验该输入是否会导致该输出，却是非常容易的。”在这片文章剩下的部分，我们要记住这台魔法机器（或者说哈希方程）的这一属性：“给定一个输出值，要算出输入值是极端困难的。但是，给定输入值和输出值，要检验该输入是否会导致该输出，却是非常容易的。”如何用这样的机器来加密一份文件？我们将使用这台魔法机器为我们的纸张产生一个密封条。按照惯例，我们将从一种想象的情形开始。想象我给你了两个盒子。第一个盒子装着数字 20893。然后我问你，“你能不能找出一个数字，加上装在第一个盒子里面的数字以后，输进这台机器，最终会给我们一个以三个 0 开头的字符？”这种情形跟我们在之前看到的很相似，而我们已经知道，算出这样一个数字的为唯一方法就是穷举整个宇宙中每一个可能的数字。又是几千次尝试之后，我们会偶然发现一个数字，比如 21191，加上 20893 以后（比如：21191+20893 = 42084）输入机器，将产生一串符合我们要求的字符。在这个例子中，数字 21191 就成了数字 20893 的封条。假设现在有一张纸，数字 20893 写在上面。为了密封这页纸（比如：使得没有人能更改这页纸上的内容），我们将盖一个带有标签 ‘21191’ 的徽章在上面。一旦密封数字（比如：21191）被戳在纸上，这页纸就被密封了。-密封数字- [术语箱] 密封数字又被称为“工作量证明”，意思是，这一数字证明了为了计算出它来已经付出的努力。为了我们的目的，我们最好还是称之为“密封数字”。如果任何人想验证这页纸是否已经被替换了，他需要做的一切不过是——将这页纸上的内容与密封数字加在一起、把和值输入那台魔法机器。如果机器给出了一串三个 0 开头的字符，那么内容就没有被改变。如果出现的字符不能满足我们的要求，我们就可以丢掉这页纸了，因为它的内容已经有了水分，没有任何用处了。我们将使用一个简单的密封机制来封存所有的记录，最终在我们各自的文件夹中编排好它们。最后，封存我们的文件要密封包含着我们网络中交易内容的记录，我们将需要算出一个数字，该数字在添加到交易记录清单上、输入机器以后，可以使我们得到一串三个 0 开头的字符。注意：我一直在使用的“三个 0 开头的字符”，只是一个例子。它阐明了哈希方程是怎么工作的。实际当中的挑战要比这个复杂得多。我们会在这机器上花费时间与电力，然而一旦我们算出那个数字，这页文件就被那个数字封存起来。永远永远，如果有人尝试改变这页纸上的内容，这个密封数字允许任何人去验证这页纸的完整性。现在，我们既已知道封存记录的手法，我们将回到我们在这张纸上写完了 10 条交易、没有空间书写更多记录的时候。一旦每个人都用尽一页纸的空间、无法记录进一步的交易，他们就开始卖力地计算该页纸的密封数字，使得它可以被藏入文件夹中。在网络中，每个人都进行这个计算，而最早算出密封数字的那个人会向其他所有人宣布这个数字。听到密封数字之后，每个人都立即验证它是否能产生要求的输出值。如果是的，每个人都为他们的纸张标上这个数字，然后把纸张放入文件夹中。但是，如果对某人，比如 #7 来说，那个被宣布的密封数字无法产生要求的输出值，怎么办？这种情形可并不少见。可能的原因有： 他可能听错了之前在网络中宣布的交易 他可能写错了之前在网络中宣布的交易 他可能在记录交易的时候试图作弊，为了谋私，或为讨好网络中的某些人无论原因是什么，#7 只有一个选择——放弃他的记录、从其他人处获得拷贝，以使他也可以将纸张放入文件夹。除非他不将他的纸张放入文件夹，他也就无法继续记录进一步的交易，这会因此禁止他成为网络中的一员。大部分人同意的密封数字，无论是它是什么，都会成为那个可信的密封数字。可是，如果他们知道其他人会算出它然后宣布它，为什么每个人都要耗费资源来进行计算呢？为什么不坐视不理、等着抱大腿呢？好问题。这就是激励加入到这幅图景的地方。每一个区块链的成员都有资格获得奖励。第一个计算出密封数字的人将得到免费的金钱作为对他的努力（比如：付出的 CPU 算力和电力）的奖励。简单地设想一下，如果 #5 为一页记录算出了密封数字，他得到了一些免费的钱作为奖励，假设是凭空铸造出来的1美元。换句话来说，#5的账户余额增加了 1 美元，同时没有任何人的账户余额有所减少。这就是比特币变为现实的方式。它是在区块链（比如：分散式的账簿）上被用来交易的第一种货币。同时，人们被奖励以比特币作为回报，以使在网络上，（计算密封数字的）努力会继续进行。当足够多的人持有比特币，比特币会升值，使得更多人想要比特币；这会使比特币进一步升值；这升值又使更多人想要比特币；这愿望又进一步使比特币升值；如此循环往复。这种奖励，使得网络中的每一个人都不停歇地工作一旦每个人都往文件夹中叠进一页纸，他们会拿出一页空白纸张，再一次重复整个过程——直至永远。 [术语箱] 将一页纸想象为记录交易的一个区块、把文件夹想象为纸张（区块）的链条，结果是，它变身成了一个区块链。老铁，这就是区块链的工作方式。然而。我还有一件小事没有告诉你。想象文件夹中已经有 5 页纸——都被一个密封数字加密了。如果我回溯到第二页纸、改动交易记录以谋私，会怎么样？密封数字会让任何人察觉到交易记录中的矛盾，对吗？那假如我更进一步、为修改后的交易记录计算出了一个新的密封数字、将这替代品戳到纸上呢？为了防止这个问题，即有人回溯并且修改纸张（区块）和密封数字，这里还有一个解释，关于一个密封数字是怎么计算出来的。防止对密封数字的修改还记得我是怎么跟你说的吗？我给了你两个盒子——一个装着数字 20893，另一个空的让你来计算？实际上，为了在区块链上算出密封数字，有三个盒子，而非两个——两个提前装好的，一个被用来计算的。而当所有三个盒子里面的内容加起来、输入魔法机器后，从机器右边出来的答案必须满足要求的条件。我们已经知道了，一个盒子装着交易记录的清单，一个盒子将装着密封数字。而第三个盒子，装着前一张纸的魔法机器输出值。有了这个优雅的小心机，我们可以保证，每一页纸张都依赖于它之前的纸张。因此，如果有人要修改一张历史记录，他将同样必须改变该页以后所有纸张的内容和密封数字，以使这条链保持一致。如果某个人，不属于我们在一开始设想的 10 个人，试图作弊，修改区块链（保存了所有交易记录清单纸张的文件夹）中的内容，他将不得不调整多页纸张、为所有这些纸张计算新的密封数字。我们都知道计算密封数字有多么困难。因此，这网络中的一个坏蛋欺负不了九个老实人。将会发生的事情是，从这个不诚实的家伙尝试作弊的那一夜开始，他将要在这网络中创造另一个区块链，但那个区块链将永远无法赶上可信的区块链——仅仅因为一个家伙的努力和速度不可能战胜九个人积累起来的努力和速度。因此，这保证了在一个网络中，最长的链就是可信的链。最长的链就是诚实可信的链。当我告诉你一个不诚实的家伙没法欺负九个实诚人的时候，它是否点醒了你什么？万一，不是一个，而是六个人搞事情呢？在这种情况下，这个协议将会落空，流于表面。它就是人们所知的“51%攻击”。如果该网络中的大部分人决定变得不诚实并且欺骗网络中剩下的人，这个协议将无法实现它的目标。任何时候，如果区块链可能会陷落，这就是其脆弱性的唯一原因。知道了这一点，它也就不太可能发生了。但是，我们所有人都必须知道这个系统的这个弱点。它建立在这样的假设之上：一群人中的大部分都总是诚实的。老铁。这就是有关区块链的一切。任何时候你发现有人感觉落后了、感到迷茫，“区块链到底是什么鬼？”你知道你可以指引他们到哪里去。给这个链接做个书签。想到了某些人现在正应该读读这篇东西？“分享”按钮就在你手上。原文链接: https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348作者: Mohit Mamoria翻译&amp;amp;校对: 阿剑 &amp;amp; Elisa你可能还会喜欢：怎样从基本原理解释复制型共享账本的价值从比特币到以太坊：比特币区块链科普 | 以太坊到底是啥？" }, { "title": "Blokchain1", "url": "/posts/blokchain1/", "categories": "", "tags": "", "date": "2022-02-08 00:00:00 +0800", "snippet": "2022-02-08-blokchain1.markdown -http://www.forexnewsnow.com/top-stories/bitcoin-2016-summary-2017-forecasts/-除非你是山顶洞人，我确信你已经听说了比特币（Bitcoins）和区块链。毕竟，它们是热点，是这几天媒体最喜欢的话题，也是年度流行词。连那些从来没有听过加密货币（cryptocurrency）、根本不知道它如何运行的家伙们也在谈论它。我的朋友中，非技术宅可比技术宅要多。为了让我给他们解释这个新流行词，他们已经骚扰我好几个星期了。我猜，成千上万人跟我有着同样的感受。当这种情形出现，是时候要写一些东西了，好让每个人都能戳醒那些糊涂蛋——这就是这篇推送的目的——以浅白的英文写作，让任何普通的网友都能理解。区块链：为什么我们需要这么复杂的东西？“每一个复杂的问题都有一个清晰、简单并且是错误的答案。”——H.L.Mencken*与互联网上的其它任何推送相反，我们不会一开始就定义什么是区块链，我们会先认识它要解决的问题。想象一下，Joe 是你最好的朋友。他正在海外旅游。在他假期的第五天，他给你一个电话，“Dude，我把钱花光了，江湖救急。”你回答”马上汇款“然后挂掉电话。然后你打电话给你银行账户的经理，”请从我的账户转 1000 美元到 Joe 的账户上“。你的账户经理回复，”收到，先生“。他打开账簿，查看你的账户以确定你有足够的余额转出 1000 美元给 Joe。因为你是个土豪，账上还有大量余额，因此，他在账簿上登记了一个条目，正如下图所示：注意：我们不提计算机，只是为了让例子简单一点。你打电话给 Joe，告诉他，“我已经转账了。下一次你去银行的时候，你就可以取出我刚刚转过去的 1000 美元。”发生了什么事？你和 Joe 都委托银行来管理你们的钱。并没有物理票据的实际流动来转移你们的钱。所需的一切不过是账簿上的一个条目。或者更准确一点，账簿上的一个既不受你和 Joe 控制、也不被你们所拥有的条目。这就是现有体系的问题。为了在我们之间建立互信，我们依赖于独立第三方。多少年了，我们依赖于这些中介以信任彼此。你也许会问，“依赖他们有什么毛病？”毛病在于，它们清一色只是数字。要在社会上引发一场混乱，所需的不过是一个人或者一个机构走向贪腐堕落，无论是有意识地，还是无意识地。要是记录下这笔转账的账簿在一场大火中烧成灰烬了呢？要是，你的银行经理搞错了，写了个 1500 美元而不是 1000 美元呢？要是，他根本就是有意为之呢？多年以来，我们一直把自己所有的鸡蛋都放在一个篮子里，并且还是别人的篮子。会有这样一个系统吗，在那里我们无需银行就可以转账？要回答这个问题，我们需要挖得更深，问自己一个更好的问题（毕竟，只有更好的问题才会导向更好的答案）。想一下，转账意味着什么？只是账簿上的一个条目而已。那么更好的问题将是——是否有某种手段，可以在我们中间维护那本账簿，而不是让其他人来为我们操作？现在，总算有一个值得探究的问题了。而答案你或许已经猜到了。区块链就是这个深奥问题的答案。它就是一种在我们中间维护账簿而非依赖其他人来为我们代劳的方法。你能跟上来吗？很好。因为现在许多问题已经开始在你脑海中爆炸，我们将学习这一分散式账簿是如何工作的。好吧，告诉我，它是怎么工作的？这一方法的要求是：必须有足够的人不想依赖第三方。只有这样，这群人才能靠自己来维护他们的账簿。“只让人们在比特币带来的交易中获取比特币，或许是有意义的。一旦有足够的人这样想，它就会变成一个自我实现的预言。”——中本聪，2009*多少人才算是够？至少要 3 个。打个比方，我们假设有 10 个人想抛弃银行以及任何第三方。根据相互之间的协议，他们可以一直拥有彼此的账号信息——但不知道其他人的真实身份。1.一个空的文件夹一开始的时候，每个人都掌握着一个空文件夹。正如我们要进行的那样，这 10 个人都将持续向他们的当前的文件夹中添加纸张。而这些纸张的集合将形成追踪交易的账簿。2.一笔交易发生的时候然后，这个网络中的每个人都将有纸笔在手。每个人都准备着记录下该系统内部发生的任何交易。现在，假设 #2 想要转 10 美元 给 #9。为了完成这次交易，#2 吼了一嗓子，告诉每个人，“我想转 10 美元给 #9。大家都在自己的小本本上记下来！”每个人都瞄一下 #2 是不是有足够的余额可以转 10 美元给 #9。如果她有足够的钱，每个人都在自己的空白页上为这笔交易做了一个记录。这样，一笔转账就被认为是完成了。3.交易继续发生时间过得很快，这个网络中的更多人想要转账给其他人。无论什么时候他们想要做一笔交易，他们就向其他所有人宣告这笔交易。无论是谁，一听到这个宣言，就在他/她自己的纸张上写下来。这样的实践持续进行，直到每个人都用完了他们当前页的空间。假设 1 页纸可以记录 10 笔交易，一旦10笔交易完成，每个人就都用完了空间。-纸张被写满的时候-那么，是时候该将这页纸存到文件夹里面，然后拿出一张新的纸、重复上述步骤2了。4.存放纸张在你将这页纸存入我们的文件夹之前，我们需要使用该网络中每个人都同意的唯一一把钥匙来密封它。通过密封，我们可以保证，一旦该页纸的备份已经被存入每一个人的文件夹，没有人能够对它作出任何更改——不止今天，不止明天，也不止是一年以后。一旦放入文件夹中，它将永远呆在文件夹里面——被封存起来。而且，如果每个人都信任这个封条，那么每个人都会相信该页纸中的内容。而这页纸的封存手法，就是这一方法的关键。[术语箱] 这一用来保护纸张内容的东西被人们称为“矿”，但为了简化它，我们还是称之为“封条”。早些时候，第三方/中介为我们赋予信任，其形式是：无论它们在账簿上已经写了什么，都永远不可变更。在一个分散式的、去中心化的系统中，就像上述我们的系统一样，这种封条将提供信任替代。因缺斯汀！那我们怎么密封这份记录呢？在我们学习如何能密封这页纸之前，我们要知道，一般而言，封条是怎么工作的。要做到这些，先决条件是学习一些东西，我喜欢称之为……魔法机器想象一个被厚墙围起来的机器。如果你从左边塞一个存有东西的盒子进去，它就会吐出一个带着其它东西的盒子。[术语箱] 这个机器被称为“哈希方程”，但我们又没有心情搞得那么专业。所以，今天，它们就叫“魔法机器”。-魔法机器（又叫做 哈希方程）-假设，我们从左边塞了个数字 4 进去，我们会发现，它在右边吐出了下列字串：‘dcbea’。数字 4 是在怎么转化成这串字符的？没有人知道。而且，这个过程是不可逆的。得到了这串字符 ‘dcbea’，也不可能搞清楚这机器从左边接收到了什么。但是，任何时候，你输入数字4给这台机器，它都总是会吐出同样的字符，‘dcbea’。- hash(4) == dcbea -来试试发送一个别的数字进去。26，怎么样？- hash（26）==94c8e -这次我们得到了 ‘94c8e’，看来字符同样可以包含数字。有意思！假如我现在问你如下问题，事情会变成什么样？“你能不能告诉我，要想在机器右边得到三个 0 开头的一串字符，我该从左边输入什么东西进去呢？比如，000ab，或者，00098，或者，000fa，或者其它情况中的任何一个。”想一想这个问题吧。我已经告诉过你，这台机器有个属性：在我们从右边得到期望的输出值之后，我们无法计算出来什么是我们必须从左边输入进去的。给我们这样一台机器，我们如何能回答我问的那个问题？我可以想出一个办法。为什么我们不一个接一个地遍历宇宙中所有数字，直到我们得到一个三个 0 开头的一串字符？-尝试所有数字以算出需要的输入值-乐观估计，经过几千次尝试之后，我们最终会得到将在右边产生要求的输出值的一个数字。在给定输出值的时候，要算出输入值是极其艰难的。但与此同时，如果预测的输入值可以产生需要的输出值的话，它又是极为容易验证的。要记住，投入一个同样数字，这台机器每一次都会吐出同样的字符。如果我给你一个数字，比如 72533，然后问你一个问题：“这个数字，输入这台机器之后，会产生一个以三个 0 开头的字符串吗”，你觉得要得出答案有多难呢？你要做的一切，不过是丢这个数字进去，然后查看我们在右边得到了什么。就这样。这样的机器最重要的属性就是——“给定一个输出值，要算出输入值是极端困难的。但是，给定输入值和输出值，要检验该输入是否会导致该输出，却是非常容易的。”在这片文章剩下的部分，我们要记住这台魔法机器（或者说哈希方程）的这一属性：“给定一个输出值，要算出输入值是极端困难的。但是，给定输入值和输出值，要检验该输入是否会导致该输出，却是非常容易的。”如何用这样的机器来加密一份文件？我们将使用这台魔法机器为我们的纸张产生一个密封条。按照惯例，我们将从一种想象的情形开始。想象我给你了两个盒子。第一个盒子装着数字 20893。然后我问你，“你能不能找出一个数字，加上装在第一个盒子里面的数字以后，输进这台机器，最终会给我们一个以三个 0 开头的字符？”这种情形跟我们在之前看到的很相似，而我们已经知道，算出这样一个数字的为唯一方法就是穷举整个宇宙中每一个可能的数字。又是几千次尝试之后，我们会偶然发现一个数字，比如 21191，加上 20893 以后（比如：21191+20893 = 42084）输入机器，将产生一串符合我们要求的字符。在这个例子中，数字 21191 就成了数字 20893 的封条。假设现在有一张纸，数字 20893 写在上面。为了密封这页纸（比如：使得没有人能更改这页纸上的内容），我们将盖一个带有标签 ‘21191’ 的徽章在上面。一旦密封数字（比如：21191）被戳在纸上，这页纸就被密封了。-密封数字-[术语箱] 密封数字又被称为“工作量证明”，意思是，这一数字证明了为了计算出它来已经付出的努力。为了我们的目的，我们最好还是称之为“密封数字”。如果任何人想验证这页纸是否已经被替换了，他需要做的一切不过是——将这页纸上的内容与密封数字加在一起、把和值输入那台魔法机器。如果机器给出了一串三个 0 开头的字符，那么内容就没有被改变。如果出现的字符不能满足我们的要求，我们就可以丢掉这页纸了，因为它的内容已经有了水分，没有任何用处了。我们将使用一个简单的密封机制来封存所有的记录，最终在我们各自的文件夹中编排好它们。最后，封存我们的文件要密封包含着我们网络中交易内容的记录，我们将需要算出一个数字，该数字在添加到交易记录清单上、输入机器以后，可以使我们得到一串三个 0 开头的字符。注意：我一直在使用的“三个 0 开头的字符”，只是一个例子。它阐明了哈希方程是怎么工作的。实际当中的挑战要比这个复杂得多。我们会在这机器上花费时间与电力，然而一旦我们算出那个数字，这页文件就被那个数字封存起来。永远永远，如果有人尝试改变这页纸上的内容，这个密封数字允许任何人去验证这页纸的完整性。现在，我们既已知道封存记录的手法，我们将回到我们在这张纸上写完了 10 条交易、没有空间书写更多记录的时候。一旦每个人都用尽一页纸的空间、无法记录进一步的交易，他们就开始卖力地计算该页纸的密封数字，使得它可以被藏入文件夹中。在网络中，每个人都进行这个计算，而最早算出密封数字的那个人会向其他所有人宣布这个数字。听到密封数字之后，每个人都立即验证它是否能产生要求的输出值。如果是的，每个人都为他们的纸张标上这个数字，然后把纸张放入文件夹中。但是，如果对某人，比如 #7 来说，那个被宣布的密封数字无法产生要求的输出值，怎么办？这种情形可并不少见。可能的原因有：他可能听错了之前在网络中宣布的交易他可能写错了之前在网络中宣布的交易他可能在记录交易的时候试图作弊，为了谋私，或为讨好网络中的某些人无论原因是什么，#7 只有一个选择——放弃他的记录、从其他人处获得拷贝，以使他也可以将纸张放入文件夹。除非他不将他的纸张放入文件夹，他也就无法继续记录进一步的交易，这会因此禁止他成为网络中的一员。大部分人同意的密封数字，无论是它是什么，都会成为那个可信的密封数字。可是，如果他们知道其他人会算出它然后宣布它，为什么每个人都要耗费资源来进行计算呢？为什么不坐视不理、等着抱大腿呢？好问题。这就是激励加入到这幅图景的地方。每一个区块链的成员都有资格获得奖励。第一个计算出密封数字的人将得到免费的金钱作为对他的努力（比如：付出的 CPU 算力和电力）的奖励。简单地设想一下，如果 #5 为一页记录算出了密封数字，他得到了一些免费的钱作为奖励，假设是凭空铸造出来的1美元。换句话来说，#5的账户余额增加了 1 美元，同时没有任何人的账户余额有所减少。这就是比特币变为现实的方式。它是在区块链（比如：分散式的账簿）上被用来交易的第一种货币。同时，人们被奖励以比特币作为回报，以使在网络上，（计算密封数字的）努力会继续进行。当足够多的人持有比特币，比特币会升值，使得更多人想要比特币；这会使比特币进一步升值；这升值又使更多人想要比特币；这愿望又进一步使比特币升值；如此循环往复。这种奖励，使得网络中的每一个人都不停歇地工作一旦每个人都往文件夹中叠进一页纸，他们会拿出一页空白纸张，再一次重复整个过程——直至永远。[术语箱] 将一页纸想象为记录交易的一个区块、把文件夹想象为纸张（区块）的链条，结果是，它变身成了一个区块链。老铁，这就是区块链的工作方式。然而。我还有一件小事没有告诉你。想象文件夹中已经有 5 页纸——都被一个密封数字加密了。如果我回溯到第二页纸、改动交易记录以谋私，会怎么样？密封数字会让任何人察觉到交易记录中的矛盾，对吗？那假如我更进一步、为修改后的交易记录计算出了一个新的密封数字、将这替代品戳到纸上呢？为了防止这个问题，即有人回溯并且修改纸张（区块）和密封数字，这里还有一个解释，关于一个密封数字是怎么计算出来的。防止对密封数字的修改**还记得我是怎么跟你说的吗？**我给了你两个盒子——一个装着数字 20893，另一个空的让你来计算？实际上，为了在区块链上算出密封数字，有三个盒子，而非两个——两个提前装好的，一个被用来计算的。而当所有三个盒子里面的内容加起来、输入魔法机器后，从机器右边出来的答案必须满足要求的条件。我们已经知道了，一个盒子装着交易记录的清单，一个盒子将装着密封数字。而第三个盒子，装着前一张纸的魔法机器输出值。有了这个优雅的小心机，我们可以保证，每一页纸张都依赖于它之前的纸张。因此，如果有人要修改一张历史记录，他将同样必须改变该页以后所有纸张的内容和密封数字，以使这条链保持一致。如果某个人，不属于我们在一开始设想的 10 个人，试图作弊，修改区块链（保存了所有交易记录清单纸张的文件夹）中的内容，他将不得不调整多页纸张、为所有这些纸张计算新的密封数字。我们都知道计算密封数字有多么困难。因此，这网络中的一个坏蛋欺负不了九个老实人。将会发生的事情是，从这个不诚实的家伙尝试作弊的那一夜开始，他将要在这网络中创造另一个区块链，但那个区块链将永远无法赶上可信的区块链——仅仅因为一个家伙的努力和速度不可能战胜九个人积累起来的努力和速度。因此，这保证了在一个网络中，最长的链就是可信的链。最长的链就是诚实可信的链。当我告诉你一个不诚实的家伙没法欺负九个实诚人的时候，它是否点醒了你什么？万一，不是一个，而是六个人搞事情呢？在这种情况下，这个协议将会落空，流于表面。它就是人们所知的“51%攻击”。如果该网络中的大部分人决定变得不诚实并且欺骗网络中剩下的人，这个协议将无法实现它的目标。任何时候，如果区块链可能会陷落，这就是其脆弱性的唯一原因。知道了这一点，它也就不太可能发生了。但是，我们所有人都必须知道这个系统的这个弱点。它建立在这样的假设之上：一群人中的大部分都总是诚实的。老铁。这就是有关区块链的一切。任何时候你发现有人感觉落后了、感到迷茫，“区块链到底是什么鬼？”你知道你可以指引他们到哪里去。给这个链接做个书签。想到了某些人现在正应该读读这篇东西？“分享”按钮就在你手上。原文链接: https://hackernoon.com/wtf-is-the-blockchain-1da89ba19348作者: Mohit Mamoria翻译&amp;amp;校对: 阿剑 &amp;amp; Elisa你可能还会喜欢：怎样从基本原理解释复制型共享账本的价值从比特币到以太坊：比特币区块链科普 | 以太坊到底是啥？" }, { "title": "Web什么Three？", "url": "/posts/web3/", "categories": "Thinking", "tags": "blockchain", "date": "2022-01-12 19:15:00 +0800", "snippet": "与元宇宙(Metaverse)相比，我一直更喜欢Web3的这个称呼。为什么呢？元宇宙这三个字给人一种太强的“神经感”，想想这句话，今天我在xxx元宇宙认识一个xxx，是不是总觉得哪里不太对。但是Web3的感觉就是更舒服一些。那Web3到底是个什么样子？现在没人能说清楚。我不是魔术师也没法预知未来。但是我还是试图从技术基础的角度是来聊一聊Web的历史，现在和未来。The history of Web一切人类社会形式的变化，有依赖技术基础的革新。在三体中，三体人通过锁死技术的发展，来锁死人类发展。Web的诞生，发展和演进同样也是建立在技术发展的基础之上。1989 Tim Berners-Lee和Robert_Cailliau共同发明了Web，使用HTML语言来描述Web页面，使用HTTP来访问Web页面, 使用URL来定位Web页面。世界进入Web1.0的时代。Web1.0Web1.0是静态网页的时代，这些页面由后台服务生成。这些信息发布到互联网上，人人都可以访问到。自此信息和内容传播的效率大大提升，人们获取信息的成本大大下降。例如这篇文章也是发布在我的blog上，我的blog使用了Jekyll这个工具，这个工具可以方便的生成静态网站并发布在互联网上，让人人都可以看到它。Web1.0时代，内容更多是由机构或者有能力的技术极客发布，毕竟对于普通人来说setup一个个人站点还是有难度的。对于大众来说，Web1.0更多是读取内容。所以如果要选一个词来描述Web1.0时代，那就是Read。Web2.0随着技术的发展和演进，特别是Ajax技术，动态网页技术，Javascript技术的发展。Web页面从简单的静态页面变得越来越丰富多彩，越来越多的交互在Web页面中呈现，Web进入2.0时代。Web2.0时代人们不再是简单的读数据，人们也可以任意的写入数据，例如在fabebook上发布一个自己的动态，在Ins上分享一张照片。由此人们就可以不仅仅是获取信息，并且可以方便的发布信息。互联网的内容变得无比丰富起来，也同时不断改变着人类生活和生产的方式。Web2.0从Read进化到Read，Write。起源iPhone的移动互联网也是Web2.0这个浪潮的一部分，因为不论从技术还是形式上依旧是Web2.0的延续和扩展。我们现在依旧在Web2.0的时代中。现在看Web2.0的时代已经足够完备了，人们似乎可以在互联网上满足自己的一切需求，那么这是否就是互联网的完美大厦已经达成，未来只是些修修补补呢? Web2.0时代有没有那几朵乌云呢？我认为还是有那么几朵“乌云”的？所有权“乌云”: 数据是属于谁的？数据归属权到底是谁的？是创作者的还是所有这些平台的？你在Facebook上的post，在通讯工具里的聊天记录，在instgram上的照片，在ticktok里的视频，所有权属于谁？这些所有权又是由谁来保证的。围墙“乌云”？互联网诞生之初，精髓是开放的，任何资源都可以用hyperlink的方式链接起来，可是发展到现在，Web已经发展成为几个巨人公司的内部花园。围墙高高建起，尤其国内更是这样。这种情况相信大家都有感受，也就不展开了。用户？客户？平台？Web时代之前商业关系是相对简单的。公司生产产品或者服务，客户对产品或者服务用钱买单。Web2.0以后的商业关系就变得有些复杂了，例如与滴滴或者Uber来说，滴滴司机和滴滴公司是什么关系？滴滴司机可以说是滴滴网络上的核心因素，但是他们很少或者基本和滴滴公司没有什么关系。这种商业关系是否有问题？以上就是我认为Web发展到2.0时代以来几个未解决的问题。这些问题如何解决呢？我觉得这些问题应该是要Web3.0来回答和解决的问题。Web3.0我认为Web3.0的底层技术是Blockchain，Web3.0的开端为Bitcoin。有些人认为Bitcoin并不是Web3.0，但是我并不这么认为。Bitcoin带来的基于密码学的身份和权益认证方法，第一个开放的全球网络。以太坊的出现更是在Blockchain中开启了一个完备的计算平台。为什么说区块链技术是Web3.0的基础呢？Blockchain的非对称加密体系为自主身份，数据自主提供了解决方案。在Blockchain网络中，所有的资产都锁定在地址上，只有对应的私钥可以解锁这个地址的资产，所以只要用户保存好自己的私钥，那么所有的数据，资产都有自己掌握。Blockchain是一个开放的网络，任何人都可以接入都这个网络中，网络不属于任何一方。Blockchain的技术特别是智能合约的技术，为新的商业关系提供可能性。如果要用一个词来的描述Web3.0，那么我理解是Own。用户可以真正的拥有他的数据，他的资产。Web1.0 - ReadWeb2.0 - Read，WriteWeb3.0 - Read，Write，Own未来是否已来？拭目以待。" }, { "title": "惊鸿一瞥：捕猎以太坊黑暗森林中的&#39;那只怪兽&#39;", "url": "/posts/nonce-reuse/", "categories": "Learning", "tags": "blockchain", "date": "2022-01-09 19:15:00 +0800", "snippet": "作为区块链安全领域从业者，我对密码学和安全一直都有着强烈的兴趣，上周看了一篇非常不错的文章，在和作者联系取得同意后，翻译成了中文，与感兴趣的朋友一起分享一下。下边就是原文:上周，以太坊黑暗森林里的一只怪兽终于向我露出了他的獠牙。在与tux交流后，我得知了这只怪兽的存在，于是投下了“我的诱饵”，16个小时之后它如期上钩。在Etherscan上看到我消失的ETH，仍旧心有余悸。这只怪兽一直在注视着以太坊网络，试图寻找以太坊交易中那个不为人注意的错误：签名中的k值复用。为了找到这只怪兽，我引诱它出现。为了理解我是怎么做到的，一些关于椭圆加密曲线签名算法(ECDSA）和数字签名的知识需要先介绍一下。ECDSA椭圆曲线的数字签名算法（ECDSA）是支撑当今最大的两个区块链，Bitcoin 和 Ethereum的密码学基础。就如同在现实中，人们用自己的签名来证明自己的权益，基于ECDSA的数字签名可以证明这些区块链上的数字资产的所有权。数字签名可以提供下边两个方面的证明： 对于私钥的所有权。每把私钥都有与之绑定的一把公钥，这把公钥同时也用来生成在区块链上的一个“地址”。 使用私钥对于一个消息的签名。在区块链的上下文中，这个消息就是交易。ECDSA之所以有效是因为，我们可以使用私钥非常容易的得到公钥，但是无法（或者说很难）从公钥去推到出私钥。但是如果得到了数字签名，在一些条件下是可以推导出私钥的。下边让我们聊一点技术细节。如果要完成对某个消息的签名，我们需要使用私钥d，一个随机值k，以及这个消息的哈希h。同时加上椭圆曲线中的G和n, 经过下边的公式计算，我们可以得到这个消息的数字签名r和s。\\[r = k * G\\ mod\\ n \\\\s = \\frac{h+d*r}{k}\\ mod\\ n\\\\\\]r和s一起就是这消息数字签名。nonce是什么？在椭圆加密算法中，计算数字签名的随机k值是非常关键的。k值永远不能暴露，并且一个k值永远只能使用一次。这就是随机k值被称为nonce的原因。下文中也会用nonce来指代k值。如果黑客知道了某个签名对应的k值，那么它就可以通过以下的公式推算出这个签名的私钥。\\[d = (s*k - h) * r^{-1}\\ mod\\ n \\\\\\]同样，如果nonce被在两个不同的签名中重复使用，这个nonce(k值)同样也可以通过以下公式被推算出来\\[k = (h_1 - h_2) * (s_1 - s_2)^{-1}\\ mod\\ n \\\\\\]有了nonce就可以通过上边的公式来推算出私钥。那在实际中我们如何判断有没有nonce重复使用呢？我们回忆一下，在ECDSA 数字签名中r的计算过程 r = k * G mod n. 这个公式中G和n都是确定的，唯一变量就是k，所以如果用同一个私钥签两个不同消息，在得到的签名中r是一样的，那么就可以判断出有nonce重复使用的问题。在了解了这些后，我们来看看以太坊上的交易，如果一个地址下的两笔交易的签名有相同的r值但是s值不同，那么可以判断这个地址下有nonce重复使用的情况。这就是“那只怪兽”一直的关注点。也是我下边所用的实验方法。Note：对于普通的用户来说，只要选择靠谱的钱包，你不要关心nonce泄露和重复使用的问题。但是对于区块链开发者来说，这些是需要了解和注意的。下饵，引蛇出洞为了引蛇出洞，找到这只怪兽，我构造了两笔交易，这两笔交易的签名使用了相同的nonce，所以他们签名会有相同的r值。我在这个地址上留了点ETH，所以如果有任何人盯着这个地址，那么它就可以通过签名推算出私钥来转走这个地址上的ETH。为了制作这些诱饵，我必须构造出两笔nonce重复使用的交易，当然你没法使用Metamask来达到这个目的。于是我使用ether.js来达到这个目的。来看下边的示例代码。var drbg = new HmacDRBG({ hash: this.hash, entropy: bkey, nonce: 1, // changed from &quot;nonce&quot; pers: options.pers, persEnc: options.persEnc || &#39;utf8&#39;, });(代码仅供参考示例，别在自己的钱包上试)在这里我把nonce设为了1！然后我重新生成了一把私钥，并在地址上充了0.04ETH，然后我使用下边的脚本，生成了两笔交易const ethers = require(&quot;ethers&quot;) async function main(){ const privateKey = &quot;not-leaking-it-this-way&quot; let wallet = new ethers.Wallet(privateKey) console.log(&quot;Using wallet:&quot;, wallet.address) const provider = new ethers.providers.JsonRpcProvider(&quot;rpc-endpoint&quot;) let signer = wallet.connect(provider) const tx = await signer.sendTransaction({ to: wallet.address, value: ethers.utils.parseEther(&quot;0&quot;).toString(), gasLimit: 45000, }) console.log(tx) } main()由于我把nonce设为了1, 所以这两个交易的签名是有相同的r，和不同的s值。写了一个简单的脚本验证了一下：robert@mbp nonce-reuse-bait % node get_r_s.js Transaction 1 r: 0x340709f674d030dda4aa8794bffb578030870bdfe583e7f41aea136a7ca1ed94 s: 0x3e5b92d8c5a2a033c9e5eb53ff2946681b28ab82fa5b17d0a9c48d139e78fe2c Transaction 2 r: 0x340709f674d030dda4aa8794bffb578030870bdfe583e7f41aea136a7ca1ed94 s: 0x2c17cf960d1af7602f875afc56d01eddcc67bb03e962877444ed8d4c1287ab7a随着这两笔交易的上链，签名私钥其实已经暴露了。我已经把饵下好，现在就静静地等待那只怪兽的上钩。惊鸿一瞥，怪兽出没当发送完这两笔交易后，我就不断的刷新区块浏览器来观察地址上的ETH是否还依旧存在。但是奇怪的事，一切如常。又过了几个小时，依旧一切如常。我都开始怀疑是不是自己搞错了什么，但是天色已晚，我就先去休息了。第二天早上一早，我就查看我的账户，它出现了！我地址上的ETH被取的干干净净，我故意留在地址上的0.04个ETH被取走了！那只怪兽终于露出了獠牙，他注视着以太坊上的交易, 看是不是有交易的签名有相同的r值。当他发现以后就去推算他们的私钥，取空他们账户上的所有资产。我有点疑惑的是，为什么过了这么久它才出动？有一种可能性是它一直在默默等待，看这个账户上会不会有更多的资产转进来，它好一次性的都转走。让我们近距离的看看这只怪兽，我不仅仅是唯一的受害者，它同样也取干了别人的资产！这个地址一直有从不同地址下转入的ETH，截止目前这个账户上有价值$3,700的资产。为了验证这些被盗地址是否也有nonce重复使用的问题，我写了一个脚本来检查他们历史上交易检查是否也有相同的r值。我检查这只怪兽（黑客）盗取的第二地址，发现它之前发送的交易也存在r值重复使用的问题。robert@mbp nonce-reuse-bait % node get-tx-history.js Same r found! r: 0xf0d7b10f398357f7d140ff2be1bea9165d32238360ad0f82911235868be7c6e1 hash: 0xb5d2454d7380bfa7ac75ec76f15eecb56e60941429153081fe799fb53a7ff901 r: 0xf0d7b10f398357f7d140ff2be1bea9165d32238360ad0f82911235868be7c6e1 hash: 0x9e459be7fa9950835a3c2594d3440c684fed05fa8e12e8088cc7776c4afb364c Same r found! r: 0x41d43fd626c24e449ac54257eeff271edb438bbabbc9bee3d60a5bd78dc39d6d hash: 0x670f66ff71882ae35436cd399adf57805745177b465fdb44a60b31b7c32e4d16 r: 0x41d43fd626c24e449ac54257eeff271edb438bbabbc9bee3d60a5bd78dc39d6d hash: 0x374180005946ef3b1906ee1677f85fa62eb5a834aa0241b4c9c74174bca26a07这进一步证明了我的猜测，这只怪兽紧紧盯着以太坊上的交易，时刻关注着是否有nonce复用的情况。一旦发现了nonce复用，它会慢慢的，悄悄地把这些地址上的资产都取光。在我分析了这只怪兽攻击的其他地址后，我惊奇的发现有些地址并没有nonce重复使用的问题，事实上在它攻击的20个地址里，有9个存在nonce重复使用的问题，而其他并没有。那么其他11个地址是什么因为什么遭到了攻击呢？老实来说我并不清楚，一种可能性是这只怪兽同时还有其他策略去尝试推算私钥，例如用常见的一些单词，数字来推算私钥。同时还有一些其他的方法来利用nonce生成中的漏洞。但是我并没有从这只怪兽的行为中找到证明。以太坊黑暗森林里的这只怪兽终于被我找到，但是会不会有或者谁是它的下一个受害者？这依旧是个谜题。Aaron简评：私钥生成不随机，nonce生成不随机，nonce重复使用这些问题都会有泄漏的可能性。对于用户来说，选择靠谱的钱包是避免这个问题的最好的方法，尤其推荐使用有真随机数生成器的硬件钱包。对于开发者来说，重视随机数的产生，选择靠谱的cryptographic library。同时使用确定性ECDSA签名算法也是避免这个问题的另一种方式。" }, { "title": "天价交易费的分析与思考-如何复现一笔交易费为7676ETH的交易", "url": "/posts/tx-fee/", "categories": "Thinking", "tags": "blockchain", "date": "2021-10-01 19:15:00 +0800", "snippet": "天价交易费的分析与思考-如何复现一笔交易费为7676ETH的交易2021年9月27号一笔7676ETH的交易的出现引爆了整个加密货币社区.到底是什么原因出现的这一笔交易引起了诸多猜测。2天后也是9月29号交易的发出者Deversifi在其网站上纰漏了更多细节，以及事故分析。作为一名老前端者，安全研究爱好者，作者第一时间阅读了这片文章。下边带大家一探究竟尝试解释一下这笔交易的由来。背景Deversifi在不久之前讲交易类型升级到EIP-1559的交易，并且它的前端支持连接Metamask和Ledger两种钱包。然而这两种钱包交易构建的方法是非常不同，对于Metamask来说，交易构建是Metamask来负责的，Dapp开发者基本不用操作什么。而对于ledger来说，Dapp需要自己构建交易，构建完成后传给Ledger进行交易的签名。目前Dapp开发者基本都会使用“@ethereumjs/tx” 来构建交易。下边就是官方文档给出的构建交易的事例代码。import Common, { Chain, Hardfork } from &#39;@ethereumjs/common&#39;import { FeeMarketEIP1559Transaction } from &#39;@ethereumjs/tx&#39;const common = new Common({ chain: Chain.Mainnet, hardfork: Hardfork.London })const txData = { &quot;data&quot;: &quot;0x1a8451e600000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;, &quot;gasLimit&quot;: &quot;0x02625a00&quot;, &quot;maxPriorityFeePerGas&quot;: &quot;0x01&quot;, &quot;maxFeePerGas&quot;: &quot;0xff&quot;, &quot;nonce&quot;: &quot;0x00&quot;, &quot;to&quot;: &quot;0xcccccccccccccccccccccccccccccccccccccccc&quot;, &quot;value&quot;: &quot;0x0186a0&quot;, &quot;v&quot;: &quot;0x01&quot;, &quot;r&quot;: &quot;0xafb6e247b1c490e284053c87ab5f6b59e219d51f743f7a4d83e400782bc7e4b9&quot;, &quot;s&quot;: &quot;0x479a268e0e0acd4de3f1e28e4fac2a6b32a4195e8dfa9d19147abe8807aa6f64&quot;, &quot;chainId&quot;: &quot;0x01&quot;, &quot;accessList&quot;: [], &quot;type&quot;: &quot;0x02&quot;}const tx = FeeMarketEIP1559Transaction.fromTxData(txData, { common })一探究竟从例子上看似乎没什么问题，只要将txData的参数传对，应该也不会出现什么问题。那到底这个天价交易是如何出现的？我们来通过代码一探究竟。public constructor(txData: FeeMarketEIP1559TxData, opts: TxOptions = {}) { ... this.maxFeePerGas = new BN(toBuffer(maxFeePerGas === &#39;&#39; ? &#39;0x&#39; : maxFeePerGas)) this.maxPriorityFeePerGas = new BN( toBuffer(maxPriorityFeePerGas === &#39;&#39; ? &#39;0x&#39; : maxPriorityFeePerGas) )上边是FeeMarketEIP1559Transaction的constructor函数，我们注意maxPriorityFeePerGas和maxFeePerGas都是将传入的字符串转成Buffer对象，然后创建了一个BN的对象用于后续计算。从文档中看@ethereumjs/tx的开发者应该是期望上述两个参数都应是string类型，并且源码中的类型声明也是这么定义的 https://github.com/ethereumjs/ethereumjs-monorepo/blob/b0477d64c259b354ff57bab7e77be43081216fea/packages/tx/src/types.ts#L263:3那么如果传入的类型如果不是string那么会发生什么？如果传入的是一个浮点数会发生什么？从Deversifi的事故分析中我们应该也能看到，他们应该传入的并不是string，而是浮点数。要回答这个问题我们就得进入toBuffer方法中看看了。toBuffer方法是定义在ethereumjs-util中的下边是其代码片段。// ethereumjs-utilimport { intToBuffer } from &#39;ethjs-util&#39;export const toBuffer = function (v: ToBufferInputTypes): Buffer { ... if (typeof v === &#39;number&#39;) { return intToBuffer(v) }}// ethjs-util// https://github.com/ethjs/ethjs-util/blob/e9aede668177b6d1ea62d741ba1c19402bc337b3/src/index.js#L39/** * Converts a `Number` into a hex `String` * @param {Number} i * @return {String} */function padToEven(value) { var a = value; // eslint-disable-line if (typeof a !== &#39;string&#39;) { throw new Error(`[ethjs-util] while padding to even, value must be string, is currently ${typeof a}, while padToEven.`); } if (a.length % 2) { a = `0${a}`; } return a;}function intToHex(i) { var hex = i.toString(16); // eslint-disable-line return `0x${hex}`;}/** * Converts an `Number` to a `Buffer` * @param {Number} i * @return {Buffer} */function intToBuffer(i) { const hex = intToHex(i); return new Buffer(padToEven(hex.slice(2)), &#39;hex&#39;);}从代码中可以发现，如果传入的是一个浮点数，那么它会被先按十六进制转成字符串，补0使得字符串长度为偶数后用来生成对应的Buffer。例如1.53125在toString(16)就会变为’1.88’，到这一步为止一个浮点数被变为字符串。var a = 1.53125a.toString(16) &#39;1.88&#39;下一步才是真正的问题所在。问题根本下一步就是这个Buffer如何生成的了。因为Buffer是Node.js中数据类型，所以在浏览器中一般会引入响应的polyfill，用的最多的是feross/buffer, ethjs-util正是使用的是它。// feross/buffer// https://github.com/feross/buffer/blob/master/index.js#L828:10.. function hexWrite (buf, string, offset, length) { offset = Number(offset) || 0 const remaining = buf.length - offset if (!length) { length = remaining } else { length = Number(length) if (length &amp;gt; remaining) { length = remaining } } const strLen = string.length if (length &amp;gt; strLen / 2) { length = strLen / 2 } let i for (i = 0; i &amp;lt; length; ++i) { const parsed = parseInt(string.substr(i * 2, 2), 16) if (numberIsNaN(parsed)) return i buf[offset + i] = parsed } return i}对于encoding为’hex’的字符串，feross/buffer对调用上述的hexWrite来生成Buffer。关键点来了，这个函数是按两个字符为间隔来调用parseInt方法来进行转换。例如’1.88’生成的Buffer是[1,136], ‘01.8’生成的Buffer则是[1], 为什么是这样呢？因为经过按两位分割后，”1.”会被转换为1 “.8”则会返回NaN导致函数退出。MDN文档中其实已经描述的非常清楚。 If parseInt encounters a character that is not a numeral in the specified radix, it ignores it and all succeeding characters and returns the integer value parsed up to that point. parseInt truncates numbers to integer values. Leading and trailing spaces are allowed.好了，至此1.53125这个浮点数就变成了Buffer[1,136] 转化为整数为392。但是如果是1.5的话则为Buffer[1]也就1。1.53125 =&amp;gt; intToHex =&amp;gt; &#39;1.88&#39; =&amp;gt; new Buffer(padToEven(hex.slice(2)), &#39;hex&#39;) =&amp;gt; Buffer[1,136] // 3921.5 =&amp;gt; intToHex =&amp;gt; &#39;1.8&#39; =&amp;gt; new Buffer(padToEven(hex.slice(2)), &#39;hex&#39;) =&amp;gt; Buffer[1] // 1这样1.53125就摇身一变成为了392，这就天价交易费的由来，一个浮点数的巨变！到底想用多少交易费？回到那笔天价的交易来说来说，到底最初设定了多少手续费呢？最后我们尝试推测一下。从链上取得交易的数据，我们发现maxPriorityFeePerGas的值为bd28c8360cb333, 我们已经知道了这是一个错误的浮点数巨变后的值，根据上边的分析原理，小数点后的值可能为”0cb333”。 整数部分大概为bd28c836，转换为整数为3173566518，3Gwei左右感觉相对合理。" }, { "title": "好奇心, 优秀软件工程师的内核", "url": "/posts/curiosity-good-coder/", "categories": "Thinking", "tags": "life", "date": "2020-06-20 19:15:00 +0800", "snippet": "好奇心, 优秀软件工程师的内核今天是端午节假期的第二天, 最近刚好在家休养身体, 看了一些书, 最近看的一本是《程序员修炼之道》有些感悟, 今天写一些出来. 书中介绍了很多优秀工程师的特质. 我想了想, 很多的特质其实都可以指向一个内核 — 好奇心.什么是好奇心好奇心,我认为是一个优秀工程师的内核. 我们先看一下维基百科里对于好奇心的定义. 好奇（Curiosity）或是好奇心是对新的事物有兴趣，会想要探索、研究及学习的特质。对于软件工程师来说, 我们每天都在面对新的事物, 新的语言, 新的框架, 新的范式. 可以说IT领域是新的事物产生最快的一个领域. 如果想成为一个优秀的工程师, 好奇心是必备的一个特质.怎么才能算有好奇心?道理听过很多, 但是还是过不好这一生, 那么怎么才能算有好奇心, 是不是每天追逐着最新, 最热门的名词才算是有好奇心呢?我倒不认为是这样. 拥有好奇心其实非常的简单, 并不是那么的高大上. 其实就在每天平平常常的工作中, 如果你正在维护一个老旧系统, 是否好奇这套系统是如果运行起来的? 它有多少个模块, 它的设计思路是什么? 如果是你是个前端工程师, 是否好奇你每天使用的框架的设计思想, 他最新的feature, 这些feature的逻辑又是什么? 如果你在区块链行业, 是否好奇为什么人人都说比特币是第一次被验证成功的数字货币技术方案? 交易的签名是怎么一回事情? 隔离见证又是解决什么问题? 如果没有好奇心, 可能想都想不到有这样的问题, 更别说去学习, 去研究了.所以, 好奇心是一个优秀工程师的内驱力, 有好奇心才有可能不断的成长和进步. 可悲的是, 多年以来, 我们接受的教育, 在不断的损害我们的好奇心, 我们在不断的被给出问题, 要求给出答案. 反而很少的能提出问题, 主动的去思考.怎么样提高(保留)我们的好奇心既然好奇心如此的重要, 那有没有办法可以提高呢? 这个问题其实我也没有明确的答案, 例如有人就是天生好奇, 有时候别人把他称为问题Boy. 有些人可能就差一点. 天生的我们确定不了, 但是有一些方法或者方式. 我觉得还是比较的通用的. 扩大外延问问题. 如果是只负责一个模块的开发, 那扩大一下外延, 问问自己是否了解整套系统是怎么回事? 向下深挖问问题. 如果你使用一个语言, or 框架? 问问自己这门语言到底特殊在那? 和其他语言相比特点是什么? 你使用的框架解决的是什么问题? 怎么设计的? 怎么解决的? 横向比较问问题. 都是在一个领域, 为什么出现了A方案, 也有B方案,他们各自的特点是什么? 有什么优点, 有什么缺点. 多读书, 多看文章. 这些就比较散的, 从文章和书里也许你会发现自己以前没有想到过的问题或者角度, 多打开一扇门, 也是提高我们好奇心的一个方式.最后一点是对于团队的leader说的, 好奇心提高不容易但是消失可能非常容易. 所以对于leader来说, 当一个新人问你一个新问题或者“傻”问题的时候, 不要下意识的就否定掉, 这样会打击新同事的好奇心, 同时也会让团队的好奇心下降一个等级. 反之, 想一想是不是这些问题提供了一些不同的视角?希望大家都能保持住自己的好奇心, 不断的思考, 成长." }, { "title": "给工程师的实用密码学", "url": "/posts/crypto-1/", "categories": "Learning", "tags": "Cryptography", "date": "2019-05-10 19:15:00 +0800", "snippet": "给工程师的实用密码学作为工程师可能多多少少,都接触过一些密码学知识. 例如加密一个文件, 加密一个字符串等等. 密码学就在身边, 进入Blockchain领域已经快两年了, 从刚开始什么也不知道, 到现在稍微知道一点东西, 越来越觉得密码学真实有趣和奇妙,所以想把自己的一些学习的知识整理一下, 记录下来. 为自己所用, 同时如果可以帮助更多的人那是更好.密码学 - OverView密码学是一门古老的科学, 有上千年的历史但是一直在不断的演进. 各种算法也在不短的演进从MD5,DES 到 AES, SHA-3,Argon2, ChaCha20.首先对于工程师而言有那些密码学的概念需要了解的呢? 总结下来可能有这几类: (1) hash function(例如SHA-256, SHA-3, RIPEMD等等).(2)HMAC(hash based message authentication code), (3) password to key derivation function (密码key提取函数, 例如Scrypt) (4) Diffie-Hellman 密钥交换协议. (5)对称加密算法(例如AES) (6) 非对称加密算法(RSA, ECC) (7)数字签名.同时还有安全的随机数生成器等等.以上的这些领域大概就是作为开发工程师需要了解的一些密码学知识和领域了.密码学是什么密码学是一门安静安全的传输和保存数据的科学. 当你打开了一个网站, 发一封邮件, 连接上家里的wifi,这些都离不开密码学, 他一直存在我们的数字世界里.这也是为什么, 作为数字世界的创造者的工程师们应该对于密码学有基本的了解, 并且知道如何正确使用这些密码学算法, 密码学的library. 这里就包括hashing, 同步异步加密算法, 数字签名等等.加密与密钥密码学要解决的一个重要问题就是如何安全的存储的加密数据. 自然而然这里就涉及到加密和解密了. 具体的来说可以分为对称加密和非对称加密. 对称加密算法例如(AES, ChaCha20)使用的是同一把密钥来加解密数据, 而非对称加密例如公私钥体系是使用的公钥和私钥这一对密钥对, 其实公钥用来加密, 私钥用来解密.常用的加密算法往往多是多种加密方式的组合例如(AES-256-CTR-HMAC-SHA-256, ChaCha20-Poly1305)还有, 密码学中的密钥在很多场景地下都是通过例如password, passphrases通过私钥衍生函数衍生而来的例如(PBKDF2 and Scrypt)数字签名和消息验证现代密码学的另一大应用领域就是数字签名和消息验证.大多数的数字签名算法例如(DSA, ECDSA 和 EdSDA)使用的是非对称加密算法来进行签名, 使用私钥对消息进行签名, 使用公钥验证签名. 在银行系统中, 数字签名被用于签署和批准交易. 在区块链系统中, 数字签名用于转移数字资产从一个地址到另外一个地址.现代密码学同时使用消息验证算法例如(HMAC)来证明消息的真实性, 完整性以及消息的所有权.同时消息验证也同时会和加密算法同时使用,用于建立安全的通讯渠道.安全的随机数随机数在密码学中用非常重要的作用, 如何安全的产生随机数是开发者, 工程师非常需要注意的问题, 一旦随机数的生成有问题那么会威胁到系统的安全性和正确性.密钥交换密钥交换算法,用于多方在一个不可信的欢迎下建立安全通讯的方法. 在我们打开一个网站的时候, 建立一个wifi连接的时候密钥交换就自然发生了.虽然我们意识不到, 但是这些方法每天都在发生.Hash函数和密码Hasing密码学为我们提供了哈希函数(例如SHA-3 和BLACK2), 哈希函数可以将消息转化为定长的消息片段, 同时这个过程是不可逆的. 在区块链系统中,我们使用哈希函数去生成区块链地址, 交易ID. 在其他系统中, 例如我们每天使用的git中, 哈希函数对于文件和提交生成唯一的ID.密钥Hashing 和 密码密钥衍生函数 用于包含用户密码和用户加密后的文件, 密码和随机加入的盐用于生成加密文件, 使得破解这些加密的文件变得非常的困难.密码学的library工程师和开发者应该理解和了解自己使用的语言, 平台下的密码学的类库, 并且需要理解基本的密码学原理来合理的使用这些类库. 开发者每天面对的应用场景各自不同, 所有就应该首先理解并了解密码学的基本原理, 然后合理的选择密码学的类库.OK, 以上就是一些基本的密码学的介绍和密码学使用的场景和方向, 后边会逐步的展开介绍这些方面." }, { "title": "Cobo 一周年", "url": "/posts/cobo-one-year/", "categories": "Thinking", "tags": "blockchain", "date": "2019-05-10 19:15:00 +0800", "snippet": "转眼间加入Cobo已经过了一年了，从作为一名工程师加入Cobo，到如今负责Cobo Wallet和Cobo Vault两条产品的Engineering Manager，一年的时间发生了太多的事情，就像圈内人的一句老话，币圈一天，人间一年。加入Cobo的这一年确实发生了太多的故事。Dive into BlockChain年纪越大，我越相信一句话叫顺势而为，或者说选择比努力更重要。如果回退到08年一个工程师选择互谅网还是IT外企，10年以后今天可能有翻天覆地的差别。我认为生在这个时代，作为一个技术人可以说是幸福的，因为你有机会见证并参与历史的发生。但是首先你得做出自己的选择。人工智能，区块链，VR&amp;amp;AR,可能都是大势，也可能不是。至少在深入了解了比特币和以太坊之后，我觉得区块链是个势。那么后边的问题就简单多了，既然相信那么把自己放进去。Dive into it！初识Cobo - first meet初识Cobo是在朋友圈中，一个朋友转发了Cobo Wallet 1.0上线的News，点开一看不错啊。再一看还在招人，于是乎就聊了一下，最后经过各种故事，结论是：一个30多岁的老男人，背上包，进京务工了。依然记得那是清明假期的最后一天，进了办公室放下包，当天就开始拉代码，大环境。第二天就开始提交代码了。这个创业公司的节奏还真是不一样。进入Cobo的一个project就是开发HD Wallet。一大波新鲜的名词铺面二来，什么是椭圆曲线，什么是BIP44，什么是助记词，什么是Seed，什么是Path。一些都陌生而新鲜。真是有意思。跟随着团队的努力，我们上线了HD Wallet，支持了ETH的Dapp，钱包开发生涯就此展开。Vault诞生记 - Working Together，Build Something OutHD Wallet开发暂告一段落，我们几个刚入职的同事组成了新的项目组，来开发我们的硬件产品Cobo Vault。那近半年的开发中，我们从零到一的把一个新的产品Build出来了。每次的方案设计，技术讨论，动态二维码的头脑风暴，多签方案的激烈讨论，数据层的架构设计。各种种种，现在想来都历历在目。记得某个周末，我们要catch一个时间节点，大家吃完火锅又继续修bug，最后保证一个节点的达成，现在想想还是很有意思。终于2018年11月，Vault上线了，Cobo的第一代硬件钱包在我们手中诞生。这次，我们做一次世界第一 - Be a World Champion this Time很难想象在其他领域，有机会做到世界第一。2018年11月Cobo Wallet成为首家支持Tron Dapp的移动钱包。作为这个feature的主要开发者，还是挺自豪自己可以有机会当一次世界第一的。2个礼拜的全力开发中，可以参考的方案基本没有，读文档，读源码，定方案，修改开源的library，这种开发的体验之前很少有过。当最后终于完成以后，那种成就感也是之前不曾有过的。Refactoring Wallet - Have Balls and Take ActionHave Balls and Take Action 一直是我们鼓励的sprint，作为工程师对于你的最好定义就是你做的产品，当发现代码有问题了，乱了，怎么办？是内心骂一句：这是什么shit，然后继续这么写？还是大声的Say NO，我们应该fix it。我认为的好的工程师当然是后一种，在一段长时间的feature开发后，我们发现代码中有不少问题，新的功能越来越难添加，老的代码维护起来难度也有所增强。我们开始的一段对于老代码的手术，将私钥管理更加模块化，根据业务建立起Data Model，将数据层和展示层分离的更加清楚。经过这些过程也让我对于React中的高阶用法例如HOC，Render Props的这些特性理解的更加的深入了。To Be Continue2019年初币价跌的一地鸡毛，但是我反而觉得这确实是最好的时代，闪电网络的逐渐稳定和逐步运行，Cosmos的主链上线。区块链的技术一片蓬勃。与时代一起成长，未来可期。最后，打个广告，我们北京，西安的办公室都在招聘技术岗位，具体的岗位信息可以点击阅读原文查看。有意愿者可以直接发简历到我的邮箱：chend@cobo.com，我们会优先处理。" }, { "title": "Why BlockChain Matters", "url": "/posts/why-blockchain-matter/", "categories": "Thinking", "tags": "blockchain", "date": "2018-10-14 19:15:00 +0800", "snippet": "2018年已经过去了4分之三，要是今年什么技术名词最为热门，那一定是BlockChain了，年初BitCoin逼近2W刀，吸引了大多数人的眼光，到目前跌回6千刀左右，让出入币圈的同学们感受到了币圈的疯狂。去年爱西欧一飞冲天，各种项目层出不穷，到现在各种凉凉。区块链，爱他的人说他是天使，恨他的人说他是魔鬼。从去年11月开始，我关注和学习blockchain也已经快一年了。那么到底什么是blockchain？这是每次和朋友聊天的时候，朋友们最爱问的问题。这一系列文章，就尝试着一探究竟。BitCoin - BlockChain 1.0说起区块链，那么就不得不提比特币。2008年中本聪的一片白皮书横空出世，把BitCoin带到了人间。BlockChain技术也相应诞生。那么什么是BitCoin呢？从白皮书的名字上定义清楚了。他是一个点对点的电子货币系统。可以说它是第一个可用的去中心化的数字货币系统。任何数字货币都要回答3个问题： 如何保证数字货币的真实性和不可伪造性？ 如何避免双花问题？ 如何保证数字货币的产权？（我是拥有这笔钱的唯一用户）如果我们看传统的货币，这些问题是怎么解决的。1，是国家机构保证的，货币发行机构使用各种技术保证了纸币的防伪性。2，是纸币的本身的特点保证的，同样一块钱，不可能我同时给A也给B。至于3，如果我拥有这块钱，那么它的产权就在我。如果我们把银行账户中的钱认为是数字化。那么以上的三点是由一个中心化的机构来保证的。中心化有什么问题吗？这个不在这篇文章的讨论范围内。那么能不能在一个去中心的系统中解决这些问题？BitCoin给出一个答案，BitCoin不是一个简单的技术，而是融合密码学，计算机科学，已经经济学的一个系统。他包含以下几个部分： 一个点对点的分布式网络 一个公开的交易账本 一系列交易验证以及货币发行的规则（共识规则） 在区块链上达到最终分布一致性的算法（POW 算法）BitCoin系统是由这四部分组成的。也是因为上边的4部分，构成第一个可用的点对点数字货币系统。可以说区块链1.0也由此展开。比特币的出现也带领了其他数字货币的兴起，例如LiteCoin，DogCoin。这些altCoin可以是基于BitCoin的变种。BlockChain 1.0的主角就是这些数字货币体系。ETH - BlockChain 2.02013年V神（Vitalik Buterin）提出Ethereum，一个基于区块链技术的分布式计算平台。实际上BitCoin上是可以执行Script，但是它支持的操作符相当有限。能不能创造一个更加强大的分布式计算平台呢？ETH就是为了实现目标而开发的。ETH实现了EVM一个图灵完备的虚拟机，可以执行用户定义好的智能合约。这样用户可以定义自己的智能合约。从目前来看，基于ETH的最为成功的应用是去年如火如荼的爱西欧了。那么这样的BlockChain到底能有什么作用呢？比较大的改变可以说是一种生产关系上的变化。举个例子，滴滴公司作为一家发展迅速的企业，作为员工也许你可以通过期权的方式来共享企业的发展。但是作为滴滴公司的早期用户和服务提供商司机来说，其实他们并没有分享到企业发展的利益。如何通过Token的方式，这些用户和司机同样也可以有机会获取到企业发展的红利。这可以说就是改变生成关系的一个例子，其他还有例如使得网络社会的价值流转成为可能。这些就是Blockchain带来的变化。ETH上第一款有影响力的应用应该说是CryptoKitties。这款养猫应用，今年年初风靡一时。同时也造成了以太坊网络的拥堵。同时也体现出现有区块链系统的上问题，如何支持大规模的应用？如何到达高的TPS？BlockChain 3.0什么是BlockChain 3.0的代表？目前这个问题见仁见智？有人认为是EOS？有人认为是其他Chain。但是目标都是一致的，让BlockChain真正可用，可以支持大规模的应用。目前来说谁能胜出，这个问题还不明朗。所有人都在做探索。Why BlockChain Matters？这篇文章是BlockChain系列的开篇，后续文章会展开介绍其中各种精彩的技术细节。BlockChain你可以恨它，你可以爱它，但是你去不能忽视它。作为技术人员，这是一片尚待开发的新大陆。等待着你开开垦。怎么样？是否激动人心，让我们来一起见证。" }, { "title": "当React Native 遇到了Google reCAPTCHA", "url": "/posts/recaptcha/", "categories": "Building", "tags": "前端", "date": "2018-09-08 19:15:00 +0800", "snippet": "做客户端开发久了，总有一些烦心事来扰乱你，其中一个就是机器人注册。当然大部分App目前注册的时候都要提供短信验证码。但是这还是防不住一些专业的羊毛党，各种短信验证码平台用的飞起。那该怎么办呢？上验证码吧。验证码大家都熟悉从不可描述的12306到Google的reCAPTCHA，作用只有一个验证你是人，不是机器人。今天的主角就是Google reCAPTCHA。Google reCAPTCHAGoogle reCAPTCHA是Google 提供的一系列好用的服务中的一个，提供完善的人机验证方法。目前有V3和V2两个版本。V3还在Beta阶段，这样我们主要介绍V2。当然同时Google reCAPTCHA也是google用来做数据标记的方法，每天成千上万的图片被人工标记，为Google的Machine Learning系统提供好的帮助。经典的双赢策略。如果还没有体会过Google reCAPTCHA这里链接reCAPTCHA如何使用Google reCAPTCHAGoogle reCAPTCHA的使用十分简单，文档中描述的清楚。下边简单的介绍一些。最简单的方法就是自动的Render Google reCAPTCHA Wideget&amp;lt;html&amp;gt; &amp;lt;head&amp;gt; &amp;lt;title&amp;gt;reCAPTCHA demo: Simple page&amp;lt;/title&amp;gt; &amp;lt;script src=&quot;https://www.google.com/recaptcha/api.js&quot; async defer&amp;gt;&amp;lt;/script&amp;gt; &amp;lt;/head&amp;gt; &amp;lt;body&amp;gt; &amp;lt;form action=&quot;?&quot; method=&quot;POST&quot;&amp;gt; &amp;lt;div class=&quot;g-recaptcha&quot; data-sitekey=&quot;your_site_key&quot; data-callback=&quot;yourCallbackFunction&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;br/&amp;gt; &amp;lt;input type=&quot;submit&quot; value=&quot;Submit&quot;&amp;gt; &amp;lt;/form&amp;gt; &amp;lt;/body&amp;gt;&amp;lt;/html&amp;gt;上面是个简单的html就实现了如何使用Google reCAPTCHA. 具体来说就是加载了google reCAPTCHA的JavaScript,然后定义一个class name是g-recaptcha div，这样以后reCAPTCHA的widget就会Render到它下边。当然你要在google reCAPTCHA上申请一个相应的site_key。so easy。好了当你用浏览器打开这个html的时候就可以看到Google reCAPTCHA widget被render出来了。同时定义了CallBallFunction，当验证成功时候，Google reCAPTCHA会调用这个callback，把取得的token告诉Application，那么Application就可以去进行验证了。好了，Google reCAPTCHA如此好用的服务，在移动端可不可以使用呢？当然Google reCAPTCHA提供Android的API。但是如果我们Application是用React Native来写，是不是就不能使用了呢？当然我们有办法让它可以使用。在React Native中是有Webview组件的，同时WebView组件和React Native之间可以通过postMessage来进行数据通信。那么已然这样，就可以通过WebView来加载一个HTML来Render Google reCAPTCHA Widget。同时通过PostMessage将 Google reCAPTCHA 返回的token，送给React Native。好了从原理上来讲是可以的，那么如何实现呢？还是看代码吧。 import { WebView } from &#39;react-native&#39;; const generateTheWebViewContent = siteKey =&amp;gt; { const htmlMarkup = &#39;&amp;lt;!DOCTYPE html&amp;gt;&amp;lt;html&amp;gt;&amp;lt;head&amp;gt;&#39; + &#39;&amp;lt;script src=&quot;https://recaptcha.google.cn/recaptcha/api.js&quot;&amp;gt;&amp;lt;/script&amp;gt;&#39; + &#39;var onDataCallback = function(response) { console.log(response); window.postMessage(response); }; &#39; + &#39;&amp;lt;/head&amp;gt;&amp;lt;body&amp;gt;&#39; + &#39;&amp;lt;div style=&quot;text-align: center&quot;&amp;gt;&amp;lt;div class=&quot;g-recaptcha&quot; style=&quot;display: inline-block&quot;&#39; + &#39;data-sitekey=&quot;&#39; + siteKey + &#39;&quot; data-callback=&quot;onDataCallback&quot; &#39;; return htmlMarkup; }; const RNReCaptcha = ({ onMessage, siteKey, style, url }) =&amp;gt; ( &amp;lt;WebView originWhitelist={[&#39;*&#39;]} mixedContentMode={&#39;always&#39;} onMessage={onMessage} javaScriptEnabled injectedJavaScript={patchPostMessageJsCode} automaticallyAdjustContentInsets style={[{ backgroundColor: &#39;transparent&#39;, width: &#39;100%&#39; }, style]} source={{ html: generateTheWebViewContent(siteKey), baseUrl: `${url}`, }} /&amp;gt; );上边这段代码就是一个最简单的实现，定义了一个RNReCaptcha的Component，其实就是一个WebView，在source里我们直接给出一段html，其实就是上边那个例子的html，这样一来render这个html就是把Google reCAPTCHA widget render了出来，同时通过postMessage将reCAPTCHA放回的结果送给React Native。好了，就是如此简单。当然，为了方便其他人的使用，我已经publish一个npm package提供给大家使用。只要简单的 yarn add rn-recaptcha npm install rn-recaptcha就ok了。这里是link rn-recaptcha下边是具体的一个demo gif。 Happy Hacking :) " }, { "title": "Rxjs 一二三", "url": "/posts/rxjs123/", "categories": "Learning", "tags": "前端", "date": "2018-09-01 19:15:00 +0800", "snippet": "在前端领域，Application的状态管理可以说是最重要的问题了。如果你使用了React做为表现层的框架，那么一般来说你都会选择例如Redux 或者Mobx这样的数据状态管理框架一同使用。Rxjs同样也是数据状态管理的一种方法。RxJs 是 Reactive Programming 的JS实现。以Stream的方式来看待数据的变化，这样的思路天生特别适合解决异步的数据状态和基于事件的状态管理。举个例子来说，如果你使用过Redux，那么你就会知道Redux天生很难处理异步的Action。当然为了解决这个问题，出现了很多框架和工具。例如Redux-thunk， Redux-Saga，Redux-thunk可以在一点程度上解决这个问题。但是它的功能还是相当有限，当处理复杂场景的时候，就捉襟见肘了。例如如何撤销一个Api Request ？ 例如如何debounce一个Api Request ？ 这些问题如果放到Rxjs的context里边就会发现解决起来相当的easy和优雅。但是Rxjs使用和理解起来还是有些learning cruve的，这篇文章也不准备一次就把所有RxJs都介绍到。这里只分享一些在学习和使用Rxjs的点，希望能让你感性的体会到Rxjs的强大和优雅。首先来看RxJS的几个核心概念。 Observable (可观察对象): 表示一个概念，这个概念是一个可调用的未来值或事件的集合。 Observer (观察者): 一个回调函数的集合，它知道如何去监听由 Observable 提供的值。 Subscription (订阅): 表示 Observable 的执行，主要用于取消 Observable 的执行。 Operators (操作符): 采用函数式编程风格的纯函数 (pure function)，使用像 map、filter、concat、flatMap 等这样的操作符来处理集合。下来我们看看例子体会一下：第一例子第一个例子十分的简单，是如何一个Button 的click event变成一个stream。就是一个Observable.常规的事件监听我们一般会这么写 const button = document.querySelector(&#39;button’); button.addEventListener(&#39;click&#39;, () =&amp;gt; console.log(&#39;Clicked!&#39;));如果我们使用Rxjs的话，他就变成这样了 const button = document.querySelector(‘button’) Rx.Observable.fromEvent(button, ‘click’).subscribe(() =&amp;gt; console.log(‘clicked&#39;))简单的两行就将button 的click变成了Observable这样，其他的Observer就可以订阅到这个Observable进行相应的操作。如果只是简单的似乎也是没什么特别的，那么到底有什么用处呢？第二例子如果要实现一个click button的事件的，但是为了防止机器人点击，1S才会有效一次该怎么实现呢？如何不用Rxjs 怎么实现呢？ const rate = 1000 Let lastClick = Date.now() - rate const button = document.querySelector(‘button’) Button.addEventListener(‘click’, () =&amp;gt; { If(Date.now - lastClick &amp;gt; rate) { console.log(‘clicked!’) lastClick = Date.now() }})上边的这段代码就是我们一般的实现方式，在这里我们引入了一个全局的状态变量 lastClick用来记录上次的点击时间，并在我们click callback去修改它，这样的实现显然不是一个好的实现方式。第一有全局的状态变量，第二函数不纯。再看看如果用Rxjs怎么实现呢？ const button = document.querySelector(‘button’) Rx.Observable.fromEvent(button, ‘click’) .throttleTime(1000) .subscribe(() =&amp;gt; console.log(‘clicked’))是不是相当的简单，如果把click事件看成一个水流，那么throttleTime就像是一个控制阀，他控制着多长时间开一次像下游放一次水。第三例子上边还只是一些简单的小例子，我们来看一个更加复杂一点的user case，第三个例子。假设我们有个search box 当用户输入的时候，会想后台api 发request， seach 对应的字段。这个需求听起来不难，每次发一个 request，然后拿后台返回的数据 render 一个list 就ok了，但是这里有一个问题。例如， // A request for rx // B request for rxjs实际上是发出了两个request，所以我们会得到2个response，但是如果 request B 的response 比 request A 先回来，那么最后render出的结果就是Request A，但是这不是我们想想要的。如何解决这个问题呢，当然我们可以在sort 一下 response，当然如果用Rxjs那么会更简单，就是用SwitchMap，简单来说SwitchMap会订阅最后一个Observable给下游，所以无论你发了几个request，下游拿到的一定是最后一个reqeust的。代码例如这样 inputValueObserverable .switchMap(query =&amp;gt; Rx.Observerable.fromProise(fetch(query))) .subscribe(value =&amp;gt; renderList(value))以上是Rxjs的三个小例子，当然RxjS的强大不止于此，如果你刚兴趣，推荐一个书《深入浅出Rxjs》，这是目前看到了把Rxjs讲的比较明白的一本书了。当然我认为要真正的掌握Rxjs还要从思维上转变成为以数据流的方式来思考和设计Application。好了，希望这几个小例子能吸引你对于Rxjs的兴趣，一起学习。" }, { "title": "React in Depth - Compound Component", "url": "/posts/react-compound-component/", "categories": "Learning", "tags": "前端", "date": "2018-02-27 19:15:00 +0800", "snippet": "使用React也有一段时间了，前边写了一些React基本概念的文章。今天开始写React in Depth这个系列文章。在这一系列文章中，我会总结和分享下React中的开发经验，希望能和大家一起分享，共同提高。今天是第一篇Compound Component。React本质来讲是只做View的Framework，所以Component是React核心和最基本的组成部分，使用React开发出来的application本质来讲就是把一个个组件拼接起来。因此深入理解Component，并且如何在项目上开发出一个合适Component，是一个需要深入理解的问题。让我们从一个现实中的例子开始，下面是两个风扇。 一个是我们日常生活中的风扇，它有一个按键，当按键按下的时候，风扇就转了。另外一个是arduino风扇，同样接通电源后风扇就转了。但是如果那天用户希望风扇反转，那么这两个产品能满足需求吗？对于第一个风扇我们得把它拆开，然后修改电机的接线，这样才能满足反转的需求，但是对于第二个我们只要简单的" }, { "title": "Render Props - New pattern in React", "url": "/posts/react-render-props/", "categories": "Learning", "tags": "前端", "date": "2018-02-27 19:15:00 +0800", "snippet": "Render Props - New pattern in React在软件开发的过程中Code Reuse和可读性一直是开发人员致力于解决的问题，在React社区中，以往出现了很多的Pattern来解决这个问题，例如Mixin，HOC等等。Render Props是React社区中里提出的另外的一种Pattern。由React Router的Co-author Michael Jackson 提出，它与HOC等有什么区别呢？又解决了什么问题呢？在这篇文章来一探究竟。问题的引出所有的Pattern或者solution都是为了解决问题而提出的，那么render props到底是为了解决什么问题呢？我们先来看一个例子。例如在我们的App里我们实现了这样一个componentimport React from &#39;react&#39;;class App extends React.Component { constructor(props) { super(props); this.state = { x: 0, y: 0 }; this.handleMouseMove = this.handleMouseMove.bind(this); } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( &amp;lt;div style= onMouseMove={this.handleMouseMove}&amp;gt; &amp;lt;p&amp;gt; The mouse is at ({this.state.x}, {this.state.y}) &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); }} Code Sandbox熟悉React的同学都知道这是一个很简单的App，他可以追踪鼠标位置给到自己。但是问题来了，万一哪天你的朋友看到这个component，说这个feature很Cool，他的app里能不能用上呢？那么该怎么解决这个问题呢？Code Repeat首先第一种想法很直接，可以把这个component做为一个父Component，另外一个Component作为一个子Component。来看代码。import React from &#39;react&#39;;const Dog = ({mouse}) =&amp;gt; ( &amp;lt;div&amp;gt;{mouse.x}, {mouse.y}&amp;lt;/div&amp;gt;)class MouseDog extends React.Component { constructor(props) { super(props); this.state = { x: 0, y: 0 }; this.handleMouseMove = this.handleMouseMove.bind(this); } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( &amp;lt;div style= onMouseMove={this.handleMouseMove}&amp;gt; &amp;lt;p&amp;gt; The mouse is at ({this.state.x}, {this.state.y}) &amp;lt;Dog mouse={mouse} /&amp;gt; &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ); }}现在我们有了两个Component, Dog 和 DogWithMouse,其实Dog作为DogWithMouse的子Component，那么DogWithMouse Component就能利用鼠标位置。好像这样是把问题解决了，但是如果我们有另外一个Component也想要trace mouse这个feature怎么办呢？难道再重新这样写一个Component吗？显然这种方式是不可取的。HOC如果熟悉react的同学，可能会想到，这很简单呀，我们写一个High order Component（HOC）就行了，的确HOC可以解决这个问题，我们来看看HOC的代码是怎么样的。import React from &#39;react&#39;;const withMouse = (Component) =&amp;gt; { return class extends React.Component { constructor(props) { super(props); this.state = { x: 0, y: 0 }; this.handleMouseMove = this.handleMouseMove.bind(this); } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( &amp;lt;div style= onMouseMove={this.handleMouseMove}&amp;gt; &amp;lt;Component mouse={this.state} {...this.props} /&amp;gt; &amp;lt;/div&amp;gt; ); } }}const Dog = ({ mouse }) =&amp;gt; &amp;lt;div&amp;gt;{mouse.x}, {mouse.y}&amp;lt;/div&amp;gt;const EnhancedDog = withMouse(Dog)在上面的代码里，我们创建了一个withMouse的HOC, 这样就把这部分逻辑抽象了出来。其他的Component想要使用我们mouse tracking的feature。只要将Component传入HOC就能得到一个enhance过的Component。pretty cool， right？如果对于HOC不太了解，可以参考react 的官方文档进行了解。 HOCHOC似乎已经完美的解决了问题，但是这种方式有没有什么缺点呢？似乎是有下面的一些缺点。 间接的props传入。让我们重新看一看Dog Component，他的props传入了mouse，但是在使用这个Component的时候，并没有地方传入了mouse。这是因为mouse是在HOC里传入的。你大概会纳闷这个Mouse是从那来的。如果维护一个大项目的时候，有时候你就会发现这种间接的props传入，是有多么坑了。 命名冲突的问题。用过react的同学不知道有没有经历过大量使用HOC的场景，笔者是见过多层HOC嵌套使用的项目代码。就像这样： const NewComponent = withA(withB(withC(...(Component)))) 如果你用过这样的多层嵌套的HOC，那么就可能会发生命名冲突的问题。来看代码： const withB = (Component) =&amp;gt; { return class extends React.Component { render() { return ( &amp;lt;div style= &amp;gt; &amp;lt;Component mouse={&#39;hehe&#39;} {...this.props} /&amp;gt; &amp;lt;/div&amp;gt; ); } }}const EnhancedDog = withB(withMouse(Dog))在这里定义另外的一个HOC withB。它也给props上传了一个同样的mouse， 如果再用它来wrap withMouse(Dog) 时，你会发现mouse tracking的feature就不work，但是React不会有任何提示，这是命名冲突的问题。如果你有一个七八层的wrapp到一起的Component，如果出现这样的命名冲突的问题，那么就有的debug了。Render props好了，既然HOC有这样的问题，那有没有什么方式既可以做到code reuse，同时也可以避免HOC的这些问题呢？答案就是Render Props。Render Props是React Traning团队提出的一种新的React中组织Component的方式，同时也是十分的简单，我们来看上边的例子中，如果用render props如何解决code reuse的问题。import React from &#39;react&#39;;import { render } from &quot;react-dom&quot;;class Mouse extends React.Component { constructor(props) { super(props); this.state = { x: 0, y: 0 }; this.handleMouseMove = this.handleMouseMove.bind(this); } handleMouseMove(event) { this.setState({ x: event.clientX, y: event.clientY }); } render() { return ( &amp;lt;div style= onMouseMove={this.handleMouseMove}&amp;gt; {this.props.render(this.state)} &amp;lt;/div&amp;gt; ); }}const DogMouse = () =&amp;gt; ( &amp;lt;Mouse render={({x, y}) =&amp;gt; (&amp;lt;div&amp;gt;this mouose is ({x}, {y})&amp;lt;/div&amp;gt;})&amp;gt;)render(&amp;lt;DogMouse/&amp;gt;, document.getElementById(&#39;app&#39;))CodeSandBox上边就是render props的一个简单例子，我们看完会发现特别的简单，没什么特别的。Mouse就是一个普通的Component，唯一不同的是这个Component上定义了一个叫render的prop，是一个函数。在Mouse中会将state作为参数调用这个函数。而创建的DogMouse同样也是一个普通的Component，其中定义render的方法，用于定义要render什么Component。我们看看render props和HOC相比解决了什么问题： code reuse。和HOC一样的，render props同样解决了code reuse的问题。把mouse tracking的feature抽象成为一个Mouse的Component，如果有另外一个Component像复用这个feature的时候，简单的定义另外一个Component定义相应的render props就好了。 间接的props传入，render props 没有这个问题，可以清楚的看到props(x, y)是从什么地方出入的. 命名冲突。利用render props是没有Component wrapp的，所以除非定义Component时候自己命名重复，否则不会有命名冲突的问题。 从上面的例子上看，render props可以再大多数情况下替代HOC。react的官方文档上，目前也正式的介绍了render props,下次让你想用HOC的时候，来试一试Render props把。" }, { "title": "图表君读书-智能时代", "url": "/posts/intel-age/", "categories": "Thinking", "tags": "读书记", "date": "2018-01-05 19:15:00 +0800", "snippet": "智能时代–我们的未来与现在2017年人人都在谈AI，如果你还是再科技行业里，那必然是早都听的不能再多了。智能时代已经悄然到来，到底什么是智能时代？在这个时代到底能给我们带来什么？2018年的第一周，图表君就阅读了吴军老师的《智能时代》一书。看看吴军老师是如何和我们描述这个已来的未来。智能时代的基石–数据数据，有人认为是未来的战略资源，尤其是这个时代。每天都有大量的数据由我们产生，并被记录下来。今天我们能很方便记录下我们明天的各种数据，我们的心跳，我们的运动，我们的行程，我们的饮食。而所有的这些数据别记录，分析，又反过来影响这我们的日常的生活。同样与煤炭是蒸汽时代的燃料，石油是电气时代的动力。所有的这些数据成为了智能时代的基石。大数据与机器智能在有了计算机之后，人类一直想让机器能有人的思考和创造的能力。计算机学家也提出了图灵测试来验证机器是否具有人的智能，具体来说如果计算机有可以完成以下的事情我们就说它具有了一定意义上的智能： 语言识别 机器翻译 文本翻译 在棋类游戏上战胜人类 自动回答问题目前机器已经可以完成以上的一些事情了。当然这后边所依靠的正是人工智能。人工智能的发展有快60多年的历史了。在早期，人们的思路是试图让计算机可以按照人的思路来解决问题。但是很快，人们就发现这样的方法并不能让计算机拥有像人类的一样的智能。人工智能的柳暗花明– 统计 + 数据在人们发现传统的方法此路不通时，于是就开始尝试采用另一种方式，利用数据驱动和数据计算的方法。这个领域的先驱就是贾里尼克，当时他在IBM开发语音识别系统的时候，从通信的角度思考这个问题，他认为语音识别的问题就是一个编码 - 传输 - 解码的问题，于是他从用数字通信的各种技术来实现语音识别，彻底抛开了原有的人工智能方法。在找到合适的数学模型后，通过大量的数据训练出模型的参数。通过这样的方法他讲语音识别的识别率从70%提高到了90%。从此开启了人工智能领域的一个新的方向，通过统计和数据的方法来解决人工智能问题。大数据的特征大数据的智能时代的另一个属性，它并不仅仅指的是数据的量大，而且还有其他的属性，其中包括多维度，全面性。因为互联网的特征我们可以从多个维度来获取描述一种数据。例如在描述一件衣服的时候，不仅能从衣服的材料，颜色，设计等显性的方式来获得数据，同样我们也可以等待，例如评论者的地点，用的手机还是PC，时间，天气，如果他还是之前的客户，那么还能得到检索的历史，购买的历史，这样多维度的数据来描述这个产品。这样的数据维度是之前不可能到达的。大数据的第三的特点就是完备性，之前做统计得抽样，用小样本来进行统计分析，但是大数据时代，你的数据集就是完备的。智能时代的思维方式在智能时代之前，人们的科学的思维方式是-机械思维，世界的运动的有规律的，这些规律是可以被发现并可以用简单的数据公式来进行总结的。这样的思维方式的核心思想就是确定性和因果关系，这是因为这样的思想才使得我们的文明不断的进步和发展到了今天。世界的不确定性机械思维能很好解决确定性的问题，但是我们的世界同时也是不确定的。针对这样的问题，我们就应该采用新的思维方式来解决问题，那就是采用信息论的思维方式。其核心的思想就是为了消除不确定性，我们应该引入信息。不确定性越大，引入的信息就越多。这部分吴军老师用了大量的例子来说明这个问题。同时在智能时候我们的思维方式，也应该从因果思维向相关性思维进行转变。智能时代的技术变革在书的后半部分，吴军老师介绍了智能时代的各种技术变革，和对商业上的影响。以及告诉大家如何做那2%的人，即利用这个时代的最近技术来解决自己行业和领域的问题。" }, { "title": "ES6新特性 iterators and Generators", "url": "/posts/iterator-and-generator/", "categories": "Learning", "tags": "前端", "date": "2017-05-28 19:15:00 +0800", "snippet": "ES6新特性 iterators and GeneratorsES6中引入了许多新特性，目前大量的JavaScript项目已经使用了ES6来进行开发，那么熟悉这些新的特性是十分必要的，例如Redux-Saga中大量的使用了Iterator和generator。这篇文章总结和介绍一下ES6中的Iterator和Generator。iterators and Generators第一个问题什么是iterator？答案很简单， Iterator是一个object，但是含有特定的接口，它有next method可以返回一个result object，这个result object有两个属性第一个是value，代表这个迭代的值, 第二个是done，代表迭代是否结束。如果我们自己来简单实现一个Iterator，它是这样的。function createIterator(items) { var i = 0; return { next : function () { var done = i &amp;gt;= (items.length) var value = items[i++] return { done: done, value: value } } }}const items = [1,2,3]const iteratorA = createIterator(items)iteratorA.next() // {result:1, done: false}那么Generator又是什么？Generator 是一个函数可以产生iterator。Generator函数用function关键字后边带*来表示。在函数定义上使用yield关键字来表示next方法调用时返回的值。例如function *createIterator(){ yield 1; yield 2; yield 3;}let iterator = createIterator();console.log(iterator.next().value); //1console.log(iterator.next().value); //2console.log(iterator.next().value); //3iterables上边介绍了什么是Iterator，什么是generator，下边再介绍一个概念iterable。iterable是一个有Symbol.iterator属性的object。这个symbol指向一个generator函数，这个函数返回关于这个对象的iterator。在ES6中所有的集合类对象(array, set, maps)和字符串都是iterable，并且有自己默认的iterator。当我们在使用 for-of时候实际上是利用了这些对象上的iterator,每次调用了next方法，将返回的result上的value返回回来。let values = [1, 2, 3];for (let num of values) { console.log(num);}例如这段简单的代码，实际上调用了values上的iterator的next方法，将result上的value拿出来赋给num。既然是这样我们可以采用这样的方法来获得默认的iterator。let values = [1, 2, 3];let iterator = values[Symbol.iterator]();在ES6中对于集合类型的Object,其上定义了一些内置的iterator，分别是； entries() - 返回一个返回key-value pair的iterator values() - 返回一个返回collection对应值的iterator // chrome not supportedMDN keys() - 返回一个返回collecttion对应key的iterator以上就是iterator和generator的一些基本概念，下边我们来看一下一些高阶应用。向iterator中传递参数上边的例子中我们在调用iterator的next方法都是无参数调用的，但是我们同样可以向next方法中传递参数。例如这样。function* createIterator() { let first = yield 1; let second = yield first + 2; yield second + 3;}let i= createItreator（）i.next() // {value:1 done: false}i.next(5) // {value: 7 done: false}i.next(3) // {value: 6 done: false}我们看上边这个例子,在第二次调用中我们传进去了5，返回值是7，这个传进去的参数可以理解为上一次yield的返回值。注意yield本身是不返回任何值的，它只向外部产生值。如果我们查看yield在英语词典中的意思，produce or generate (a result, gain, or financial return 所以yield的值是向外产生值。所以在第一次next后 first的值依旧是undefined。但是向next中传递参数，这个参数代表我们想要上一次yield在generator函数中的值。所以在第二次next后 返回值的value就是7(5+2)了。第三例子同理。所以基于上边的原因我们向第一个next函数中传入任何值都是没有意义的。我们变化一下再看function* createIterator() { yield 1; let first; let second = yield first + 2; yield second + 3;}i.next() // {value:1 done: false}i.next(5) // {value: NaN done: false}i.next(3) // {value: 6 done: false}在第二个next中我们的返回是NaN, 为什么呢？这是因为first是Undefined，第一次的yield并没有给first赋值。所以在yeild中的执行顺序是每一次执行到相应的yield就完了，下次继续向下执行。在Iterator中Throw Error在iterator中我们可以来throw error 来达到控制执行的目的。例如上边一个例子。function* createIterator() { let first = yield 1; let second = yield first + 2; yield second + 3;}let i= createItreator（）i.next() // {value:1 done: false}i.next(5) // {value: 7 done: false}i.throw(new Error(&#39;error&#39;)) // error thrown done is set to true after throw errorGenerator function中的Return同样在generator 我们可以使用 return来返回。function* createIterator() { yield 1; return; yield 2; yield 3;}let iterator = createIterator();console.log(iterator.next()); // &quot;{ value: 1, done: false }&quot;console.log(iterator.next()); // &quot;{ value: undefined, done: true }&quot;第一次next后已经结束了所以 我们第二次next后done就已经是true了。Generator 和 Iterator的应用实例：Task Runner我们可以使用generator和Iterator来实现一个task runner,可以让我们不用手动的next，而是一次执行结束。代码如下：function run(taskDef) { let task = taskDef(); let value = task.next() function step() { if (!value.done) { value = task.next(value.value) step() } } step()}run(function*(){ let first = yield 1; let second = yield first + 3; yield second + 4;})上边就是一个例子，这样定义的run function就可以顺序执行这些generator定义的步骤。实际上generator和Iterator最为实际的作用是可以控制异步函数的执行，下边我们可以简单的例子。function run(taskDef) { let task = taskDef(); let result = task.next() function step() { if (!result.done) { if (typeof result.value === &quot;function&quot;) { result.value(function(err, data) { if (err) { console.log(&#39;err&#39;, err); task.throw(err) return } console.log(&#39;err&#39;, data); result = task.next(data); step() }) } else { result = task.next(result.value) step() } } } step()}let fs = require(&quot;fs&quot;);function readFile(filename) { return function (callback) { fs.readFile(filename, callback); };}run(function* () { let contents = yield readFile(&quot;abc.json&quot;); console.log(contents); console.log(&quot;Done&quot;);});首先我们定义了一个task runner run function 在其中当发现result中的value是function的时候，就执行这个function, 并且在异步函数的callback中，当没有error的时候执行下一步。在看我们的ReadFile function，fs模块中的readFile是一个异步的函数，而在这里我们将其进行了封装成为一个新的函数。让其返回一个function给在task runner中使用。那么在我们的generator函数中，我们看上去的代码就和同步的一样了，先readfile，完成后将其输出。这样使用Iterator和generator可以帮助我们写出一个比较好看的异步执行函数。" }, { "title": "微服务构架下的Serveless实践", "url": "/posts/Serveless-practice/", "categories": "Learning", "tags": "构架", "date": "2017-03-25 08:01:00 +0800", "snippet": "微服务构架下的Serveless实践目前的软件构架，什么样的构架方式是最受关注？答案自然是微服务了。似乎人人都在谈微服务，维护老系统的开发人员，在思考如何将系统迁移到微服务的构架下。开发新项目的，自热而然已经在的构架设计上，会采用微服务的构架方式了。网络上讨论微服务的文章现在是汗牛充栋，这篇文章不打算更多的讨论什么是微服务，它好处，它的问题，而想讨论下我们在微服务构架下在实现上一些演进的方式，希望能带来更多的思考。微服务构架下的数据处理业务在互联网应用下，数据越来越成为驱动业务的一个重要的驱动力了。CEO要需要依靠数据来做出战略的决定，运营人员需要看数据来做出运营方案，开发人员需要根据交互数据来调整开发方案。所以可以说数据处理服务慢慢的成为一个企业IT系统中的重要环节。笔者之前参与的项目就是为了开发出这样一套数据的ETL系统，为企业的业务人员服务。具体来说，我们使用了第三方的用户数据追踪服务，来为我们追踪用户的行为，而每天他们都会为我们提供一份用户行为的数据文件，我们需要拿到这些数据，加上我们自己的产品数据，就能清楚的让我们的运营人员看到，我们有哪些产品是最受欢迎的，哪哪些产品的访问量较低等等。那么最初我们是怎么设计的技术方案的呢？传统的微服务架构我们将业务拆分为3个独立的微服务，2个data collector，1个data loader， 都分别的部署在EC2的Instance上，将中间数据存储在一个外部的S3 bucket上（AWS的数据存储）最后将数据保存在我们的数据库中，在数据库之上我们使用专门的BI工具来制作Report。至于为什么这样拆分微服务，这样拆分的好处是什么，这篇文章这不进行详细的讨论。我们第一个数据服务就是按照这样的构架进行设计和实践的。当系统上线服务以后，我们发现了里边的一些问题。在我们这套系统中，Data Collector 2 每天的执行时间较长需要1个小时左右的时间，而 Data Collector 1 每天的执行时间较短，通常执行时间不会超过1分钟，但是由于外边的数据源的更新时间是不确定的，所以虽然我们服务实际的有用时间只有仅仅的一到两分钟，但是也不得不让instance24小时全天运行。可以看到，我们的服务每天实际有效的时间只有一个小时，其他23个小时实际上是在浪费资源，如何改善这样的情况呢？首先我们想到了让服务定点运行的方法。由于我们外服数据源的更新特点，虽然它的更新时间是不确定的，但是它在一个特定的时间点前是一定会更新的。所以基于这样的情况，我们将服务的运行时间改为定点运行，这样是不是就能解决问题了呢？然而现实总不是那么美好，因为我们服务间是有依赖关系的，data loader 是依赖于我们data Collector的处理结果的，当我们把运行方式改为定点运行后，带来的问题是，一旦data Collector的运行状态出现了问题，例如运行时间过长，运行中出现错误，那么data loader必然出错。并且改为定点运行后，我们的数据更新必然有延迟。那么如何解决这些问题呢？Serveless的系统架构2016年Serveless Architectures的提出引发了对于软件构建的关注，那么什么是Serveless Architectures呢？现在还没有一个明确的定义，但是就我的理解而言，Serveless顾名思义，就是没有Serve的构架方式。我们业务逻辑代码并不是执行在一个Server上了，例如一台EC2的instance。而是运行在一些基于事件驱动的，无状态的第三方计算服务上，也就是Function as a Service。概念可能比较抽象，举例来说就是AWS的Lambda，Lamnda可是说是Function as a Service的典型代表。那么下边我就来介绍下，我们是如何使用Lambda来改进上边的数据处理系统。其实也很简单，我们将Data Collector 和 Data loader用Lambda进行了替换，有哪些好处呢？第一点因为我们的基础架构是架构在AWS上的所以，Lambda提供了很多事件驱动的机制，例如，S3上一个数据的变化可以触发一个事件，SNS的一条消息可以触发一个时间等等，在使用Lambda后，我们就可以讲原来基于时间的数据处理流程，转变为基于事件的数据处理流程，这样一方面可以保证我们数据更新的实时性，另一方面可以大大节省资源，由于Lambda是按照触发次数收费的，所以在我们的这个用例下，可以大大减少花费。可能细心的读者想问为什么我们data Collector 2 没有使用Lambda进行替换呢？这是因为它的业务逻辑比较复杂，每次运行的时间较长，而Lambda的最长执行时间是5分钟，所以在这种情况下，就不适合使用Lambda进行替换了。实时数据处理下Serveless构建在初识Serveless 构建的好处之后，我们开始在其他方面应用的尝试，比较典型的一个例子就是在实时数据处理业务下的Serveless构架，目前在我们有原来越多的实时数据需要处理，例如记录用户行为的log数据，实时的数据分析等等。在我们业务下，同样有这样的需求，我们需要实时的跟踪一个外部的数据源API，实时根据它的数据变化来更新我们的数据，下边就是我们在解决这样业务场景下的Serveless构架。在我们的构架设计中，我们使用一个lambda来跟踪外部数据源的数据变化，并将其推到AWS Kinesis Stream里，AWS Kinesis 会触发第二个lambda进行相应的数据处理，并把数据存储到数据库中，值得注意的是由于Lambda是可以根据需求自动伸缩的，所以Lambda会根据Kinesis的需求来自动的scaling，到流中的数据量大时，触发的lamnda会相应增大。当数据量小时，触发的lambda会相应的减少。这就体现了Serveless 构架下的另一个好处，可以相对简单的，自动的进行伸缩扩展。#Web系统的Serveless构架上文我们更多的是讨论，对于数据处理系统下的Serveless构架，那么对于Web系统来说，这种我们最为熟悉和常见的IT系统它是如何能不能用Serveless的构建来进行实现呢？我们来看下边的例子。我们先来看看经典的传统的例子。在传统的实现中，我们会利用load Blancer来做负载均衡，然后后边的app在AutoScaling Group中，根据request的情况来做自动的Scaling，这种模式已经是十分成熟了。那么我们看看在Serveless的构架下该如何设计呢？在serveless的构架下，一般我们的frontend app的资源包括Html，js，css是部署在S3 bucket下的。前端通过http请求向后台请求数据。后台通过API GateWay定义对外的endpoint，同时每个endpoint会触发一个lamnda进行数据操作，例如图中的GET，和POST请求会触发两个不同lambda。在这种构架下，带来的第一点好处就是，我们不必自己担心Scaling的问题了，以前我们要自己去建立AutoScaling Group根据请求来进行不断的挑战，而在Serveless构架下我们就可以很大程度上不必担心这样的问题了。同样可以不必自己去监控Instance了，云平台上相应的服务替代我们做了这些工作。但是是不是我们现在就要完全的拥抱Serveless构架，将我们所以得Service都变成这样呢？我觉得并不一定是这样的，Serveless在给我们带来好处的同时，也给我们来了很多的问题，例如上边的构架图，我们可以看到已经十分复杂了，这里每一块我们都要考虑它的deployment，logging，monitoring等等的问题，这无疑给带了更多的复杂度。的确就像以往任何一种新的技术一样，Serveless 不是银弹，再给我们带了优势和益处的同时，也相应的带了不少的问题。选不选择还是要安装业务场景来具体分析，希望本文我们的实践经验能给您带来更多的思考。" }, { "title": "浅析React之事件系统（二）", "url": "/posts/react-event-2/", "categories": "Learning", "tags": "react", "date": "2017-01-09 08:01:00 +0800", "snippet": "浅析React之事件系统（二）上篇文章中，我们谈到了React事件系统的实现方式，和在React中使用原生事件的方法，那么这篇文章我们来继续分析下，看看React中合成事件和原生事件混用的各种情况。上一个例子在上篇文章中，我们举了个例子。为了防止大家不记得，我们来看看那个例子的代码。class App extends React.Component { constructor(props){ super(props); this.state = { show: false } this.handleClick = this.handleClick.bind(this) this.handleClickImage = this.handleClickImage.bind(this); } handleClick(){ this.setState({ show: true }) } componentDidMount(){ document.body.addEventListener(&#39;click&#39;, e=&amp;gt; { this.setState({ show: false }) }) } componentWillUnmount(){ document.body.removeEventListener(&#39;click&#39;); } handleClickImage(e){ console.log(&#39;in this &#39;) e.stopPropagation(); } render(){ return ( &amp;lt;div className=&quot;container&quot;&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;Open Image&amp;lt;/button&amp;gt; &amp;lt;div className=&quot;img-container&quot; style= onClick={this.handleClickImage}&amp;gt; &amp;lt;img src=&quot;http://blog.addthiscdn.com/wp-content/uploads/2014/11/addthis-react-flux-javascript-scaling.png&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) }}ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&#39;root&#39;));这有什么问题呢？ 问题就在于，如果我们点击image的内部依旧可以收起Image，那么这是为什么呢？这是因为我们及时点击了Image的内部，body上绑定的事件处理器依旧会执行，这样就让我们的image收起来了。那我们如果不想让image收起来改怎么做呢？首先的想法是停止冒泡，如果我们在img-container中就停止冒泡了是不是就可以让image不消失了呢？比如这样：...handleClickImage(e){ e.preventDefault(); e.stopPropagation(); } render(){ return ( &amp;lt;div className=&quot;container&quot;&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;Open Image&amp;lt;/button&amp;gt; &amp;lt;div className=&quot;img-container&quot; style= onClick={this.handleClickImage}&amp;gt; &amp;lt;img src=&quot;http://blog.addthiscdn.com/wp-content/uploads/2014/11/addthis-react-flux-javascript-scaling.png&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) }...Open In CodePen在这里我们定义一个handleClickImage的方法，在其中我们执行取消默认行为和停止冒泡。那是似乎效果并不是我们想要的。因为阻止React事件冒泡的行为只能用于React合成事件中，没法阻止原生事件的冒泡。同样用React.NativeEvent.stopPropagation()也是无法阻止冒泡的。如何解决这样的问题呢？首先，尽量的避免混用合成事件和原生事件。需要注意的点是： 阻止react 合成事件冒泡并不会阻止原生时间的冒泡，从上边的例子我们已经看到了，及时使用stopPropagation也是无法阻止原生时间的冒泡的。 第二点需要注意的是，取消原生时间的冒泡会同时取消React Event。并且原生事件的冒泡在react event的触发和冒泡之前。同时React Event的创建和冒泡是在原生事件冒泡到最顶层的component之后的。我们来看这个例子：class App extends React.Component { render(){ return &amp;lt;GrandPa /&amp;gt;; }}class GrandPa extends React.Component { constructor(props){ super(props); this.state = {clickTime: 0}; this.handleClick = this.handleClick.bind(this); } handleClick(){ console.log(&#39;React Event grandpa is fired&#39;); this.setState({clickTime: new Date().getTime()})}; componentDidMount(){ document.getElementById(&#39;grandpa&#39;).addEventListener(&#39;click&#39;,function(e){ console.log(&#39;native Event GrandPa is fired&#39;); }) } render(){ return ( &amp;lt;div id=&#39;grandpa&#39; onClick={this.handleClick}&amp;gt; &amp;lt;p&amp;gt;GrandPa Clicked at: {this.state.clickTime}&amp;lt;/p&amp;gt; &amp;lt;Dad /&amp;gt; &amp;lt;/div&amp;gt; ) }}class Dad extends React.Component { constructor(props){ super(props); this.state = {clickTime:0}; this.handleClick=this.handleClick.bind(this); } componentDidMount(){ document.getElementById(&#39;dad&#39;).addEventListener(&#39;click&#39;,function(e){ console.log(&#39;native Event Dad is fired&#39;); e.stopPropagation(); }) } handleClick(){ console.log(&#39;React Event Dad is fired&#39;) this.setState({clickTime: new Date().getTime()}) } render(){ return ( &amp;lt;div id=&#39;dad&#39; onClick={this.handleClick}&amp;gt; &amp;lt;p&amp;gt;Dad Clicked at: {this.state.clickTime}&amp;lt;/p&amp;gt; &amp;lt;Son /&amp;gt; &amp;lt;/div&amp;gt; ) }}class Son extends React.Component { constructor(props){ super(props); this.state = {clickTime:0}; this.handleClick=this.handleClick.bind(this); } handleClick(){ console.log(&#39;React Event Son is fired&#39;); this.setState({clickTime: new Date().getTime()}) } componentDidMount(){ document.getElementById(&#39;son&#39;).addEventListener(&#39;click&#39;,function(e){ console.log(&#39;native Event son is fired&#39;); }) } render(){ return ( &amp;lt;div id=&quot;son&quot;&amp;gt; &amp;lt;p onClick={this.handleClick}&amp;gt;Son Clicked at: {this.state.clickTime} &amp;lt;/p&amp;gt; &amp;lt;/div&amp;gt; ) }}ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&#39;root&#39;));Open in CodePen在这个例子中我们有三个component，Son Dad，Grandpa。同时定义了React Event handler 和 native event handler，并在Dad的native Event handler中stopPropagation，当我们点击Son or Dad component的时候会发现，React Event handler并没有被trigger。console里的output为：&quot;native Event son is fired&quot;&quot;native Event Dad is fired&quot;这就说明native Event的停止冒泡可以阻断所有的React Event。所以即使我们是在Dad上停止冒泡的，依旧阻断了Son上的React Event。同时如果我们把dad上的stopPropagation remove掉我们会看到如下结果：&quot;native Event son is fired&quot;&quot;native Event Dad is fired&quot;&quot;native Event GrandPa is fired&quot;&quot;React Event Son is fired&quot;&quot;React Event Dad is fired&quot;&quot;React Event grandpa is fired&quot;这就说明React的合成时间是在原生事件冒泡到最顶层组件结束后才创建和冒泡的，也是符合React的原理，因为在是实现的时候React只是将一个Event listener 挂在了最顶层的组件上，其内部一套自己的机制进行事件的管理。" }, { "title": "浅析React之事件系统（一）", "url": "/posts/react-event/", "categories": "Learning", "tags": "react", "date": "2017-01-08 08:01:00 +0800", "snippet": "浅析React之事件系统（一）大家周末好，2016年的最后几篇文章开始写到了React的一些东西，那么最近就来一些图表君对于React的简单总结和理解，那么今天就开始第一篇，说一说React的事件系统。总览简单来说React实现了一个SyntheticEvent层，所有定义的事件处理器都可以接受到一个SyntheticEvent对象的实例，他是一个跨浏览器的对于原生事件的包装，和原生事件一样有同样的接口，包括stopPropagation()和preventDefault()。合成事件的使用方式在React中不会把所有的事件处理器绑定到相应的真实的DOM节点上，而是使用一个统一的事件监听器，把所有的事件绑定在最外层。当事件发生的时候，首先被这个统一的事件监听器处理，随后找到真正的事件处理函数进行调用，这样是为了提高效率，这是因为在UI系统中，事件处理器越多，那么占据的内存就越大，React的做法是将其简化为一个，这样就大大提高了效率。在之前开发者需要为了优化性能需要自己来优化自己的事件处理器的代码，现在React帮助你完成了这些工作。合成事件的绑定方式说了这么许多理论上的知识，我们来看看合成事件是怎么使用的。 bind方法。 我们来直接看代码 import React, {Component} from &#39;react&#39;; class EventApp extends Component { handleClick(e,args){ console.log(&#39;this is the react event&#39;,e) console.log(&#39;this is the args&#39;, args) } render(){ return &amp;lt;button onClick={this.handleClick.bind(this,&#39;test&#39;)}&amp;gt;Test&amp;lt;/button&amp;gt; } } 构造器内声明 再来看代码 import React, {Component} from &#39;react&#39;; class EventApp extends Component { constructor(props){ super(props); this.handleClick = this.handleClick.bind(this); } handleClick(e){ console.log(&#39;this is the react event&#39;,e) } render(){ return &amp;lt;button onClick={this.handleClick}&amp;gt;Test&amp;lt;/button&amp;gt; } }使用构造器内声明的方法，仅仅要绑定一次而不需要每次使用的时候都绑定一次。 箭头函数class ButtonApp extends React.Component { handleClick (e) { console.log(e.target.value) } render(){ return &amp;lt;button onClick={(e) =&amp;gt; this.handleClick(e)}&amp;gt;Test&amp;lt;/button&amp;gt;; } }从上边的使用方式我们可以看出React来使用合成事假还是很简单的，但是现实的世界总是更加的复杂的。那么在React中我们可以使用原始事件吗？当然是可以的。使用原生事件在React中我们也可以使用原生事件，那么如何进行绑定呢，因为React提供了ComponentDidMount这样的API让我们可以调用，那么要使用原生事件我们就可以在DidMount后进行绑定。例如上边的那个例子中如果我们想把click事件绑定在原生button上该怎么做呢？我们来看代码：class ButtonApp extends React.Component { componentDidMount(){ this.refs.button.addEventListener(&#39;click&#39; e =&amp;gt; { console.log(e); }) } componentWillUnmount(){ this.refs.button.removeEventListener(&#39;click&#39;) } render(){ return &amp;lt;button ref=&quot;button&quot;&amp;gt;Test&amp;lt;/button&amp;gt; }}在这里例子中我们使用原生事件的方法绑到了button上，注意一点的是在DidMount上add了这个listener在willUnmont上remove这个listener。一定要手动的记住移除，不然可能会出现内存泄漏问题。如果我们使用React合成事件，这些事React已经帮你做好了。但是现实的情况下我们有一些场景是不得不用到原生的事件的那么该怎么做呢？我们来看下边的一个例子。例如我们要实现这样的一个功能，在页面上有个button，当点击它会出现一个图片。当点击页面的其他部分的时候，这个图片会自动的消失，那么这样的需求我们就不得不使用原生的事件了。话不多说我们来看代码实现。import React from &#39;react&#39;;class App extends React.Component { constructor(props){ super(props); this.state = { show: false } this.handleClick = this.handleClick.bind(this) this.handleClickImage = this.handleClickImage.bind(this); } handleClick(){ this.setState({ show: true }) } componentDidMount(){ document.body.addEventListener(&#39;click&#39;, e=&amp;gt; { this.setState({ show: false }) }) } componentWillUnmount(){ document.body.removeEventListener(&#39;click&#39;); } render(){ return ( &amp;lt;div className=&quot;container&quot;&amp;gt; &amp;lt;button onClick={this.handleClick}&amp;gt;Open Image&amp;lt;/button&amp;gt; &amp;lt;div className=&quot;img-container&quot; style= &amp;gt; &amp;lt;img src=&quot;http://blog.addthiscdn.com/wp-content/uploads/2014/11/addthis-react-flux-javascript-scaling.png&quot; /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ) }}ReactDOM.render(&amp;lt;App /&amp;gt;, document.getElementById(&#39;root&#39;));Open In CodePen上边一个例子中，我们实现了组件APP，他里边有一个button，它上边有一个handleClick的事件处理器，当触发时会把app的state里show制成true，这样图片就显示了出来。同时在body上使用了原生事件，当发生点击事件的时候，就会被收起，这样就简单实现了需求的功能，那是看似这样好像就没有问题的，但是这其中有个bug，到底是什么问题呢，我们下篇文章继续。看看原生事件和合成事件混用的那些事。参考文献：深入react技术栈" }, { "title": "再见2016，你好2017", "url": "/posts/2016-Summary/", "categories": "Thinking", "tags": "Summary", "date": "2016-12-31 08:01:00 +0800", "snippet": "再见2016，你好2017今天是2016年的最后一天，时间过的好快，一转眼一年又过去了，这一年做了不少事情了，年底的最后一天，转头回来看看吧。糖记发布2016年初发布了糖记，自己学习IOS开发的一个小小的作品，本想今年能继续开发出Android版本，看来是现在是没有机会了。看2017年有没有时间用React Native写一个Android版本吧。博文更新说来惭愧，2016年一共也写了20篇文章，有技术，有非技术的。完成一个小小的专题“图表君聊docker”，其实docker还有很多可以写，看2017年继续这个系列的第二季了。2017年继续把成长的点滴记录下。工作变化2016年最大的变化可以说是换了一家公司，如果对图表君熟虑的朋友，应该知道我现在去到了ThoughtWorks，终于可以愉快的写代码了。至于在ThoughtWorks工作的体验，前几天写了篇文章发表在了公司的微信公号上，有兴趣的同学可以点击下边的阅读原文，读一读。在这快一年的时间内，认识了许多新的伙伴，看到了许多新的风景。感谢各位对我的各种帮助，很高兴能和大家战斗在一个集体里。生活点滴感谢家人一年的支持和照顾，有了你们的支持，才有可能完成今年的所有成绩。你好20172016年底看到了Zuckerberg写的JARVIS，牛人就是牛，还能抽出时间来写个挺有意思的东西。图表君也有点类似的想法，看看2017年能不能写点东西，完成这个小愿望。2017年希望能见识更多人，走过更多的地方。新年快乐！祝好。" }, { "title": "骚窝点滴，一个新人的年终感悟", "url": "/posts/year-summray/", "categories": "Thinking", "tags": "Summary", "date": "2016-12-24 08:01:00 +0800", "snippet": "骚窝点滴，一个新人的年终感悟又到了2016年的年末，感觉时间过得真快，一年的时间又匆匆的流过。但是这一年的工作经历，应该说比以往几年都要来的丰富，原因很简单，因为换工作了。2016年的三月份正式的加入了ThoughtWorks，到现在已经有9个月的时间，回想起来还是有所感悟。初识骚窝虽然是今年才正式加入ThoughtWorks，但是听说和了解这家公司也是很早之前的事了。在西安，ThoughtWorks可以说是社区活动的引领者，每个技术领域的社区活动，都有ThoughtWorks的身影。比如前端圈的UI Super Day，测试圈的BQConf, 运维圈的Devops MeetUp，BA圈的DnA Workshop，还有Code Retreat等等，在西安只要是你对于技术感兴趣，应该多多少少都参加过ThoughtWorks的活动。所以之前我也参加了不少活动，在Code Retreat上见识到了ThoughtWorks同学对于代码的热情和信仰。觉得这是一家不同的公司，再加上不少好友已经加入了ThoughtWorks, 现在看来我加入骚窝也是一件自热而然的事情。现在深切的记得3月份入职的时候是那满怀期待的心情。入职的第一天的最大感受就是，真是太快了。上午办完入职手续，下午就是进了项目组。以我之前的经验，入职第一天一般来说多是熟悉公司，应该没什么特别的事情。但是下午两点我刚做的工位上的时候，组里的同事已经开始给我讲项目的业务了。这速度是我完全没有预料到的。而后下来的几天，最大的感受就是快。同事打字的速度快，快捷键之熟练，写代码之快，让我大开眼界。讨论问题，一旦问题清楚，马上解决。而同样的问题，在以前的公司，必定是一场邮件大战，到真正解决怕也得好几天的时间。速度快是我加入初识骚窝的第一感触。敏捷之旅在度过了几天是适应期后，真正的就开始上手工作了，各种新鲜的感受也是接踵而至，首先就是团队构成的让我耳目一新。全功能团队之前的公司，基本上团队都是长这个样子的，有专门开发团队，专门的测试团队，专门的运维和支持团队。然后问题就来了，基本上各个团队都是相互仇恨的，开发团队仇恨测试团队报的Bug多，测试团队嫌开发团队的质量差。如果一个bug出现了，开发团队里的前后台还得吵半天。但是，ThoughtWorks的团队是另外一个样子，一个团队里有PM，BA，DEV，QA。所有的人员是一个团队，大家的目标是统一的，为了让项目高效，高质量的交付出去。看不到相互的仇恨和推诿，更多的是相互的支撑和支持。这种体验让经历过传统团队的我，确实感觉倍加舒服。那面看板墙以前的工作中，我一直好奇的一个问题就是我的老板是怎么掌握项目的进度的。虽然我们也使用scrum的实践，虽然我们每天也站会，但是我作为一个团队成员，总是感觉我并不清楚，现在项目到底是一个什么状态，而我仅仅是完成每天分给我的一个个task。我隐约的觉得之并不是一个正常的状态。而我加入ThoughtWorks在看到那面看板墙后，我心中的困惑一下解开了。我们一直使用看板来管理我们的项目，有了看板，让所有的团队成员对于项目的进度一目了然。每个story的情况所有人都很清楚，而在站会的时候所有人过一下板子，对于项目的运行情况，对于遇到的问题一清二楚了。现在我在做自己的side project的时候也会首先建起一面看板墙。结对编程在ThoughtWorks的工作方式，一般来说都是结对编程，对此不同人有不同的看法，我也并不想说结对编程到底好不好，仅说说我自己感受的好处吧。结对的第一点好处是能让新人快速进入上下文。不知道有多少同学在拿到一个老的代码库，那种无从下嘴的感觉。通过结对的方式，一个老人带着一个新人，能很快的带新人进入上下文，而且是因为是结对完成一个story，这样就有特定的目标，能给快速的得到反馈，这样新人的学习速度是会大幅度提高的。结对的第二点好处是能较高的保证质量，结对的过程实际上就是一个相互review的过程，两个人通过思维上的交锋和讨论，能避免不少问题的出现，这样使得代码的质量能够得到较高的提升。结对的第三点好处是在结对的过程中，会有大量时间有互相的交流和讨论。你会感受到不同人的不同工作方式，这是一个很好的学习过程。另外结对的过程实际上这就是一个设计的过程，通过表述可以让设计的过程更加的完善，从而减少bug的产生。结对无论好与不好，1000个人有1000个看法，仅就对我而言，这样的工作方式对我帮助很大。团队之感年轻的团队，战斗的团队，成长的团队ThoughtWorks是家年轻的公司，大部分的人都是年轻人，这样的团队战斗力是很强悍的，记得上半年的一个夜晚，突然发生了一个线上的事故，大家立马解决。虽然家里的网络各种的不给力，但是最终还是解决了这个问题，那时已是凌晨4点左右。没有人有半点不满，我之前是无法想象的。之后的Retro中，大家一起分析这个问题的根本原因，并制定了相应的action避免类似的问题再次发生。在实践中学习，从问题中总结，在总结中成长。少有抱怨，更多是怎么办，怎么改变，这样的团队是推进人成长的良好环境。Session文化Session文化是我加入以来感受最深的一个方面，在Thoughtworks你会看到人人都在讲Session，人人都在听Session。在团队中有讲，在公司中有讲，在社区内有讲。你会感觉到人人都在学习，人人都在进步，你要是不学点什么，就会落后在别人后边，这也就是公司讲的同僚压力吧。P3之行将社会的公平公正作为公司Mission的，我听说也就是Thoughtworks一家了，P3的精神和文化可以说是融入在ThoughtWorks的每个人中的，ThoughtWorks的诸多P3项目，从非洲的儿童走失，到医疗公平公正，从关注渔业安全，到帮助慈善组织完善IT系统。公司的确实打实的地在做事情来实践自己的P3 Mission。可以说是所有看到的，听到的，这一切的一起影响，也促使我们做出了全民救援这样的P3产品。这在之前可能是我不层想到，也不会做的事情。加入Thoughtworks在快一年的时间，看到很多，见识了不少，以上只是记忆比较深的小片段。套用我们伟大领袖的一句话，加入骚窝，广阔天地，大有可为。" }, { "title": "Thinking In React Way - 有限状态机", "url": "/posts/react-01/", "categories": "Learning", "tags": "前端", "date": "2016-12-10 08:01:00 +0800", "snippet": "Thinking In React Way - 有限状态机今天来聊聊前端，其实这个公众号刚开始写起来的时候，是想和大家分享数据可视化的一些知识的。这也是图表君名头的由来，后来慢慢就写进了些前端的东西，再后来，因为图表君工作的转换，现在更多的做一些后台的工作，那么讨论的问题就更杂了，现在看起来算是我的一些工作和学习心得和感受吧。好了，说了这么多。今天聊点什么呢？聊聊React。其实这也并不是什么新东西了。2014年，图表君就知道有这么个东西，听着几位业界大牛聊，说这东西有多么多么的好，当时也不是特别的理解，跟了一遍官方的Tutorial，也没有特别的感受。应该是因为当时前端的经验特别的浅（虽然现在也不敢说深，捂脸），没有什么特别的感受吧。Angular的痛后来做了几个项目，使用的是Angular，刚开始觉得双向数据绑定好牛逼啊，好好用，好好用。但是随着项目逐渐的一点点变大，感觉$scope上的东西是越来越多，各个controller里各有各的$scope,再加上$scope是继承的，当项目一复杂就越来越难以管理和控制。还有自己要封装一个组件在angular里得用directive吧，好吧看看directive的文档你就得晕了，link，compile，controller都是什么鬼。好了，今天不是吐槽angular的时间，但是angular得设计和使用的确是太复杂了。前端到底是在干什么好了，让我们先暂时跳出框架的讨论，来思考一下，前端的工作到底是干什么的？其实可以简单的说就是将数据到View的一个映射上，也就是说无论什么框架解决的基本问题就是讲数据展示到View上, 然后将讲用户的操作最后再反应到数据的变化上来。 Data --&amp;gt; Whatever FrameWork --&amp;gt; View Data &amp;lt;-- Whatever FrameWork &amp;lt;-- View再想清楚这个问题之后，React是怎么做的呢？React并不是一个完整的前端框架，只是一个专注于渲染View的library，在看了React的文档之后，我们会发现他的api是很简单的。一个典型的react的组件class ShoppingList extends React.Component { render() { return ( &amp;lt;div className=&quot;shopping-list&quot;&amp;gt; &amp;lt;h1&amp;gt;Shopping List for {this.props.name}&amp;lt;/h1&amp;gt; &amp;lt;ul&amp;gt; &amp;lt;li&amp;gt;Instagram&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;WhatsApp&amp;lt;/li&amp;gt; &amp;lt;li&amp;gt;Oculus&amp;lt;/li&amp;gt; &amp;lt;/ul&amp;gt; &amp;lt;/div&amp;gt; ); }}// Example usage: &amp;lt;ShoppingList name=&quot;Mark&quot; /&amp;gt;即使你没有React的经验，看这样的代码也不会有什么特别的问题。好了，今天图表君不打算安利React，并不想写一个hello world出来。这样的文章太多，看看React的官方例子会比图表君写的好很多。那么今天说什么呢？React Thinking - 状态机看这部分之前，图表君强烈建议你可以看一看React的官方tutorialtutorial，很好的一个例子，也不长。一个小时就能看完，自己上手写一写，感受会更深。好了现在假设你看完了这个tutorial有什么感觉？图表君的最大的感受是，最后将State，function都定义到了Game的这个Root级别的Component上了，再把所有的数据和function都传进自己的子Component里，需要的地方直接调用就好了。这样就使得我们上边说把Data的操作逻辑都被提出来，并集中在一起了，一下就清晰了，明确了。App管理从此变得一下简单了。反复品味这样的设计，忽然有个东西，进入了我的思维里。这东西不就是一个有限状态机呀。有限状态机有限状态机是个十分有用的模型，可以用来模拟世界上大部分的事物，其有三个特征： 状态总数（state）是有限的。 任一时刻，只处在一种状态之中。 某种条件下，会从一种状态转变（transition）到另一种状态。我们再来看看例子中的代码class Game extends React.Component { constructor(){ super(); this.state={ history:[{ squares: Array(9).fill(null) }], stepNumber: 0, xIsNext: true } } handleClick(i){ const history = this.state.history; const stepNumber = this.state.stepNumber const current = history[history.length - 1]; const squares = current.squares.slice(); if (calculateWinner(squares) || squares[i]) { return; } squares[i] = this.state.xIsNext? &#39;X&#39;:&#39;O&#39;; this.setState( { history: history.concat([{ squares: squares }]), stepNumber: stepNumber + 1, xIsNext: !this.state.xIsNext, } ) } jumpTo(step){ const newHistory = this.state.history.slice(0,step+1) console.log(newHistory); this.setState({ history: newHistory, stepNumber:step, xIsNext: (step % 2) ? false: true, }) } render() { const history = this.state.history; const current = history[this.state.stepNumber]; const winner = calculateWinner(current.squares); let status; if(winner){ status = &#39;Winner Is :&#39; + winner; }else{ status = &#39;Next player: &#39; + (this.state.xIsNext ? &#39;X&#39;:&#39;O&#39;); } const moves = history.map((step,move) =&amp;gt; { const desc = move ? &#39;Move #&#39; + move : &#39;Game Start&#39;; return( &amp;lt;li key={move}&amp;gt; &amp;lt;a href=&quot;#&quot; onClick={() =&amp;gt; this.jumpTo(move)}&amp;gt;{desc}&amp;lt;/a&amp;gt; &amp;lt;/li&amp;gt; ) }); return ( &amp;lt;div className=&quot;game&quot;&amp;gt; &amp;lt;div className=&quot;game-board&quot;&amp;gt; &amp;lt;Board squares={current.squares} onClick={(i) =&amp;gt; this.handleClick(i)} /&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;div className=&quot;game-info&quot;&amp;gt; &amp;lt;div&amp;gt;{status}&amp;lt;/div&amp;gt; &amp;lt;ol&amp;gt;{moves}&amp;lt;/ol&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; ); }}构造方法，constructor - 定义了APP的初始状态。handleClick - 定义了在棋盘里点击事件后的APP状态的变化。jumpTo - 定义点击历史记录中某一步后APP的状态变化。render- 描述如何在View上来展示当前的状态。这样精巧的设计，facebook果然聚集了当今世界一流的工程师。然后我看了阮一峰的这篇介绍有限状态机的文章，看到这段代码。var menu = {　　 　　　　// 当前状态　　　　currentState: &#39;hide&#39;,　　　　　　// 绑定事件　　　　initialize: function() {　　　　　　var self = this;　　　　　　self.on(&quot;hover&quot;, self.transition);　　　　},　　　　　　// 状态转换　　　　transition: function(event){　　　　　　switch(this.currentState) {　　　　　　　　case &quot;hide&quot;:　　　　　　　　　　this.currentState = &#39;show&#39;;　　　　　　　　　　doSomething();　　　　　　　　　　break;　　　　　　　　case &quot;show&quot;:　　　　　　　　　　this.currentState = &#39;hide&#39;;　　　　　　　　　　doSomething();　　　　　　　　　　break;　　　　　　　　default:　　　　　　　　　　console.log(&#39;Invalid State!&#39;);　　　　　　　　　　break;　　　　　　}　　　　}　　　　};　　有没有似曾相识的感觉，Redux里是不是就是这么干的？然后再想想Redux，到底干了一件什么事？帮我们做了这样的一个状态机啊，我们开发者只要定义Action，Reducer，他把我们的APP组织成了一个状态机。从这样的角度再来看React,Redux这个的技术栈，我觉得理解的更加的清楚了，当然这仅仅是我的一点点小小的思考，欢迎大家一起讨论拍砖，后边逐步的和大家分享我的心得体会。" }, { "title": "我们在ThoughtWorks打造一款P3产品", "url": "/posts/tw-p3/", "categories": "Building", "tags": "Summary", "date": "2016-11-26 08:01:00 +0800", "snippet": "我们在ThoughtWorks打造一款P3产品从今年3月份加入ThoughtWorks以来，已经过去了8个月的时间，从刚开始的激动，新奇，到逐渐的适应。虽然8个月的时间不长，但是有些新奇的感悟，并且还是特别强烈。初识P3在New Hire Orientation上，公司的HR介绍了ThoughtWorks的3个Pillar。也就是： 可持续化的业务（Run a sustainable business） 追求软件和技术卓越（Champion software excellence and revolutionize the IT industry） 引导社会和经济公平（Advocate passionately for social and economic justice）ThoughtWorks所做的每一件事，每一个决定都是基于这个三个Pillar。当然每个公司都有自己的Mission和Vision。例如Google的Mission是整合世界的信息，让其可以更有效的被人类利用。（Google’s mission is to organize the world’s information and make it universally accessible and useful. ）Facebook的mission是让人们可以更加有效的分享和联结（ Facebook’s mission is to give people the power to share and make the world more open and connected.）每个公司无论大小，无论是否被总结写下来，都有自己的Mission，只不过有大小之分罢了。ThoughtWorks的Mission，前两条都很好理解，我们追求可持续化的业务，我们追求软件技术的卓越。例如我们定期的会发布技术雷达，为行业提供技术选型的指导，我们为客户提供敏捷软件工程方法，提高客户的软件工程质量。但是ThoughtWorks将追求社会和经济公正，作为自己的Mission之一，而且写出来说出去，在之前我并不是十分的理解。追求社会和经济公正，在一个国家来说，不应该是政府应该做的事情吗？如果提高到一个人类的角度上来说，那不应该是联合国应该做的事情吗？会不会是仅仅说说而已？其实很多大公司也做慈善，比如说可能会捐献一些善款，组织一些公益活动。当然这些都是很好的回馈社会的方法。但ThoughtWorks的做法的确不同，公司更多的是利用自己的技术，来推动和影响社会和经济公正。ThoughtWorks与很多NGO组织合作，利用技术的手段来帮助他们提高IT能力，让他们能更高效的完成工作。ThoughtWorks组建的思沃学院，为在校的学生提供更多技术指导和培训，帮助学生成长。当看到了这些以后，我慢慢的觉得，公司的P3好像并不是仅仅的说说而已，而是尽自己的能力，来改变一些事情。实话实说，这种冲击对我来说还是挺大的，但更大的冲击，是来自于我看到了“心声”这个APP。缘起“心声”是Thoughtworks西安Office的开发人员，利用自己的业余时间，做出一款帮助聋哑人与正常人交流的APP，可以让正常人的语音转换为文字，帮助与聋哑人交流。这是我之前根本不会想到的事情，当我看到身边的同事，花费自己的时间，利用自己的技术，在确实帮助聋哑人的时候，感受到了P3已经确实融到了TWer的DNA里。在这家公司做这样的事情，是一种自然而然的事情。那么我又能做点什么呢？直到有一天看到一篇报道文学，讲述是中国人口老龄化，农村和城镇的空心化，产生了大量的留守老人，有一些因为无人照顾，突发疾病，发生一桩桩人间悲剧，具体的我就不详细描述了，因为是实在是太过悲惨。感慨万千一番，我想，自己能做些什么，哪怕能带来一丝丝的改变？当然我改变不了，中国城市化的进程，让大城市的年轻人能回乡照顾自己的亲人；当然我改变不了，国家的户籍政策，让这些留守老人，能在大城市与自己的子女团聚。当然我也改变不了，现在的养老行业，让留守老人可以都住在养老院里，得到基本的照顾。但是我可以做的是，利用自己的技术，帮助他们在生命紧急的关头，发出求救的信号。开始产品梳理有了这样的想法，与身边的小伙伴一起商议，得出了一个成型的方案，简单来说就是开发一个APP，搭建一个平台。在一个城市，一个社区，或者村桩里，招募志愿者。同时开发老人端的APP，和一些硬件设备，比如说手环，手表等等。当老人发生危险或者需求救助的时候，他可以按下这些设备上的救助按键。那么这个救助信息就会在平台上看到，附近的志愿者就能看到，从而在最短的时间内能提供救助，避免悲剧发生。当然这只是一个初始的想法。紧接着我们就做了一次User journey，梳理了对于我们最为关键的需求点。理清楚需求后，安装优先级划分好task，并建起了我们的项目看板，追踪项目的运行情况。技术选型产品需求梳理好了以后，下面的问题就是如何进行技术选型了。第一个问题就是因为我们都缺乏硬件的知识，考察了市面上现有的手环，没有发现提供SDK可以让我们直接利用的。又想到了Apple Watch，但是想到高昂的价格并不是一个最好的选择。于是乎还是决定再做一个针对老人的手机APP。同样因为我们的Mobile开发经验，并不是特别的丰富，于是选择了React Native。并设计出了我们的系统构架图。但是迟迟没有找到一个合适硬件产品，来触发求救信息始终让我们觉得这还不是一个真正可用的产品。终于有天，公司广发英雄帖，召开技术大赛。并在邮件中介绍了一款AWS刚出的硬件设备AWS IOT Button。这让我们都眼前一亮，这不就是我们要找的东西吗。简单来说IOT Button的按键可以trigger AWS上的一个lambda。有了这个，后边的事情就是我们的强项了，于是乎立马报名参赛，并购入了IOT Button。产品实现下面就进入到了具体开发的阶段，充分的发挥每个人的特长，虽然大家都是开发，但是有人有UX的特长，有人有mobile的特长，大家各尽所能，发挥自己的特长，让这个产品越来越好，首先就是UI设计。React-Native可以说是给传统的APP开发带来了新的方式，可以让传统的web开发人员可以快速的实现产品。但是同样也是因为它在快速的发展中，也带了不少问题，例如API的变化，第三方组件的支持，但是好在我们的产品场景相对的简单，所以使用ReactNative还是一个比较好的选择。同时救助者的实时位置同步也是一个比较大的挑战，我们可以在自己的后台的实现一套消息队列的服务，来做位置同步。但是最终我们使用了市面上成熟的实时数据同步服务，来快速的实现产品。目前产品已经进入了后期开发的阶段，小伙伴们在进行最后的优化，期待能在最后技术大赛的showcase里拿出一个能够成行的，可以真正帮助到老年人的产品出来。Why从初始想法的生成到现在产品的逐渐成行，花费了我们不少的业务时间，有朋友问做这些事为了什么？其实我现在也说不好，在加入TW之前，遇见一些社会事件，可能最多也就是捐点钱，在网上转发转发，评论评论。加入了TW后，看到了这么多之后，自己也想真正做些事情，可以让这个社会能变得稍微美好一点。" }, { "title": "图表君碎碎念", "url": "/posts/Summary01/", "categories": "Thinking", "tags": "Summary", "date": "2016-11-06 09:25:00 +0800", "snippet": "大家周末好，天气这是越来越冷了，冬季到来了。西安冬日的传统雾霾又上演了，不过最近又限行了，希望能有点用处吧。好了今天不说什么新的东西，把之前的坑给填一填吧。上篇文章的最后给大家留了一个问题，如果顺序的执行多个promise，已经有同学答对了，就是用链式调用。的确答案就是如此，那么具体一点怎么做链式调用呢？那么我们来看一个例子吧。var guid = 0;function run() { guid++; var id = guid; return new Promise(resolve =&amp;gt; { setTimeout(function () { console.log(id); resolve(id); }, (Math.random() * 1.5 | 0) * 1000); });}var promises = Array.from({ length: 10 }, run);Promise.all(promises)上篇文章（上边的例子）中我们看到了 使用promise.all可以把几个promise组合起来使用，那么如果我们想让这些promise顺序执行改怎么办呢？来看答案。var guid = 0;function run() { guid++; var id = guid; return new Promise(resolve =&amp;gt; { // resolve in a random amount of time setTimeout(function () { console.log(id); resolve(id); }, (Math.random() * 1.5 | 0) * 1000); });}var promises = Array.from({ length: 10 }).reduce(function (acc) { return acc.then(function (res) { console.log(res) return run().then(function (result) { res.push(result); return res; }); });}, Promise.resolve([]));这里有点很有意思，我们先创建了一个创建一个长度为10的Array出来，然后呢，调用了其上的reduce方法，关键是这个reduce方法有意思了，传入的初始值是个resolved的promise，然后传入了一个function，其作用就是将这些promise都chain了起来。这样达到了顺序调用的目的，当然可以用其他写法达到目的，但是使用reduce还是有点意思的。大家有兴趣了可以自己来试试。OK，之前在介绍DockerFile的时候图表君还是留了问题。下边的DockerFile其实定义的是有问题的。 FROM node:4.6 MAINTAINER Aaron Chen&amp;lt;mail@aaronchen.cn&amp;gt; RUN mkdir /app WORKDIR /app COPY . /app RUN npm install EXPOSE 8080那么问题在哪呢？问题就是这样的DockerFile我们就不能利用webpack-dev-server的hot reload的特性了。这对于开发阶段是相当大的效率影响的，那么如何解决呢，也是比较容易的，我们将代码做成一个volume挂到容器里就解决问题了。下边说几句非技术的话题，技术的道路做久了，都会考虑到技术路线的问题，作为一个年轻人图表君并没有太多的经验，但是上周看到了池建强老师的一篇文章，说的挺好，在这里分享给大家。 技术发展（这里只谈我了解的软件）不外乎三条路：算法、底层和业务。能在一条路上精通，就很不错了。而厉害的人可以同时兼顾两条路。三条都牛的人，蛮罕见的。 技术1：算法路线 走算法路线，对智商的要求是高于其它路线的。但也不能说高到哪里去了。毕竟在企业里做算法工作，更多的是应用成熟算法，而不是自己设计算法。 算法路线比较适合耐得住寂寞的人，因为做算法常常是站在产品的幕后，好的结果又往往需要慢慢「熬」出来。算法往高走，对基础的要求就比较高了。不是博士出身，没在顶尖研究机构混过，在企业里也很难做出特别牛的成果。所以一般本科生不太建议走这个方向（当然，本科生也不用太难过，毕竟没退学生也做出过一些惊人的成就，池建强注）。 技术2：底层路线 底层路线，是围绕着操作系统、编译原理、分布式系统、数据库、软件工程这些理论，用各种工具搭建出酷酷的应用开发、运行环境。把各种复杂的工具跑起来，不仅和谐共处，还能发挥各自的长处，弥补各自的短处，并不是个简单工作。如果能再自己开发一些好用工具，就更不简单了。 极客、黑客范儿的人，是最适合走这条路线的。爱折腾，爱尝鲜，崇尚开源文化，细致缜密，是做好这一行的标签。 运维、DevOp、云计算、大数据、架构师，这些岗位或领域的人，多是能呼云唤雨的底层高手。 技术3：业务路线 大多数技术都是在业务线生存和创造价值的。如果论技术光环，这条线是比不过前两条的，容易产生「对技术能力要求不高」的感觉。从某些角度看，确实如此，但这条线也有自己独步天下的技术，那就是复杂业务建模能力。修炼这项能力，除了技术的通用要求外，还需要比其它路线更强的沟通能力和抽象能力。或者说，对情商的要求最高。适合自己的才是最好的，到底走那条路线是一个选择问题，做出自己的选择，并坚持的走下去。这可能是漫长和痛苦的过程。好了，唠唠叨叨了这么多，今天就写到这吧，我们下周见。原创文章，欢迎转发，但请标明出处。欢迎关注图表君的公众号，一起成长。在微信中搜索 “多彩数据” 或者 “Data_Visualization”" }, { "title": "只为那句承诺-大话Promise", "url": "/posts/promise/", "categories": "Learning", "tags": "Summary", "date": "2016-10-23 08:01:00 +0800", "snippet": "只为那句承诺-大话Promise大家周末好，要说最近几年什么语言大红大紫，当属JavaScript了。话说虽然是10天就创造出的语言，但是人家能文能武。web前端自然不必多说了，各种框架你方登罢我上场，前两年还是Angular一统天下，这两年React又是大红大紫，还有Vue最近异军突起，好不红火。要是仅仅是前端也就算了，但是由于Node.js人家在后台也能写，React Native的出现让人家移动端也能做。好吧，还有硬件上也出现Ruff方案，好像硬件上也能写了。真是让人感觉挺有意思的事情。图表君上边叨叨了这么多，难道是为JavaScript唱赞歌的吗？呵呵，其实并不是。只是最近因为在用上篇文章介绍的AWS Lambda。Lambda现在只支持Java，Node.js,Python。最终选择了Node.js进行开发，不可避免的要牵扯到异步操作的问题。那么今天就来聊聊JavaScript中的Promise。什么是Promise Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。上面是Promise的一个定义，引自阮一峰的ES6标准入门一书。S6标准入门。多说一句，目前的JavaScript项目无论是前台或者是后台，都应该采用ES6的标准语法来写，ES6让JavaScript的书写更加的清晰和规范。基本用法如何来构造一个promise对象呢？ES6中提供了原生Promise可以使用。var promise = new Promise(function(resolve, reject) { // ... here is some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }});上面的例子给出了new一个promise对象的方法，Promise的构造函数接受一个函数作为参数传入，这个函数的两个参数，reject和resolve是JavaScript本身提供的两个函数。一个promise对象有三个状态分别是，pending，resolved，rejected。resolve函数可以将pending状态转变为resolved状态。reject函数可以讲pending状态转变了rejected状态。对象的状态不受外界的影响，同样也是promise名字的由来。外部你拿着我的一个承诺，一会我会告诉你我的状态。promise对象通过then方法来添加回调函数。例如这样promise.then(data=&amp;gt; console.log(data), err=&amp;gt; console.log(err));当promise被resolved的时候，就会把data log出来。当promise被rejected的时候，err就会被log出来。看上去好像是挺简单的，的确Promise的应用使得异步的操作，以同步的形式表现出来。当发生错误的时候可以通过catch方法，来定义回调函数。怎么用上边都是一些干巴巴的定义，那么到底该怎么用呢？Promise又怎么样的解决了问题呢，下边我们看一个例子。假设下边一个场景，我们一个服务，从一个外边service获取数据，然后写到一个db里，或者一个存储里，最后在把存储的状态龙出来，那么如果没有promise是怎么写的呢？可能会是这样。getData(function (value1) { storeToDb(value1, function(value2) { logStore(value2, function(value3) { //... }); });});传统的回调的写法，这样使得代码逻辑混乱在一起。再想想如果再加上错误处理的情况，更是酸爽。那么用promise来写会怎么样呢？看下边这样的代码function getData(){ return new Promise((resolve,reject) =&amp;gt;{ // ... send request to get data if(/* get successfully*/){ resolve(data) }else{ reject(err) } })}function storeData(data){ return new Promise((resolve,reject)=&amp;gt;{ // ... store the data if(/*store successfully*/){ resolve(data) }else{ reject(err) } })}getData() .then(data =&amp;gt; storeData(data)) .then(data =&amp;gt; console.log(&#39;the process is done&#39;,data)); .catch(err =&amp;gt; console.error(&#39;there is the err&#39;,err));这样写是不是就是很清楚了，先getData，然后再storeData，最后将这次运行的情况log了出来，其中有任何的问题，在catch中都可以Catch出来。代码的逻辑以同步的方式得到了体现。我们来看看如果是其他语言会怎么写，下边是个ruby的语言的例子def get_data // ...send request if /*get successfully */ return data else raise GetDataError endenddef store_data // ...save to db if /*save successfully */ return data else raise StoreDataError endend/*Main Logic*/begin request_data = get_data db_data = store_data request_data p &quot;here is the store data #{db_data}&quot;rescue e p &quot;here is some errors #{e}&quot;end我们对比两个例子，可以看到在使用的Promise后让JavaScript的异步方式的编程模式更将清楚，也更加让人容易理解。由于JavaScript的执行环境是单线程的，所以大量采用了异步的方式来进行编程，这使得我们写起代码并不十分符合我们一般的习惯。但是Promise的出现让这种问题能得到一定程度的缓解。但是异步操作异步操作的好处，比如上边的那个例子，如果我们想要做的同时并发10个操作，那个在ruby或者其他语言中中就要启多个线程来进行。但是JavaScript就完全没有这个问题。只要简单的loop下就行了。但是如果我们想要在这10个操作完成后根据返回的状态做点其他操作该怎么做呢？这时候用Promise.all就是最好的了。let p = Promise.all([p1, p2, p3]);Promise.all接受数组作为参数传入，每个元素都是一个promise对象。只要所有子promise都resolved以后，p才会被resolved。只要有一个被rejected，这个p就会被rejected。但是有一点是这些子promise之间并不会有顺序的关系。再来看一个例子：var guid = 0;function run() { guid++; var id = guid; return new Promise(resolve =&amp;gt; { setTimeout(function () { console.log(id); resolve(id); }, (Math.random() * 1.5 | 0) * 1000); });}var promises = Array.from({ length: 10 }, run);Promise.all(promises)OUTPUT:23567810149从这次的output可以看到，promise之间并没有顺序执行，实际上是并发的。那么如何让这些promise是顺序执行呢？留个大家自己思考下，下篇文章，我们揭晓。或者可以联系图表君，私下告诉你答案哦。 ps，当然也可以用一些第三方的库和方案，例如（async）来实现顺序操作，但是代码的乐趣不就是做些思维挑战吗:)原创文章，欢迎转发，但请标明出处。欢迎关注图表君的公众号，一起成长。在微信中搜索 “多彩数据” 或者 “Data_Visualization”" }, { "title": "只为那句承诺-大话Promise", "url": "/posts/aws_lambda/", "categories": "Learning", "tags": "Summary", "date": "2016-10-23 08:01:00 +0800", "snippet": "只为那句承诺-大话Promise大家周末好，要说最近几年什么语言大红大紫，当属JavaScript了。话说虽然是10天就创造出的语言，但是人家能文能武。web前端自然不必多说了，各种框架你方登罢我上场，前两年还是Angular一统天下，这两年React又是大红大紫，还有Vue最近异军突起，好不红火。要是仅仅是前端也就算了，但是由于Node.js人家在后台也能写，React Native的出现让人家移动端也能做。好吧，还有硬件上也出现Ruff方案，好像硬件上也能写了。真是让人感觉挺有意思的事情。图表君上边叨叨了这么多，难道是为JavaScript唱赞歌的吗？呵呵，其实并不是。只是最近因为在用上篇文章介绍的AWS Lambda。Lambda现在只支持Java，Node.js,Python。最终选择了Node.js进行开发，不可避免的要牵扯到异步操作的问题。那么今天就来聊聊JavaScript中的Promise。什么是Promise Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。上面是Promise的一个定义，引自阮一峰的ES6标准入门一书。S6标准入门。多说一句，目前的JavaScript项目无论是前台或者是后台，都应该采用ES6的标准语法来写，ES6让JavaScript的书写更加的清晰和规范。基本用法如何来构造一个promise对象呢？ES6中提供了原生Promise可以使用。var promise = new Promise(function(resolve, reject) { // ... here is some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); }});上面的例子给出了new一个promise对象的方法，Promise的构造函数接受一个函数作为参数传入，这个函数的两个参数，reject和resolve是JavaScript本身提供的两个函数。一个promise对象有三个状态分别是，pending，resolved，rejected。resolve函数可以将pending状态转变为resolved状态。reject函数可以讲pending状态转变了rejected状态。对象的状态不受外界的影响，同样也是promise名字的由来。外部你拿着我的一个承诺，一会我会告诉你我的状态。promise对象通过then方法来添加回调函数。例如这样promise.then(data=&amp;gt; console.log(data), err=&amp;gt; console.log(err));当promise被resolved的时候，就会把data log出来。当promise被rejected的时候，err就会被log出来。看上去好像是挺简单的，的确Promise的应用使得异步的操作，以同步的形式表现出来。当发生错误的时候可以通过catch方法，来定义回调函数。怎么用上边都是一些干巴巴的定义，那么到底该怎么用呢？Promise又怎么样的解决了问题呢，下边我们看一个例子。假设下边一个场景，我们一个服务，从一个外边service获取数据，然后写到一个db里，或者一个存储里，最后在把存储的状态龙出来，那么如果没有promise是怎么写的呢？可能会是这样。getData(function (value1) { storeToDb(value1, function(value2) { logStore(value2, function(value3) { //... }); });});传统的回调的写法，这样使得代码逻辑混乱在一起。再想想如果再加上错误处理的情况，更是酸爽。那么用promise来写会怎么样呢？看下边这样的代码function getData(){ return new Promise((resolve,reject) =&amp;gt;{ // ... send request to get data if(/* get successfully*/){ resolve(data) }else{ reject(err) } })}function storeData(data){ return new Promise((resolve,reject)=&amp;gt;{ // ... store the data if(/*store successfully*/){ resolve(data) }else{ reject(err) } })}getData() .then(data =&amp;gt; storeData(data)) .then(data =&amp;gt; console.log(&#39;the process is done&#39;,data)); .catch(err =&amp;gt; console.error(&#39;there is the err&#39;,err));这样写是不是就是很清楚了，先getData，然后再storeData，最后将这次运行的情况log了出来，其中有任何的问题，在catch中都可以Catch出来。代码的逻辑以同步的方式得到了体现。我们来看看如果是其他语言会怎么写，下边是个ruby的语言的例子def get_data // ...send request if /*get successfully */ return data else raise GetDataError endenddef store_data // ...save to db if /*save successfully */ return data else raise StoreDataError endend/*Main Logic*/begin request_data = get_data db_data = store_data request_data p &quot;here is the store data #{db_data}&quot;rescue e p &quot;here is some errors #{e}&quot;end我们对比两个例子，可以看到在使用的Promise后让JavaScript的异步方式的编程模式更将清楚，也更加让人容易理解。由于JavaScript的执行环境是单线程的，所以大量采用了异步的方式来进行编程，这使得我们写起代码并不十分符合我们一般的习惯。但是Promise的出现让这种问题能得到一定程度的缓解。但是异步操作异步操作的好处，比如上边的那个例子，如果我们想要做的同时并发10个操作，那个在ruby或者其他语言中中就要启多个线程来进行。但是JavaScript就完全没有这个问题。只要简单的loop下就行了。但是如果我们想要在这10个操作完成后根据返回的状态做点其他操作该怎么做呢？这时候用Promise.all就是最好的了。let p = Promise.all([p1, p2, p3]);Promise.all接受数组作为参数传入，每个元素都是一个promise对象。只要所有子promise都resolved以后，p才会被resolved。只要有一个被rejected，这个p就会被rejected。但是有一点是这些子promise之间并不会有顺序的关系。再来看一个例子：var guid = 0;function run() { guid++; var id = guid; return new Promise(resolve =&amp;gt; { setTimeout(function () { console.log(id); resolve(id); }, (Math.random() * 1.5 | 0) * 1000); });}var promises = Array.from({ length: 10 }, run);Promise.all(promises)OUTPUT:23567810149从这次的output可以看到，promise之间并没有顺序执行，实际上是并发的。那么如何让这些promise是顺序执行呢？留个大家自己思考下，下篇文章，我们揭晓。或者可以联系图表君，私下告诉你答案哦。ps:当然也可以用一些第三方的库和方案，例如（async）来实现顺序操作，但是代码的乐趣不就是做些思维挑战吗:)原创文章，欢迎转发，但请标明出处。欢迎关注图表君的公众号，一起成长。在微信中搜索 “多彩数据” 或者 “Data_Visualization”" }, { "title": "图表君聊docker-Dockerfile", "url": "/posts/docker-basic-dockerfile/", "categories": "Learning", "tags": "docker", "date": "2016-10-15 23:25:00 +0800", "snippet": "图表君聊docker-Dockerfile前边几篇文章给大家介绍了docker的三大基本概念。可能大家觉得概念的东西比较生涩，有没有更多实战的例子呢？好了，从这篇文章开始，我会给大家介绍更多实际的例子来帮助大家，那么就从dockerfile开始吧。在介绍docker image的时候，我给大家介绍了build image的两种方法，但是留了一个坑，就是DockerFile，那今天图表君就来把这个坑填了。什么是DockerfileDockerfile实际上是由一行行命令组成的,让用户可以方便的创建自定义镜像。下边就是一个Dockerfile的例子FROM python:2.7MAINTAINER Aaron Chen &quot;mail@aaronchen.cn&quot;COPY . /appWORKDIR /appRUN pip install -r requirements.txtEXPOSE 5000ENTRYPOINT [&quot;python&quot;]CMD [&quot;app.py&quot;]这个例子是启动一个python flask app的Dockerfile（flask是python的一个轻量的web框架）。下边我就来介绍下dockerfile里的指令。通常来说，Dockerfile的指令分为四类，基础镜像信息，维护者信息，镜像操作指令以及容器启动时执行的指令。常用的指令有如下：FROM用于指定基础的images格式为 FROM &amp;lt;image&amp;gt; or FORM &amp;lt;image&amp;gt;:&amp;lt;tag&amp;gt;一个Dockerfile里的第一条指令必须为FORM指令。MAINTAINER格式为 MAINTAINER &amp;lt;name&amp;gt; 用于指定维护者信息。RUN格式为 RUN &amp;lt;command&amp;gt; RUN命令将在基础镜像上执行相应的指令，并提交为新的镜像。CMD启动Docker时运行的命令，一个dockerfile只有一个CMD起效，但是当用户在docker run 时提供了运行的命令时，CMD命令就会被覆盖。推荐的格式为为 CMD[&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]另外一种格式为 CMD[&quot;param1&quot;,&quot;param2&quot;],配合ENTRYPOINT同时使用，其中的两个参数会提供给ENTRYPOINT。ENTRYPOINT配置容器启动后执行的命令,并且不可被 docker run 提供的参数覆盖。每个 Dockerfile 中只能有一个 ENTRYPOINT ,当指定多个时,只有最后一个起 效。COPY复制本地主机的&amp;lt;src&amp;gt;(Dockerfile所在目录的相对路径)到容器里&amp;lt;dest&amp;gt;WORKDIR为后续的 RUN 、 CMD 、 ENTRYPOINT 指令配置工作目录。格式为 WORKDIR /workdirPath上边就是一些基础的命令，还有其他一些命令，图表君就不一一介绍了，大家有兴趣了可以去docker官网上自己查询。我们再来看上边的Dockerfile的例子，现在应该能看懂了把。它定义就是： 从dockerhub上pull下python 2.7的基础镜像。 维护者的信息是图表君 copy当前目录到容器中的 /app目录下 指定工作路径为/app 安装依赖 暴露5000端口 启动app创建镜像编写好Dockerfile后，就可以使用docker build来build images了。其格式为：docker build 选项 [路径]，通常我们可以使用.dockerignore来定义docker build images的时候忽略的文件，通常项目的依赖我们一般会忽略（例如 npm install后的 node_modules）。我们可以使用 docker build . -t pythonflasksample来build image. 然后我们就可以使用docker run 来运行容器。又一个栗子上边是一个python app的栗子，我们再来看一个前端的栗子。├── .dockerignore├── .gitignore├── Dockerfile├── README.md├── app│   ├── directives│   ├── index.html│   └── index.js├── dist│   ├── bundle.js│   └── index.html├── node_modules├── karma.conf.js├── package.jsonimage└── webpack.config.js这是一个Angular的前端project的项目目录。我们用npm来管理和安装依赖的包，用webpack来构建项目。下来用Dockerfile来定义一个docker image，将其容器化。 FROM node:4.6 MAINTAINER Aaron Chen&amp;lt;mail@aaronchen.cn&amp;gt; RUN mkdir /app WORKDIR /app COPY . /app RUN npm install EXPOSE 8080这里Dockerfile的定义，很简单，下载基础镜像node 4.6，安装依赖，暴露接口。下来我们用docker build . -t webpackdemo来build这个image，当image构建好后，简单的执行docker run -it -p 3456:8080 webapackdemo2 npm run start，好了一个前端的project就启动起来了。相当的轻松，让你访问http://localhost:3456/的时候就可以访问了。这里是这个project的github repo，大家可以来一看究竟。dockerSample解决了什么问题呢？如果你是个前端人员，看到这里的时候一定会觉得，这到底解决了什么问题呢？我本地启动也没有什么问题啊。的确图表君刚开始也有这样的疑问，但经过思考，我认为解决了这几个问题： 让开发的环境能更简单的搭建了。经常会有这样的场景，在别人机器上正常的开发环境，在自己的机器上为什么就是不行呢？研究了半天，发现人家用的是node 6.5，自己用的是node 0.11。在使用了docker以后就解决了这样的问题，只要pull下image就OK了，所有的版本和依赖都固定下来了。 现在业绩最流行的构架方式当属于微服务了，一个系统的正常启动依赖于多个服务，有可能对于其中的某些服务我们并不熟悉，那么如果将服务容器化了以后，就能有效的解决这样的问题了。另外对于团队里的其他非技术人员使得他们也能容易的在本地搭建起环境来。其实，上边这个前端项目中的dockerfile有一个很大的问题，图表君给大家留个问题。如果大家看出来了，欢迎给我留言好了，Dockerfile就介绍这么多，我们下期再见。原创文章，欢迎转发，但请标明出处。欢迎关注图表君的公众号，一起成长。在微信中搜索 “多彩数据” 或者 “Data_Visualization”" }, { "title": "图表君聊docker-仓库", "url": "/posts/docker-basic-repo.markdown/", "categories": "Learning", "tags": "docker", "date": "2016-10-08 23:25:00 +0800", "snippet": "图表君聊docker-仓库今天我们来继续聊docker，上篇文章我们介绍了docker里的Container。今天来继续三大概念中的最后一个–仓库（Repository)。当我做好了一个Image，我该怎么和其他人分享呢？答案很简单，把他push到一个仓库里，这样其他人也能使用我的Image了。这个仓库可以是一个私有的仓库，供一个team内部使用。也可以是一个公共的仓库，开放给所有使用。目前docker官方维护一个公共仓库 Docker Hhub,里边有大量的image，可以满足我们的大部分需求。当然首先你得注册一个docker hub的账号，由于众所周知的原因，你需要用一些科学的手段才能注册上。登录当注册好docker hub的账号以后，就可以通过 docker login来登录了。login后我们可以搜索自己需要的image来使用。like this:docker search pythonNAME DESCRIPTION STARS OFFICIAL AUTOMATEDpython Python is an interpreted, interactive, obj... 1285 [OK]kaggle/python Docker image for Python scripts run on Kaggle 40 [OK] azukiapp/python Docker image to run Python by Azuki - http... 4 [OK] dalenys/python Docker image of Python. 4 [OK] vimagick/python mini python 3 [OK] pandada8/alpine-python An alpine based python image 3 [OK] 当选择好相应的的image后，我们就可以 pull Image到本地进行使用了。PUSH Image有了docker hub，就可以讲本地的image push 到hub上这样，其他人就可以进行使用了。首先我们先tag 一个image，然后将其push到我们的repo里。docker tag image YOURNAMEHERE/imagedocker push YOURNAMEHERE/imagedocker tag training/webapp fmcand/pythonappdocker push fmcand/pythonappThe push refers to a repository [docker.io/fmcand/pythonapp]ok,现在登录docker hub你就可以看到自己push的image了。Auto Build我们可以通过Dockerhub 上的Auto Build的方式来自动的创建Image。但是要用到dockerfile，之前介绍过我们build 一个docker Image可以通过dockerfile的方式来进行，但是我们还没有详细介绍dockerfile。（其实Dockerfile是下一篇文章的主题）简单说，过程是这样的： 在我们的代码里添加dockerfile用于描述如何build 包含我们app的docker image 将我们的github repo 和docker hub 进行配置链接 每次我们checkin 代码的时候就会自动的trigger docker hub 去build image这部分内容后边的文章会详细的介绍，大家如果现在看不太明白可以不必着急。ok，那么问题来了，其实我们国内用户访问docker hub 和github会有些问题，那么如何解决呢？其实国内的一些厂商也提供了类似的服务。后边的文章会详细的介绍。私有仓库当然，在现实的世界里，我们会需要搭建自己的docker repository，供团队内部使用。docker同时提供了自己搭建私有仓库的方法，我这里不做详细介绍了，大家可以google一下。如果确实需要，或者有什么问题，大家可以个我留言或者以后写另一文章专门介绍。好了，docker的三大核心概念就介绍完毕了。下一篇我们继续dockerfile，并看些实战的例子。原创文章，欢迎转发，但请标明出处。欢迎关注图表君的公众号，一起成长。在微信中搜索 “多彩数据” 或者 “Data_Visualization”" }, { "title": "图表君聊docker-Container", "url": "/posts/docker-basic-container/", "categories": "Learning", "tags": "docker", "date": "2016-10-01 23:25:00 +0800", "snippet": "图表君聊Docker-Container上篇文章我们介绍了Docker三大概念中的Image，这篇我们来介绍Container，上篇文章中我们了解到了Image是运行在Container中的，实际上在容器里跑的指令都是在Container中run的。启动容器启动容器的方法一般有两种： 基于一个Image重新启动一个新的容器 启动一个现在已经是在Stopped状态下的容器。来试着运行下边的这个命令： docker run ubuntu /bin/echo &#39;Hello Docker&#39; Hello Docker有没有感觉和本地执行 echo ‘Hello Docker’ 的速度没什么差别？但是其实人家是在一个Container里运行的啊。想想之前用VM的情况，启动一个instance得2分钟，所要执行的Job只有几秒而已。如果同样的Job放到docker里跑，那会快多了，太爽快了。所以一般用户在使用容器的时候都是随时新建和删除容器的。上边那个例子是我们用docker 运行了一个输出语句，下面我们来看这样一个例子： docker run -t -i ubuntu /bin/bash root@42099bcd8196:/# ls bin boot dev etc home lib lib64 media mnt opt proc root run sbin srv sys tmp usr var这样进入了一个docker container 并运行ls命令。-t让docker分配一个伪终端绑定到容器的标准输入上， -i让容器的标准输入一直打开。容器的启动过程那么一个容器的启动到底经历那些过程呢： 检查images如果本地不存在就是从远程仓库下载。 利用镜像创建并启动一个容器 分配一个文件系统，并在只读的镜像层外层挂接一个写读写层。 从宿主主机配置的网桥接口桥接一个虚拟接口到容器中 分配一个ip地址给容器 运行用户给定的应用程序 运行完毕，容器被终止。容器的启动过程，对于理解容器至关重要，需要深入的理解。使用docker ps -al查看所有的历史，使用docker start可以启动一个已经终止的容器。后台运行添加 -d参数可以后台运行docker container docker run -d ubuntu /bin/bash -c &quot;while true; do echo hello docker; sleep 2; done&quot;这样我们就看不到容器的输出信息了，可以通过docker logs来查看docker logs [container ID or NAME]like thisdocker logs 133e58dbdc78hello dockerhello dockerhello dockerhello docker...停止容器要停止一个容器也是相当简单的，docker stop就能办到了。同时，对于终止状态的容器，我们可以采用docker start来启动。通过docker restart来重启这个容器。docker stop [CONTAINER ID OR NAME]进入容器当我们使用 -d参数运行了一个Container的时候，有时候我们需要进入这个容器进行一些操作。例如有这样的一个情况，我们运行了一个app在一个容器里，我们想进入容器看看，这个app运行的状态，查看log。那们如何进入呢？其实有很多种方法，这里介绍两种。第一： docker attach [CONTAINER ID OR NAME]$ docker run -d --name topdemo ubuntu /usr/bin/top -b$ docker attach topdemotop - 02:05:52 up 3:05, 0 users, load average: 0.01, 0.02, 0.05Tasks: 1 total, 1 running, 0 sleeping, 0 stopped, 0 zombieCpu(s): 0.1%us, 0.2%sy, 0.0%ni, 99.7%id, 0.0%wa, 0.0%hi, 0.0%si, 0.0%stMem: 373572k total, 355560k used, 18012k free, 27872k buffersSwap: 786428k total, 0k used, 786428k free, 221740k cachedPID USER PR NI VIRT RES SHR S %CPU %MEM TIME+ COMMAND 1 root 20 0 17200 1116 912 R 0 0.3 0:00.03 top这里我们使用了attach命令进入了容器，看到了top命令的输出。回到我刚才说的那个例子，如果有个Container后台里执行的是一个webapp，如何看到logs 或者是输出呢？接下来具体说说。docker run -d --name webapp -p 5000:5000 training/webapp在执行了这个命令后，我们在后台run了一个images为training/webapp的Container（这是一个python的flask app）我们将本机的5000端口与Container的5000端口（flask的默认端口）进行了mapping。当我们从Browser访问的时候，我们就能访问到这个app。当我们在本地开发的时候，我们很容易的可以从console里看到，这个app的访问的记录，同时也能方便的查看log文件。那么这些在容器里怎么进行呢？当然我们可以使用上边介绍的attach命令。docker attach webapp当从浏览器访问这个app的时候，通过attach我们可以看到Container里的输出。docker attach webapp172.17.0.1 - - [04/Oct/2016 04:44:23] &quot;GET / HTTP/1.1&quot; 200 -172.17.0.1 - - [04/Oct/2016 04:44:24] &quot;GET / HTTP/1.1&quot; 200 -但是问题来了，如果我们要看log文件，或者想进入Container，看看其他的文件状态，该怎么办呢？那么这时候我们就会用到 docker exec了。 docker exec -it webapp /bin/bash root@e0cac87036f0:/opt/webapp# ls Procfile app.py requirements.txt tests.py root@e0cac87036f0:/opt/webapp#通过docker exec我们就在这个Container里又运行了bash，这时候我们就能做其他我们想做的事情了。那么docker attach 和 docker exec有什么区别呢？docker attach 让用户可以进入Container查看输出等等操作，但是并不会另外启动一个进程! 如果你用CTRL-c来退出，同时这个信号会kill Container（默认情况）docker exec 会启动另外一个进程来进入Container，这里的操作是在这个进程下的。如果你用CTRL-c来退出，不会kill 原来的Container好了，对于Container今天就聊到这里，下片文章我们继续聊最后一个概念，Docker仓库。原创文章，欢迎转发，但请标明出处。欢迎关注图表君的公众号，一起成长。在微信中搜索 “多彩数据” 或者 “Data_Visualization”" }, { "title": "图表君聊docker-基本概念", "url": "/posts/docker-basic-1/", "categories": "Learning", "tags": "docker", "date": "2016-09-26 09:25:00 +0800", "snippet": "上篇文章我们介绍了docker的历史由来带来的一些好处，从这篇文章开始，我们开始正式的进入Docker的世界，首先给大家介绍一下Docker一些基本概念。Docker的基本概念Docker的基本概念并不是很多，就是三个： 镜像（image） 容器（Container） 仓库（Repository）深入理解这三个概念，对于docker的理解会有很大的帮助。 什么是image呢，简单来说image就是一个镜像，一个系统的snapshot,可以类比于一个vm的image，或者如果你用过AWS，类似于一个AMI文件。 什么是Container，Container是简易版的Linux环境，可以类比的与一个Virtual Machine 或者 一个EC2的instance。 那个image和Container什么关系呢？一个docker Container 需要加载一个image然后执行。image是run在Container里的。 什么是repository呢？repository是一个image仓库，可以将打好的Docker image push这个仓库中与他人分享。相信上篇文章后大家已经把docker安装好了吧。下边我们就来一步步的介绍这个三个概念。Docker Image运行docker pull命令可以从仓库中获取镜像。 docker pull ubuntu:16.04当运行这条命令的时候，实际上是从docker hub 上来请求标记为16.04 的Ubuntu image，当然由于众所周知的原因，pull的速度会很慢。所以我们可以选择从国内的一些repository来pull images。例如这样： docker pull daocloud.io/ubuntu:14.04如何看到我们本地已经pull下来的images呢？使用docker images可以列出本地已有的镜像。REPOSITORY TAG IMAGE ID CREATED SIZEpython 3.5-alpine 4f778158195b 5 days ago 87.58 MBpython 3.5.2-alpine 4f778158195b 5 days ago 87.58 MBpython 2.7-alpine 8b2171e895fd 3 weeks ago 71.97 MB我们可以看到他是来自哪个仓库的，image的标价，全局唯一的ID，创建的时间 和镜像的大小。同样如果我们想查看哪个仓库的images 可以这样： docker images ubuntuimages下载好了，我们怎么运行这个image呢？easy docker run -t -i ubuntu /bin/bash root@fc8e5743f790:/#这样我们就使用这个image创建了一个Container 并运行bash应用。ps.上边的 -t 让docker分配一个伪终端并绑定到容器的标准输入上，-i 让容器的标准输入保持打开。下边的一个问题是如何创建一个image呢，有两种方法，一种是我们基于现有的image，例如这样： docker run -i -t ubuntu /bin/bash root@c5c7fa33b061:/# apt-get update &amp;amp;&amp;amp; apt-get install -y curl ...我们创建了一个docker container 并在其中装上curl，这是注意我们得记下他的ID。 docker commit c5c7fa33b061 ubuntu-have-curl docker history ubuntu-have-curl我们使用了docke commit 生成了一个new image ‘Ubuntu-have-curl’，并用docker history看看这个image的历史。下来我们用这个image来curl一下。docker run ubuntu-have-curl curl https://www.baidu.com % Total % Received % Xferd Average Speed Time Time Time Current Dload Upload Total Spent Left Speed100 2443 100 2443 0 0 12234 0 --:--:-- --:--:-- --:--:-- 12215easy? Yes.这样我们就build一个带curl的Ubuntu image，你可以把他push 到 docker hub上，让更多人使用了。使用docker commit 可以对于一个镜像做些简单的扩展，但不方便分享和他人的利用。另外一种方式是使用dockerfile，这是更加通用的方法，这里暂不详解，后边会专门的介绍dockerfile。我们看了pull，build，run一个image，下来看看如何删除吧。命令很简单 docker rmi docker rmi ubuntu:14.04当我们使用了一段时间以后，我们运行docker images会发现有很多没有tag的images，大量占据着磁盘空间，那么势必就要清理下了。运行下边这条命令，我们就可以清理下了。$ sudo docker rmi $(docker images -q -f &quot;dangling=true&quot;)" }, { "title": "周总结", "url": "/posts/week-summary-this-week/", "categories": "Thinking", "tags": "Summary", "date": "2016-09-25 09:25:00 +0800", "snippet": "周总结这个周学到那些东西呢？ 写代码的时候，特别是logging error的时候，如何能够更好的定位Issue这是为了帮助自己，例如在做loader的validator的时候，如果放到转换里边，并不知道现在validator的数据是那个文件的，那么这样如果id，name都为空的时候，这样就不能给一个有效的提示了。还有在validator一个文件的时候，是发现一个错误就报出来，然后部去处理其他，还是全部validator以后把错误的field都报出来。显然第二方式是更好的方式了。 Ruby Rspec 中的 raise error 常常要进行regex的判断，regex 是不加引号的，加了引号就成为string了. 直接 /^XXXXXXX/就OK了。 Rails 里的Create 是不写入了，create！是写入的。 Rails Model.Create!([]).这样一次插入多条，这是一个transcation，但有错了是一次都rollback回去的。所以批量插入的时候就有个validator的问题了，什么时候validator？ 插入之前，都validator一把，把不合适的filter过，再插入。 直接试着插入，看看有没有raise error，catch住error再validator 一把，滤掉后再插入。 第一种方法是可能有性能问题。如果错误的机会不大，实际上是浪费。第二种没有这个问题，但是logic上有点奇怪，但是可以考虑采用。 Rspec Mock，or UT中的Mock，UT是为了测试一个Class的logic 所以有些引入的其他类就要mock掉，还有，例如AWS connect， 从ENV获取数据的这些操作的类，都要mock掉，不然真真就是连AWS，CI上没有环境变量怎么搞？然测试的东西与其他隔离，这是好测试的标准。 这周的学习主题是Docker。" }, { "title": "图表君聊docker-开篇", "url": "/posts/docker-1/", "categories": "Learning", "tags": "docker", "date": "2016-09-24 09:25:00 +0800", "snippet": "图表君聊Docker-开篇今天是图表君聊Docker得第一篇，为什么会有这个系列呢？作为容器技术的Docker出现已经有一段时间了，之前零零星星的也看过一些文章，图表君现在所的项目上也在使用Docker，对这种技术的理解也这是皮毛而已，工作上用到也是谢谢DockerFile，然后遇到问题的时候Google一下。最近刚好参加了Docker的培训，正好趁着这个机会，深入学习一下。一句话描述Docker，这货真是个改变世界的技术。Docker的由来Docker原来这是dotCloud公司的内部业余项目，基于Go语言实现，后来开源了加入了Linux基金会，自开源后收到了广泛的关注和讨论，后来dotCloud将公司都改名为Docker Inc.dotCloud公司原本的产品并没有成果，但是凭借Docker做的风生水起了，真是柳暗花明又一村。所以呀，很多朋友们都有自己的side Project，只要大家觉得自己的想法是有趣，有用的。坚持做下去，谁也不知道会不会是下个Docker。Docker的技术特点Docker的技术特点，详细大家都比较的了解了。想比较于传统的虚拟化技术,Virtual Machine包含了一套完整的OS，每个VM上都有自己的GUEST OS。而一个Docker Container并不包含一个OS，只包含这个App和期依赖，所以Docker Container更加的轻量快速。下边这张图大家一看就明白了。-&amp;gt;&amp;lt;--&amp;gt;&amp;lt;-Docker怎么安装呢Docker是基于Linux的容器技术，所以天生在Linux上安装十分的简单。curl -sSL https://get.docker.com/ | sh对于Mac，喜大普奔的是Docker现在原生的支持Docker了。到Docker官网上下载Docker的安装包，简单的几部next，Docker就安装好了。Docker至于Windows，图表君没试过，官网有windows的教程，大家可以参考。Docker到底解决了什么问题一个新技术的出现，备受追捧，必定是解决了一些很多的问题。Docker这么红火到底是解决了什么问题呢？最直观的问题是，Docker让开发，测试，生产环境，彻底的统一了，统一了，统一了。有没有小伙伴有这样的经历，线上出了一个问题，我们查了半天。what the fuck！我本地没问题啊，于是乎上测试环境，生产环境，吭哧吭哧查半天，然后发现是环境配置问题。内心一万个草泥马飞过。现在好了程序写好，做成镜像。想在那里部署运行都行。-&amp;gt;&amp;lt;-另外目前什么样的软件架构最火，当然是微服务了啊。图表君的项目上都是微服务的构建，一个Project，7到8个Repo是很常见的。为了我们搭建开发环境这些services都得启动起来。于是乎一个个的启动。太麻烦了。想当初图表君为了看一个CSS的修改效果，不得不启动3个service，我内心是奔溃的。（虽然是仅仅多run了几条命令而已，然而程序员都很懒的）现在好了一个docker compose up。所有的service都起好了，太方便了，太方便了。-&amp;gt; &amp;lt;-目前，docker还只是运用在开发和测试环境上，但是已经Docker运用在生产环境上，只是时间的问题了。原来在为了run一个简单的job，我可能要启动一个instance，来处理出来，现在我只要简单的run一个docker container就OK了。节省了多少资源成本和时间。特别是对于图表君这种仅仅只有一台阿里云服务器来说，可以做跟多的事情了。特别利用DaoCloud这样的云服务，代码的提交，测试，发布，部署，一下全搞定。生活简直太美好了。好了，开篇就写这个多了。下篇文章开始进入正题。如果你还不知道什么是docker，应该跟新下知识库了。上docker的官网，安装docker，然后跟着图表君一起学习吧。" }, { "title": "工作总结", "url": "/posts/Week-Summary/", "categories": "Thinking", "tags": "Summary", "date": "2016-09-11 09:25:00 +0800", "snippet": "周总结（20160911）RUBY 工作 如何自定义Error类型RUBY ERRORclass CustomError &amp;lt; StanrdErrorend 测试的时候并不测试私有方法，因为测试一个Class目的是为了验证其对外的接口和定义，所以不必测试私有的方法。 Ruby里如何删除一个hash里某个KeyValue pair因为delete方法返回的是那个要删除key的value，但是原来的hash是删除过后。 def delete_pair_by_hash key hash.delete(key) hashend前端 学习工作 遇到的问题 在做web-UI的时候一个select的event 被两个Controller 监听到，因为两个Controller是相互嵌套的，由于JAVASCRIPT的冒泡机制，由于一个事件是一直向上冒泡的，所以被一个监听到并处理之后，并不会解决他，而是继续向上冒泡，所以就被另一个Controller处理了，这样就发生错误了。 遇到问题 CSS的布局问题，当在一overflow：hidden的container中其中的postion:absolute的方式不起作用。 &amp;lt;div style=&quot;postion:relative; overflow:hidden&quot;&amp;gt; &amp;lt;div style=&quot;postion:absolute; top:1px right:2px&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;并不能有效的布局，如何解决呢？Easy前边加个一个div包起来就OK了。 &amp;lt;div style=&quot;postion:relative&quot;&amp;gt; &amp;lt;div style=&quot;overflow:hidden&quot;&amp;gt; &amp;lt;div style=&quot;postion:absolute; top:1px right:2px&quot;&amp;gt;&amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt; &amp;lt;/div&amp;gt;" }, { "title": "人人都是创业者，你的产品就是你自己", "url": "/posts/Create-yourself-1/", "categories": "Thinking", "tags": "感悟", "date": "2016-09-11 09:25:00 +0800", "snippet": "人人都是创业者，你的产品就是你自己本系列文章是观看看陈天直播的心得和总结。在这个大众创业，万众创新的时代，仿佛不创业就一点也更不上潮流似的。同时也就人讲这就是泡沫，那有那么多创业者可以成功。的确是这样的，并不是每个创业者都有最后成功的机会。但是事实上来说，每个人都应该是创业者，你的产品就是你自己。每个公司，每个国家都有自己的短期和长期的目标。一个人的工作时间也有30到40年，但有多少人有目的的打造过自己呢，可能并没有人特意的打造过。打造这个词可能并不好听，他用在一个企业，一个产品，一个项目上听起来可能是比较合适的。但是对于打造自己来说，好像并不是那个好听，但是每一个有想法的人，都需要打造自己，就像一个产品一样，精心的打造自己，无论你是不是创业者。从这个意义上来讲，每个人都是创业者。partner思维把自己和雇主的关系定义为partner，遇到问题看应该如何主动应对。吐槽无意，看看自己能改变什么。这里转述陈天的话： 做好必须要做的事：维护遗留系统 抓住你想做的事情：接待ZebOS 的创始人 Ishiguro 积极主动承担责任：开发自动测试系统 做别人不愿意做的事情：为 ScreenOS 撰写文档 这是Partner思维战术上应该怎么做的，可以想想自己应该怎么做。学习 看书学知识学理论 找到自己的Role modal：伟人，等等 找到自己的memtor，可以见到的人，可以给你经验的人。最后找到自己的 vision，mission，values我的Vision：提供有效的服务，完成他人的使命Mission：技术精深，不吹牛逼Values：技术，诚实。" }, { "title": "征途荆棘，杨帆起航", "url": "/posts/vis-back/", "categories": "Learning", "tags": "Summary", "date": "2016-08-27 09:25:00 +0800", "snippet": "图表君回归八月并不是一个总结的月份。16年已经过了3分之二，然而这一年发生的事情似乎比其他年份发生的都多，开这个公众号也有一年多了，开始容易，坚持不易。今天工作忙了，明天有事出去玩了，断断续续没更新几篇。今日开始复写，先总结总结这一年都发生了什么吧。女儿出生了，快一岁了女儿的降临，是这一年里最大的事情了，全家人的生活都因此发生了改变。小家伙马上就要过一岁的生日了，时间过的真快，天天和她玩一会也是每天最开心的时光。然而有时候工作太忙，没有更多的时间陪伴她。要感谢妻子和丈母娘，承担大量照顾宝宝的职责。怎么当一个父亲，我还在继续学习的道路上。图表君，换工作了这一年，图表君换工作了，离开了工作了四年的IBM，加入了ThoughtWorks。为什么离开？主观原因是在IBM已经不能获得任何发展了，客观原因是不得不走了。都说外企的日子不好过了，的确是这个样子。作为一个年轻人，当你每天都轻轻松松的话，你要小心了，日子过了太安逸了，以后总是要还的。离开自己的舒适区，做让自己困难和不舒服的事，才能获得发展。加入了TW，文化完全不同。新公司，新技术，想想世事轮回，现在开始写起了Ruby，用起了Rails。想想当年和一个好基友，我学python,他学Ruby，我用Django，他用Rails，这世界也是真的很奇妙。现在早已过了认为xxx语言是世界上最好语言的年纪了，用什么学什么，什么合适用什么。用Rails写Web还是挺爽的：）。数据可视化和RAVE虽然公司换了，但是和Reporting的纠缠似乎并没用结束，目前的项目上用的是Tableau，遥想当年老板还说Tableau是个小玩家，世界变化真是快，祝福Cognos一路走好吧。数据可视化依然是我感兴趣了领域，然而之前文章介绍的RAVE已死。以前写过开发的技术才能长足的发展，RAVE的故去可见一斑吧。可喜的是市面上可视化的工具和框架也是越来越多了。以后慢慢的一一介绍吧。糖记的故事糖记是我去年开发的一款IOS APP,用于记录，血糖，血压，体重和推送靠谱的健康信息。为什么做这个APP，公众号中回复“糖记”，查看糖记的故事。今年希望能完成Android版本，帮助更多的人。这篇文章算是年中总结吧，前路荆棘，重新出发，图表君回来了。" }, { "title": "Keyboard不再遮挡住view", "url": "/posts/ios-trickskeyboard/", "categories": "Learning", "tags": "IOS, Summary", "date": "2016-02-28 09:25:00 +0800", "snippet": "Keyboard不再遮挡住View在IOS开发中常见的一个问题就是Keyboard的大小遮挡住了View的问题，那么这样的情况如何解决呢？从实现上来看就是让Constrain按照keyboard的位置进行变化就可以了。 首先是 实例化一个 NSNotificationCenter 的实例。 将keyboard的显示和hide注册为两个observer，同时在相应的observer中实现相应的方法例如： NSNotificationCenter *ctr = [NSNotificationCenter defaultCenter]; [ctr addObserver:self selector:@selector(moveKeyboardInResponseWillShowNotification:) name:UIKeyboardWillShowNotification object:nil]; [ctr addObserver:self selector:@selector(moveKeyboardInResponseWillHideNotification:) name:UIKeyboardWillHideNotification object:nil];当keyboard现实和hide的时候就会调用相应方法。同时在方法上实现那两个方法就可以了。-(void)moveKeyboardInResponseWillShowNotification:(NSNotification *)notification{ NSLog(@&quot;This is the log for show&quot;); NSDictionary *info= [notification userInfo]; CGRect kbRect; kbRect = [[info objectForKey:UIKeyboardFrameBeginUserInfoKey] CGRectValue]; CGFloat duration = [[info objectForKey:UIKeyboardAnimationDurationUserInfoKey] floatValue]; UIViewAnimationCurve curve = [[info objectForKey:UIKeyboardAnimationCurveUserInfoKey] integerValue]; [self.view layoutSubviews]; [UIView beginAnimations:nil context:nil]; [UIView setAnimationDuration:duration]; [UIView setAnimationCurve:curve]; [UIView setAnimationBeginsFromCurrentState:YES]; self.bottomLayout.constant = kbRect.size.height; [self.view layoutSubviews]; [UIView commitAnimations];}-(void)moveKeyboardInResponseWillHideNotification:(NSNotification *)notification{ NSLog(@&quot;This is the log for hide&quot;); NSDictionary *info= [notification userInfo]; CGRect kbRect = CGRectZero; CGFloat duration = [[info objectForKey:UIKeyboardAnimationDurationUserInfoKey] floatValue]; UIViewAnimationCurve curve = [[info objectForKey:UIKeyboardAnimationCurveUserInfoKey] integerValue]; [self.view layoutSubviews]; [UIView beginAnimations:nil context:nil]; [UIView setAnimationDuration:duration]; [UIView setAnimationCurve:curve]; [UIView setAnimationBeginsFromCurrentState:YES]; self.bottomLayout.constant = kbRect.size.height; [self.view layoutSubviews]; [UIView commitAnimations];}注意这里最核心的一点通过notification 的userInfo那到了keyboard的大小kbRect,获得了时间duration，拿到了动画的Curve。拿到这些以后来设置这个UIView的render的参数，通过kbRect的height来设置bottom的Constrain。具体的代码可以参考：" }, { "title": "糖记", "url": "/posts/tangji/", "categories": "Building", "tags": "IOS, 生活", "date": "2016-01-24 09:28:00 +0800", "snippet": "糖记 - 为自己，为家人糖记是一款用于血糖数据记录的app，是我第一款个人app，2015年的目标就是要上线一款自己的app，终于赶在在农历新年之前实现了：）。糖记的由来为什么要做糖记这么一个app呢？2015年对于我来说是很特殊的一年，因为这年我当父亲了，都说不当爹不知父母恩。的确，自有自己有了亲身的体会才知道父母的养育是多么的辛苦。虽然父母之恩无以为报，但是如何孝敬父母呢？可能最好的方式是多点陪伴吧，多点关注吧。父亲血糖有问题，算是轻度的糖尿病。通过饮食和运动的控制，基本还是可以的。但是还是需要定时的进行体检。以前知道有这么个事，因为没什么表现和症状，所以我没太在意。今年陪着父亲去体检了几次，才了解到了对于糖尿病并不能轻视。它的并发症十分的可怕。目前中国18岁以上的成年人有10%是糖尿病的患者，什么概念？就是有1个亿。如果我们把按照年龄来划分，这个比例会更高。谁都不想得病，但是真是有病了，还是要正确对待。虽然糖尿病还没有根治的方法，但是只要能有效的控制，糖尿病人还是可以幸福的生活的。糖尿病的治疗中，血糖的检测是十分的重要。看到父亲还是靠手抄来记录血糖的，就觉得在这个时代应该是有更好的办法。在appstore上也找了不少app，研究了一番，有个是要注册的，上来就问手机号。呵呵，鬼知道你把我信息会怎么卖了。还有就是各种推送的，不胜其烦，就是简单的记录一下，没有必要有那么多功能吧。那就自己造一个吧，送给父亲当做礼物。糖记的功能这是糖记的第一个版本，功能还是很简单的。就是记录血糖，血压和体重的测量值，还有血糖测量的提醒。张小龙说,好的app就是应该让用户用完就走的app，糖记希望能做到这一点。糖记的未来未来的糖记会逐步的添加一些靠谱的功能，例如一些靠谱的科普信息（例如说丁香园，老人的手机里各种养生的“秘方”满天飞，给父母推荐了丁香园的公众号，能得到点靠谱的信息）。还有一个重要的功能，我会着手完成的是，监护者模式。现在越来越多的年轻人与父母不在一起，都在外打拼。每回给家里打电话，父母都说好着呢，让你不要操心。但是事实可能并不是那样。所以糖记未来的一个重要功能就是监护者模式，让在外打拼，放心不下的年轻人能看到父母的血糖情况。问与答问：为什么选择糖记？答：第一，糖记简单，好用。第二，用户所有的数据都在自己的手机上存储，糖记没有数据的占有欲。第三，糖记是个人开发，不作恶是我的信条。问：有没有Android版？答：这个目前还没有，个人比较喜欢Apple的平台，所以只做了IOS版本，当然如果，有小伙伴觉得糖记是个有意思的事情，欢迎联系我，帮助我开发出糖记的Android版。另外个人觉得，IOS的平台还是安全一点，对于科技知识不是那么足的父母那一辈人来说，IOS平台是个相对较好的选择。最后的话糖记是我在业余时间做一款app。如果你的家人如果有血糖的问题，希望糖记能帮助到他们。当然，糖记现在还很年轻，还有很多能改进的地方，例如糖记的图标我就不是很满意（因为我不会设计，图标是稍微自学了Sketch，简单画出来的）。如何你觉得糖记做的是一件有意思，有意义的事情，并且和我一样业余的时间喜欢写代码玩，欢迎和我联系，我们一起把糖记做好。" }, { "title": "Weekly-Summary", "url": "/posts/weekly-summary/", "categories": "Learning", "tags": "Summary, IOS", "date": "2016-01-17 09:20:00 +0800", "snippet": "本周完成了糖记的1.0版本的主要工作，完成了打包上传的步骤。等待apple的审核。本周还进行了其他的学习记录.outlets and Actionoutlets 是一种特殊的OC属性可以用来执行storyboard or nib中的objects，它的keywords是IBOutlet，声明它的表达式为： @property (weak,nonatomic)IBOutlet UIButton *myButton;Action 另一方面呢是可以将storyboard上的object与相应的方法进行连接。函数定义如下可见： -(IBAction)doSomething:(id)sender;其中IBAction是返回值，sender是参数，可以有也可以没有，sender是指向调用这个方法的object的指针。带style的String当然在编辑labeltext的时候，我们也可以是用带style的string。如下： NSMutableAttributedString *StyleString = [[NSMutableAttribiteString alloc] initwithString:plainText] NSDictionary *attributes = @{ NSFontAttributeName:[UIFont boldSystemFontOfSize:_statusLabel.font.pointSize]; }; NSRange nameRange = [plainText rangeOfString:title]; [styleText setAttributes:attributes range:nameRange]; _statusLabel.attributedText = styleText;DelegateIOS 中大量的使用了Deleage的模式进行设计和实现，在我的理解中可以理解为回调函数。Delegate模式的优点在我的理解里是最大限度的讲系统解耦了，在一个objectA定义了delegate的接口，另外一个objectB只要实现了相应的接口方法，当objectA有相应行为发生的时候，只要调用objectB的相应方法就ok了。在整个app的生命周期里，app delegate 作为这个app的delegate，当app有相应的动作发生时候，app delegate里的相应方法就会被调用。相应的方法有：- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { // Override point for customization after application launch. return YES;}- (void)applicationWillResignActive:(UIApplication *)application { // Sent when the application is about to move from active to inactive state. This can occur for certain types of temporary interruptions (such as an incoming phone call or SMS message) or when the user quits the application and it begins the transition to the background state. // Use this method to pause ongoing tasks, disable timers, and throttle down OpenGL ES frame rates. Games should use this method to pause the game.}- (void)applicationDidEnterBackground:(UIApplication *)application { // Use this method to release shared resources, save user data, invalidate timers, and store enough application state information to restore your application to its current state in case it is terminated later. // If your application supports background execution, this method is called instead of applicationWillTerminate: when the user quits.}- (void)applicationWillEnterForeground:(UIApplication *)application { // Called as part of the transition from the background to the inactive state; here you can undo many of the changes made on entering the background.}- (void)applicationDidBecomeActive:(UIApplication *)application { // Restart any tasks that were paused (or not yet started) while the application was inactive. If the application was previously in the background, optionally refresh the user interface.}- (void)applicationWillTerminate:(UIApplication *)application { // Called when the application is about to terminate. Save data if appropriate. See also applicationDidEnterBackground:.}" }, { "title": "IOS-Deleopment-Summary-4", "url": "/posts/ios-deleopment-summary-4/", "categories": "Learning", "tags": "IOS, Summary", "date": "2016-01-03 22:43:00 +0800", "snippet": "this Week I have implement the first tab and most of second tab.add some new things to make it feel good.these are the problems I have faced and also found the solution: chart 重复显示。root cause：update chart 的方法没有实现。solution： 实现update chart 的方法 re-render这个chart，这样就有个问题是chart要重新生成很多回，这样其实并不是一个最优的方案。由于时间的问题，所以暂时还是采取的这样的一种方案，随着知识的累积尝试着将update chart的方法进行实现。 [self.scatterChart removeFromSuperview]; self.scatterChart = nil; [self createTheScatterChart];首先将chart从view上remove下来，然后制成nil，最后重新的create。 chart高等自适应superview高等的问题，取高等是可以用这个方法：view.bounds.size.height 由于这个高等要在autolayout计算之后取得所以在那里调用这样的方法也是同样的问题。最后是在viewDidAppear中进行相应方法的调用，才对的。 segue中指向一个被embedded到nav view中的另外一个view的解决方法。常常因为我们需要在不同的view中来传递值，所以在IOS中就只能在segue的一些方法中进行定义。常见的实在prepareForSegue中进行定义：{ if ([[segue identifier] isEqualToString:@&quot;showItems&quot;]) { ShowItemsTableViewController *destinationViewController = [segue destinationViewController]; [destinationViewController setItems:[self itemsFromCoreData]]; }}但是由于destinationViewController是nav bar 所以怎么才能得到nav bar 后边的真正的viewController呢？下边就是答案： UINavigationController *navController = [segue destinationViewController]; ShowItemsTableViewController *SITViewController = (ShowItemsTableViewController *)([navController viewControllers][0]); [SITViewController setItems:[self itemsFromCoreData]];可以参考这个链接 将nav bar view上的color变了以后相应的embeded进去的view的header bar同样就变了（显然么）. weak and Strong reference. If a method name starts with init, copy, mutableCopy or new, you’ll receive a non-autorelease object. This is not the case here (you are using dateWithTimeIntervalSinceNow) and as a result, you’ll receive an autorelease object. Thus, you are instantiating an autorelease object and therefore it will not be deallocated until the autorelease pool is drained. And your weak reference will not be nil-ed until the object is deallocated. The deallocation of autorelease objects happens when your app yields back to the run loop (or you explicitly create your own autorelease pool). you can also use a non-autorelease object (e.g. use a method whose name starts with init) and this non-autorelease object will be deallocated immediately after being set to nil. __weak NSDate * date = [[NSDate alloc] init]; NSlog(@&quot;%@&quot;，date); // the data will be null since it is an weak variable and it will be release after the assignment.**weak reference是不被记录成为owner的所以在ARC计算的时候是不被计算的**，所以in this case date object就会被释放掉。 /* 同样还要注意的是：If a method name starts with init, copy, mutableCopy or new, you&#39;ll receive a non-autorelease object. This is not the case here (you are using dateWithTimeIntervalSinceNow) and as a result, you&#39;ll receive an autorelease object. 所以非init方法返回的是autorelease 的object！而init返回的是 non autorelease的object */ __weak NSDate * date = [NSDate date]; NSlog(@&quot;%@&quot;，date); //这里的date是有值的，因为没有被autorealse， //Thus, you are instantiating an autorelease object and therefore it will not be deallocated until the autorelease pool is drained. And your weak reference will not be nil-ed until the object is deallocated. The deallocation of autorelease objects happens when your app yields back to the run loop (or you explicitly create your own autorelease pool). // //所以当app后台运行的时候才会这个object才会被autorelease，或者这样： @autoreleasepool{ __weak NSDate * date = [NSDate date]; } NSlog(@&quot;%@&quot;，date); //and **You can also use a non-autorelease object (e.g. use a method whose name starts with init) and this non-autorelease object will be deallocated immediately after being set to nil**:weak/strong/autorelease object" }, { "title": "IOS项目与学习周记", "url": "/posts/IOS-Summary-4/", "categories": "Learning", "tags": "IOS, Summary", "date": "2015-12-29 06:00:00 +0800", "snippet": "IOS-Summary-20151228 add new controller in the tab application create an tab application add the view controller control - drag to the new view controller choose view controllersthese are the steps! more you can access this post:the post link change the cell format to subtitle and can change the image for the cell add the image to the assets.xcassets change the image name in code you can access the image using it: image = [UIImage imageNamed:@&quot;pass&quot;]; unwind segue define the segue in the destionation viewController in the operation page you can drag the button to the exit in the top and choose the defined segue (but only when using size class are chosen) in the 出发的viewController 可以在 Document outline中看到出发的viewController里定义的segue。可以加入identifier的Name，在code中就可以调用这个segue。 [self performSegueWithIdentifier:@&quot;unwindToSugerView&quot; sender:self]; 使用tableview 来做页面layout 定义了几个section 但是想把空白的地方显示为空白，不要显示table cell。这里有个tricks：5.tableview的头里有空白，如何消除这些空白呢，在其attribute inspector 里 uncheck the post link" }, { "title": "IOS-summary-CoreData&amp;Notification", "url": "/posts/ios-summary-coredatanotification/", "categories": "Learning", "tags": "IOS, Summary", "date": "2015-12-28 19:57:00 +0800", "snippet": "Question1:In method application:handleActionWithIdentifier:forLocalNotification:completionHandler:the completioHandler have to be called in the end. but why is that? what did it do?In the article it is said.It’s great that you’re provided this – it means that you can perform asynchronous operations without the system killing your process when you’re in the background.(当你的app在后台运行的时候，可以进行异步操作)。[link]https://www.shinobicontrols.com/blog/ios8-day-by-day-day-25-notification-actionsIOS CoreDataIOS中内置了SQLite的数据库，进行数据的保存。同时提供了CoreData的ORM机制，使得可以不写任何的SQL语句，进行数据库操作。下面就是些总结内容：从上面的图可以看出，coreDataStack 分为三层，最底层用于定于model的关系，实际上是各个表的外键的关系，以及用SQLite实现了数据的保存。第二层用于保存数据与SQL语句的交互，最上一层用于与object进行交互。使用CoreData首先在创建工程的时候，选取使用coredata的选项，在自动生成的xxx.xcdatamodeld中进行定义。关于数据和表的对于关系可以参考下面的图：注意要定义好relationship，中的1对多和，1对1的关系。当做好这些定义之后，创建每个Entity的Class Name。点击Editor选择Create NSManageObject Subclass，这样Xcode 为你创建好了相应的Class。同时在AppDelegate中定义好了相应的方法。###如何使用？在AppDelegate中的- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions方法中： [self managedObjectModel]; [self persistentStoreCoordinator]; NSManagedObjectContext *moc = [self managedObjectContext];对于与上面的三层构架，对应可三个方法，我们平时进行交互的就是moc 也就是NSManageObjectContent。同时可以定于相应的Object的Create方法例如： -(ChroeMO *) createChroeMO{ NSManagedObjectContext *moc = [self managedObjectContext]; ChroeMO * chroeMO = [NSEntityDescription insertNewObjectForEntityForName:@&quot;Chroes&quot; inManagedObjectContext:moc]; return chroeMO; }进行数据交互时候的步骤： -(void)updateLogList{ //create NSManagedObjectContext NSManagedObjectContext *moc = self.appDelegate.managedObjectContext; //create the request NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;ChroeLog&quot;]; NSError *error = nil; //sent the request NSArray *result = [moc executeFetchRequest:request error:&amp;amp;error]; if(!result){ NSLog(@&quot;Error fetching Person objects %@\\n%@&quot;,[error localizedDescription], [error userInfo]); } NSMutableString *buffer = [NSMutableString stringWithString:@&quot;&quot;]; for (ChroelogMO *c in result) { [buffer appendFormat:@&quot;%@ at%@ %@\\n&quot;,c.person_who_did_it,c.when,c.chore_done,nil]; } self.persistedData.text = buffer;}有写操作的时候，完成后要保存。 - (IBAction)deleteTaped:(id)sender { NSManagedObjectContext *moc = self.appDelegate.managedObjectContext; NSFetchRequest *request = [NSFetchRequest fetchRequestWithEntityName:@&quot;ChroeLog&quot;]; NSError *error = nil; NSArray *result = [moc executeFetchRequest:request error:&amp;amp;error]; if(!result){ NSLog(@&quot;Error fetching Person objects %@\\n%@&quot;,[error localizedDescription], [error userInfo]); } for (ChroelogMO *c in result) { [moc deleteObject:c]; } //save after changed [self.appDelegate saveContext]; [self updateLogList];}" }, { "title": "ios-summary-point", "url": "/posts/ios-summary-point/", "categories": "Learning", "tags": "IOS, Summary", "date": "2015-12-28 19:52:00 +0800", "snippet": "注意：you should alloc init the object， the property just define the pointer，the actual object you should alloc and initwhy the UI element not needed？because the UI element init when rendering the storyboardthe difference about ViewDidLoad and viewDidAppear:the autolayout result can be done in view did appear. 在didload中的view的大小还没有计算出来？在didapper中已经计算出来了。（1）字体的问题：change hex color to UIcolor：hex color to UIColor（2）render view的问题" }, { "title": "ios-alert-share", "url": "/posts/ios-alert-share/", "categories": "Learning", "tags": "IOS", "date": "2015-12-25 20:09:00 +0800", "snippet": "IOS-Summary-Alert-Activiy-Share-web-API-week2Create an Alert Action In IOS first you should create an AlertController Create an Action Add the Action to the AlertController present the Controller to the view.```objectivec-(void)showAlertMessage:(NSString *) myMessage{ UIAlertController *signInActionController = [UIAlertController alertControllerWithTitle:@”” message:myMessage preferredStyle:UIAlertControllerStyleAlert]; //Create an AlertViewController firstUIAlertAction *canle = [UIAlertAction actionWithTitle:@&quot;okay&quot; style:UIAlertActionStyleDefault handler:nil]; //Create an Action then[signInActionController addAction:canle];//Add the Action[self presentViewController:signInActionController animated:YES completion:nil]; //present that action in the view. }## Make the Activity Share(IOS自带的share集合和工具)```objectivec UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:@[self.activityTextField.text] applicationActivities:nil]; [self presentViewController:activityVC animated:YES completion:nil];// based on the acitivityitems type to decide which app to share, if I change to self.actitivyTextField. it is an object so no app can accept that share!//根据items的类型来确定能share给的app单一分享： UIAlertAction *tweet = [UIAlertAction actionWithTitle:@&quot;Tweet&quot; style:UIAlertActionStyleDefault handler: ^(UIAlertAction *action){ //first check whether logged in? if ([SLComposeViewController isAvailableForServiceType:SLServiceTypeSinaWeibo]) { SLComposeViewController *twitterVC = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeSinaWeibo]; //then create the viewController if ([self.textField.text length] &amp;lt;140) { //add the text to share [twitterVC setInitialText:self.textField.text]; }else{ NSString *shortText = [self.textField.text substringToIndex:140]; [twitterVC setInitialText:shortText]; } // present the view [self presentViewController:twitterVC animated:YES completion:nil]; }else{ [self showAlertMessage:@&quot;Please Sign in your Twitter&quot;]; } }];IOS-SDK自带了四种Social的平台。同样是4步：see the commentsSocial Sharing —OAuth2 import the NXOAuth2Client from Cocopods: 首先initAccountStore： request Access web redirect to the custom URL app handle the URL//init the accountstore[[NXOAuth2AccountStore sharedStore] setClientID:@&quot;61c99c80e0324c7992e87aa575ce582e&quot; secret:@&quot;93f0359abc3c4c119780c027d0b1d447&quot; authorizationURL:[NSURL URLWithString:@&quot;https://api.instagram.com/oauth/authorize&quot;] tokenURL:[NSURL URLWithString:@&quot;https://api.instagram.com/oauth/access_token&quot;] redirectURL:[NSURL URLWithString:@&quot;grammyplus://things.com&quot;] forAccountType:@&quot;Instagram&quot;];// this is the callback function for redirect url,web give the custom url for app step4 and this function is defined in the AppDelegate.m-(BOOL)application:(UIApplication *)application openURL:(nonnull NSURL *)url options:(nonnull NSDictionary&amp;lt;NSString *,id&amp;gt; *)options{ NSLog(@&quot;we recieved the login callback&quot;); return [[NXOAuth2AccountStore sharedStore] handleRedirectURL:url];}##How to make an request://fisrt compose the URL NSString *imgUrlStr = pkg[@&quot;data&quot;][0][@&quot;images&quot;][@&quot;standard_resolution&quot;][@&quot;url&quot;]; NSURL *imgUrl= [NSURL URLWithString:imgUrlStr];//set the request. note function is://[[session dataTaskwithURL:completeHandler:^(){}] resume] the handler is an block function! [[session dataTaskWithURL:imgUrl completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) { if (error) { NSLog(@&quot;Error: net request error&quot;); return ; } //error2 NSHTTPURLResponse *serverResonse = (NSHTTPURLResponse *)response; if(serverResonse.statusCode &amp;lt;200 || serverResonse.statusCode &amp;gt;= 300){ NSLog(@&quot;HTTP Error&quot;); return; } //取得绘制UI的主线程进行绘制 dispatch_async(dispatch_get_main_queue(), ^{ self.ImageView.image = [UIImage imageWithData:data]; }); }]resume];" }, { "title": "IOS-Development-Summary", "url": "/posts/ios-development-summary/", "categories": "Learning", "tags": "IOS", "date": "2015-12-15 21:44:00 +0800", "snippet": "1 you should alloc init when using the object in OC,even when you are using the property. e.g:@property(nonatomic) BSRecord *record;you define the property in the viewController h file.the record do exist when you init the viewController but it just an point which is point the record instance, so you should alloc init the instance when you using it. like:self.record = [[BSRecord alloc] init];otherwise you just all the point the actual instance doesn’t exist.2, Using the datasource which is an delegate the create the TableView.In IOS development, MVC pattern are using to create the app. so when create the tableview, there is two parts to consider,first is the tableview and second is the tableview controller, because the delegate pattern. after the tableview loaded to ask its delegator:viewController for the data. so in this case,you should implement these methods in the tableview controller to get the data for view, there are two methods to implement:- (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return 1;}// num of section in table view tell how many sections in the table view- (NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section {#warning Incomplete implementation, return the number of rows return [self.allRecords count];}// how many rows in the one section- (UITableViewCell *)tableView:(UITableView *)tableView cellForRowAtIndexPath:(NSIndexPath *)indexPath { UITableViewCell *cell = [tableView dequeueReusableCellWithIdentifier:@&quot;RecordsPrototypeCell&quot; forIndexPath:indexPath]; return cell;}// implement each cell,if you using the prototype you should define the identifier in attribute of the cell.3,Define the unwind segue to get to the previous view,To create an unwind segue you should add the action method to the destination view controller(the view controller you would to go):-(IBAction)unwindToList:(UIStoryboardSegue*)segue;take the UIStoryboardSegue as the parameter;you can link the button to the exit and choose the defined the segue. P94 in the book start developing iOS today.using the segue to go to another view.4, Saving and Loading data to the file- (NSString *)documentsDirectory{ NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES); NSString *documentsDirectory = [paths firstObject]; return documentsDirectory;}// get the directory of the document- (NSString *)dataFilePath{ return [[self documentsDirectory] stringByAppendingPathComponent:@&quot;bsrecords.plist&quot;];}// get the date file path- (void)saveRecords{ NSMutableData *data = [[NSMutableData alloc] init]; NSKeyedArchiver *archiver=[[NSKeyedArchiver alloc] initForWritingWithMutableData:data]; [archiver encodeObject:self.allRecords forKey:@&quot;Records&quot;]; [archiver finishEncoding]; [data writeToFile:[self dataFilePath] atomically:YES];}// create to the file;- (void)loadRecords{ NSString *path = [self dataFilePath]; if([[NSFileManager defaultManager] fileExistsAtPath:path]){ NSData *data = [[NSData alloc] initWithContentsOfFile:path]; NSKeyedUnarchiver *unarchiver = [[NSKeyedUnarchiver alloc] initForReadingWithData:data]; self.allRecords = [unarchiver decodeObjectForKey:@&quot;Records&quot;]; [unarchiver finishDecoding]; }else{ self.allRecords = [[NSMutableArray alloc] initWithCapacity:10]; }}// load from the file.Meanwhile you define the encode and second method or the object:@interface BSRecord : NSObject&amp;lt;NSCoding&amp;gt;- (id)initWithCoder:(NSCoder *)aDecoder{ if ((self = [super init])) { self.recordDate = [aDecoder decodeObjectForKey:@&quot;BSDate&quot;]; self.recordValue = [aDecoder decodeObjectForKey:@&quot;BSValue&quot;]; } return self;}// define the init method the decode the object- (void)encodeWithCoder:(NSCoder *)aCoder{ [aCoder encodeObject:self.recordDate forKey:@&quot;BSDate&quot;]; [aCoder encodeObject:self.recordValue forKey:@&quot;BSValue&quot;];}// define the encode method to encode the object!!! implement to the view controller ’s initWithCoder method to let the view controller to get the data from file:- (id)initWithCoder:(NSCoder *)aDecoder{ if ((self=[super initWithCoder:aDecoder])) { [self loadRecords]; } return self;}initWithCoder, for view controllers that are automatically loaded from a storyboardFor refer: p124 in the IOS_apprentice_2_checklit.Create an Alert Action in IOS: -(void)showAlertMessage:(NSString *) myMessage{ UIAlertController *signInActionController = [UIAlertController alertControllerWithTitle:@&quot;&quot; message:myMessage preferredStyle:UIAlertControllerStyleAlert]; Create an AlertViewController first UIAlertAction *canle = [UIAlertAction actionWithTitle:@&quot;okay&quot; style:UIAlertActionStyleDefault handler:nil]; //Create an Action then [signInActionController addAction:canle]; //Add the Action [self presentViewController:signInActionController animated:YES completion:nil]; //present that action in the view. } Make the Activity Share UIActivityViewController *activityVC = [[UIActivityViewController alloc] initWithActivityItems:@[self.activityTextField.text] applicationActivities:nil]; [self presentViewController:activityVC animated:YES completion:nil]; // based on the acitivityitems type to decide which app to share, if I change to self.actitivyTextField. it is an object so no app can accept that share! //根据items的类型来确定能share给的app" }, { "title": "[译]理解和掌握JavaScript中的this", "url": "/posts/js-this/", "categories": "Learning", "tags": "前端", "date": "2015-10-26 06:00:00 +0800", "snippet": "西安天凉了，冬天要来了。最近在看javascript的书，之前没用系统的看过js方面的书，虽然也看了网上的不少教程，也一直在用，但是总没有体系的感觉，所以最近在补这方面的课程，下面就是看到的一篇关于this的文章，觉得讲的不错，翻译过来。JavaScript中的this的keyword对于很多初学者，甚至是有经验的js开发人员来说，有时候会难以理解。这篇文章的目的就是解决这个问题，阅读完之后，妈妈再也不用担心我理解不了this了:) 这篇文章会讨论到this应用中的各种情况。编程语言是人与机器的交流语言，使其它的设计就是参考了我们人类的自然语言。this的使用与自然语言中代词（pronouns）的使用是类似的。但我们写下 John is running fast he is trying to catch the train。注意这里的人称代词 he的使用，当然上边的那句话我们也可以写成这样：John is running fast John is trying to catch the train.当然了，在现实中你并不会这么说，你的朋友会笑死你的。在Javascript中，我们使用this作为一个对象的简称，一个引用。来看下边的例子。var person = { firstName: &quot;Penelope&quot;, lastName: &quot;Barrymore&quot;, fullName: function () { ​// 注意这里的this就类似上个例子中的he:​ console.log(this.firstName + &quot; &quot; + this.lastName); ​// 同样可以写成这样:​​ console.log(person.firstName + &quot; &quot; + person.lastName); }}如果在上边的例子里用person.firstName 和person.lastName，我们的代码就变得有歧义了。如果有另外一个全局变量叫person。那么例子中的person.firstName会可能访问到那个全局变量中的属性。这将会导致你的程序难以调试。所以使用this关键字不仅仅是为了美观，同时也是为了准确。就像在自然语言中我们使用代词让句子变得更加的清晰和简洁。(在上文的例子中，使用he代表的就是前文的那个john，并不是其他的John)。就是代词he是用来指代前文的人称。this也是用于指向绑定函数中的一个对象。类似于人称代词，this可以认为是一个对象在相应的上下文（词法环境）中的简称。##Javascript中this关键字的基本用法首先，javascript中的所有的函数都有属性，就像对象一样。但一个function被执行的时候，它就会得到它的this属性——一个变量用于保存这个function被调用的环境。this总是指向一个对象，并经常在一个函数或者方法中进行使用，虽然它可以在函数外，在全局作用域中使用。注意在严格模式下，this在全局函数中的值为undefined，在匿名函数中不指向任何的对象。当this在函数中使用时（例如函数A）它包含了调用函数A的环境对象。我们需要this去获取调用函数A的那个对象的方法和属性。特别是，我们并不是总是知道调用函数A的那个对象的名字，有时候也可能是没有那个名字。所以this就是作为调用对象的一个简称。看下边的例子来说明javascript中this的使用。var person = { firstName :&quot;Penelope&quot;, lastName :&quot;Barrymore&quot;, //由于this关键字是在showFullName方法中使用，同时showFullName方法在person对象中定义，this代表了person对象，因为person对象调用的showFullName方法。 invoke showFullName ()​ showFullName:function () { console.log (this.firstName + &quot; &quot; + this.lastName); }​} person.showFullName (); // Penelope Barrymore再看一个jQuery中的this的例子。 $ (&quot;button&quot;).click (function (event) { // $(this) will have the value of the button ($(&quot;button&quot;)) object​​// because the button object invokes the click () method​ //$(this)代表的是($(&quot;button&quot;))那个button的对象，因为button对象调用的click()方法。 console.log ($ (this).prop (&quot;name&quot;)); });对于这个jQuery的例子展开来讲讲。$(this)，jQuery中对this关键字的表示，在一个匿名函数中被使用，这个匿名函数在button的click方法中进行执行。$(this)绑定到button对象的原因是因为JQuery将$(this)绑定到了调用click方法的那个对象上。所以$(this)会取到jQuery button($(‘button’))对象的值，即便$(this)是定义在一个匿名函数中，其自身是无法获取到外层函数的this值的。##Javascript this关键字的核心是神马？JavaScript中this关键字的核心是：this是值是不确定的，只有当一个对象调用包含this定义的那个函数时，this的值才确定，我们称那个函数为this函数。虽然this看上去是指向包含其定义的那个对象，但是只有当this Function被调用的时候才能确定this的值。然而由于JavaScript的设计缺陷，this并不一定指向包含其定义的那个对象。后文会介绍这样的情况。##全局作用域下的this的使用在全局作用域下，当代码在浏览器中运行的时候，所有的全局对象和函数后定义在window对象上。所以在一个全局函数时，this会指向全局的window对象（在严格模式下，并非如此。）下面是一个例子： var firstName = &quot;Peter&quot;, lastName = &quot;Ally&quot;;​ function showFullName () { //这个函数中this指向是window object因为shouwFullName()是定义在全局作用域上，就像firstName 和lastName一样 console.log (this.firstName + &quot; &quot; + this.lastName); }​ var person = { firstName :&quot;Penelope&quot;, lastName :&quot;Barrymore&quot;, showFullName:function () { //这里的this是指向 person 对象,因为 showFullName函数会被 person 对象所调用。 console.log (this.firstName + &quot; &quot; + this.lastName); } }​ showFullName (); // Peter Ally​​ // 所有的全局对象和函数都是定义在window对象下, 因此:​ window.showFullName (); // Peter Ally​​ //定义在person 对象上的showFullname()方法中的this会指向person对象，因此： person.showFullName (); // Penelope Barrymore##this中的坑this关键字在下边的情况下会有坑，在使用的时候，要注意一下。当我们借用了一个函数其中定义了this，当在回调函数中使用this的时候，当this在闭包时使用时，this在回调函数的时候。下边会对于这些情况一一分析，并给出解决方法。在继续之前，我们来看一点Context（上下文）的概念。JavaScript中的上下文与自然语言中的主语类似。”John is the winner who return the money” 这句话的的主语是John，那我可以说这句话的上下文是John，因为在这句话的整个的关注点在John上，所以who这个代词都是代表的John。同样就如同我们可以使用分号来切换句子的主语一样，我们可以通过用另外一个对象来调用一个函数来切换一个对象的现在的上下文环境（这句话翻译的确实有些问题，大家可以看原文。）来，还是看例子吧。var person = { firstName :&quot;Penelope&quot;, lastName :&quot;Barrymore&quot;, showFullName:function () {​// The &quot;context&quot;​console.log (this.firstName + &quot; &quot; + this.lastName); }}// 当调用 showFUllname的时候，由于我们调用的是 person对象上的shownFullName方法。上下文是person对象// 在showFullName方法中的this就指向了person对象。person.showFullName (); // Penelope Barrymore​​​// If we invoke showFullName with a different object:​​var anotherPerson = {firstName :&quot;Rohit&quot;,lastName :&quot;Khan&quot;​};​//通过使用apply方法,this方法获得是调用的对象，因此：//通过使用apply方法，现在 上下文是 anotherPerson，因为是anotherPerson调用了 showFullName的方法。person.showFullName.apply (anotherPerson); // Rohit Khan​​下面继续进入this关键字的坑阶段.###this在回调函数中的问题和解决当this是在回调函数中进行使用的时候，事情就变的有些奇怪了，看如下例子： //如下是一个简单的对象，他上边有个clickhandler方法，当我们点击一个button的时候，这个方法会被调用。var user = { data:[ {name:&quot;T. Woods&quot;, age:37}, {name:&quot;P. Mickelson&quot;, age:43} ], clickHandler:function (event) { var randomNum = ((Math.random () * 2 | 0) + 1) - 1; // random number between 0 and 1​​ //打印一个在data数组中随机一个人的名字和年龄。 console.log (this.data[randomNum].name + &quot; &quot; + this.data[randomNum].age); } } //button是一个jquery对象吗，但是output是undefined因为在button对象上并没有data属相。 $ (&quot;button&quot;).click (user.clickHandler); // Cannot read property &#39;0&#39; of undefined在上文的例子中，由于button是一个对象，并且我们将user.clickhandler方法作为它click事件的回调函数中，在user.clickHandler方法中定义的this不在指向user对象。它会指向user.clickHandler执行时的那个对象，因为this是定义在user.clickhandler中的。由于调用user.click方法的是button对象，user.clickHandler会在button对象的click方法的中被执行。注意到一个点，是即使是我们使用了user.clickHanedlerhandler来调用这个方法（也没有其他什么方法能调用），clickHandler的方法的执行上下文是button对象，所以this现在是指向的button对象。在这里，我们可以注意到，当执行的上下文变化以后，我们执行了某些方法在其他的对象上而不是其本身定义时的那个对象上，this关键字就不指向原先的对象，而是指向调用这些方法的那个对象。如何解决能，其实方法也是很简单。我们可以使用bind(),apply(),call()等方法来确定this的值。为了解决上边的问题，进行如下的一些改变： $(&quot;button&quot;).click (user.clickHandler.bind (user));###闭包中的this问题另外一个使用this的问题是闭包中的问题。有一点很重要的需要说明的是闭包不能获取外层函数的this变量，这是因为this关键字只能被自己访问，不能被内层函数访问。可以看以下的例子：var user = { tournament:&quot;The Masters&quot;, data :[ {name:&quot;T. Woods&quot;, age:37}, {name:&quot;P. Mickelson&quot;, age:43} ],​ clickHandler:function () {​ //这里使用this.data是可以的，因为this指向user对象，并且data是user对象的一个属性。 this.data.forEach (function (person) { //但是匿名函数中的this就不是指向的user object了，因为内层函数的不是无法获得外层函数的this console.log (&quot;What is This referring to? &quot; + this); //[object Window]​ console.log (person.name + &quot; is playing at &quot; + this.tournament); // T. Woods is playing at undefined​ // P. Mickelson is playing at undefined​ }) }​ }​ user.clickHandler(); // What is &quot;this&quot; referring to? [object Window]在匿名函数内的this不能获取到外部函数的this，所以在非严格模式下，他被绑定到了window对象上。如何解决呢？答案很简单把外部函数的this赋给另外的一个变量。看例子：var user = { tournament:&quot;The Masters&quot;, data :[ {name:&quot;T. Woods&quot;, age:37}, {name:&quot;P. Mickelson&quot;, age:43} ],​ clickHandler:function (event) { //在这里我们将this赋给另外的一个变量，以便我们后边使用。 var theUserObj = this; this.data.forEach (function (person) { // Instead of using this.tournament, we now use theUserObj.tournament​ console.log (person.name + &quot; is playing at &quot; + theUserObj.tournament); }) }​ }​ user.clickHandler(); // T. Woods is playing at The Masters​ // P. Mickelson is playing at The Masters###this方法被赋给一个变量当我们将一个使用了this的方法覆了一个变量的时候，this的值会变的与我们预想的不同。 // 这里的data是一个全局变量 var data = [ {name:&quot;Samantha&quot;, age:12}, {name:&quot;Alexis&quot;, age:14} ];​ var user = { // 这里的data是user对象的一个属性 data :[ {name:&quot;T. Woods&quot;, age:37}, {name:&quot;P. Mickelson&quot;, age:43} ], showData:function (event) { var randomNum = ((Math.random () * 2 | 0) + 1) - 1; // random number between 0 and 1​​ // This line is adding a random person from the data array to the text field​ console.log (this.data[randomNum].name + &quot; &quot; + this.data[randomNum].age); }​ }​ // 将 user.showData赋给一个变量 var showUserData = user.showData;​ // 当执行showUserData函数的时候，this指向了全局的data数组，而不是user上定义的data数组。 //​ showUserData (); // Samantha 12 (from the global data array)​如何解决呢，也很简单，使用bind方法 var showUserData = user.showData.bind (user);###借用方法中的this借用方法是JavaScript中的常见的实践方法，我们经常在实际的使用中应用这种方法。还是用一个看看在借用方法中this的问题。 //这里有两个对象，一个里边有 avg()方法，另外一个没有，我们会借用这个 avg()方法。var gameController = { scores :[20, 34, 55, 46, 77], avgScore:null, players :[ {name:&quot;Tommy&quot;, playerID:987, age:23}, {name:&quot;Pau&quot;, playerID:87, age:33} ] }​ var appController = { scores :[900, 845, 809, 950], avgScore:null, avg :function () {​ var sumOfScores = this.scores.reduce (function (prev, cur, index, array) { return prev + cur; });​ this.avgScore = sumOfScores / this.scores.length; } } //如果执行以下的代码 gameController.avgScore的属性会被设置成为appController对象的scores数组的平均值。 gameController.avgScore = appController.avg();avg方法中的this关键字会不会指向gameController对象，它会只指向appController对象的，因为是appController对象啊调用了这个函数。如何解决呢？为解决这个问题我们要确定appController.avg()方法指向gameController，我们可以使用apply()方法： //利用apply方法将this指向了gameContrller对象，同时将gameController.scores作为参数传入。 appController.avg.apply (gameController, gameController.scores);​ //我们借用了appController对象上的avg()方法，并将gameController的avgScore设置成功了。 console.log (gameController.avgScore); // 46.4​​ //注意appController的avgSocre还是null console.log (appController.avgScore); // nullgameController借用了appController的avg()的方法，appController中的avg()方法中this会被指向到gameController中，因为我们使用了apply()方法，apply方法会根据参数准确的制定this的值。##结束语希望这篇文章可以帮助大家能够很多的理解JavaScript中的this关键字，以及this中各个坑和解决方法。原文" }, { "title": "Ionic 项目总结与分享", "url": "/posts/project-summary-01/", "categories": "Building", "tags": "前端, Summary", "date": "2015-08-13 06:00:00 +0800", "snippet": "IONIC 是较为红火的mobile app 开发框架，所以花了点时间研究了一下，一下就是对于具体实施的一些项目中的总结和分享。app的设计思想与web不同的是，在app中的设计的思想是要注意数据的cache的，从本质上来讲，app就是原来的desktop上的软件，但是在目前的情况下，所有的app基本上都是有网络请求的，实际上的产品结构师CS的。所以app是client端，那么有client端就一定有数据的本地存储，在app上一般是使用sqlite的方式去进行存储的。所以下边就简单说下如何在ionic中引入sqlite的plugin。参考文章首先引入cordova 的plugin，然后引入ngcordova，将ngcordova注入到ionic的angular里，在初始化app的时候create table，然后可以使用cordova的其他方法来进行数据的处理。this part will be described latervideogular的使用在github上900多star的videogular被引入到项目中来，还是在继续的看源码，写到不错。fullscreen的支持使用了cordova的fullscreen的插件进行使用。在为让用户在点击全屏的时候，自动横屏全屏，修改了videogular的源码，但是目前ios上有些问题，andriod上可以。ios不能inline play，在点击播放的时候会调用native player。this issue should be more investigate。share to wechat使用了github上 xu.li.cordova.wechat的plugin。了解到了一些基本的东西，在ios apple上的app id 就是 bundle id 可以唯一标示一个app，但在android上就需要包名，以及签名来标示，在ionic上包名在config.xml中&amp;lt;widget id=&quot;com.ionicframework.badyapp960848&quot; version=&quot;0.0.1&quot; xmlns=&quot;http://www.w3.org/ns/widgets&quot; xmlns:cdv=&quot;http://cordova.apache.org/ns/1.0&quot;&amp;gt;参考文档第一步 build –release第二步 生成 keystore第三步 签名第四部 优化 apk这就是第一周的项目总结。后边一周总结一下。" }, { "title": "CSStricks Time-让video响应式原理分析", "url": "/posts/CSS-tricks-video-explain/", "categories": "Learning", "tags": "前端", "date": "2015-08-03 18:15:00 +0800", "snippet": "上一篇分享到了如何让video可以做的响应式，那么今天我们具体来分析一下到底是如何做到的。首先现在的目前的video都是有固定的比例的，一如4:3，一如16:9。无论我们如何缩放，我们也要保证这个比例是不会变化的。所以这是视频缩放的前提。首先给介绍一个css tricks 那就是padding property，padding property 可以让一个box有一个固定的比例。这既是当我们将padding设为%以后那么它基于他的container的width大小计算的。有了这个trciks我们就可以用他来建一个固定比例的box了。来看代码：&amp;lt;div class=&quot;video-container&quot;&amp;gt; &amp;lt;div class=&quot;element-to-strech&quot;&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;.video-container{ position: relative; padding-bottom: 20%; height: 0;}.element-to-strech{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: green;}来让看下这个css片段。在.video-container中设置了，postion：relative目的是为子元素定位提供一个位置定位。padding-bottom设置为20%，这样就创建了一个比例为5:1的box。在其子元素中设为postion：absolute，这样就可以让子元素可以突破container的height的限制。那就这个元素就可以被定位在父元素的padding区域里了。后边的就好理解了，top，left定位位置，width，height让与container同宽高。这样我们就创建好了一个固定5:1可缩放的container。下面让我们看下一个真实的例子：在上边的说明的例子我们container与body同宽的，那么在实际应用的时候，我们经常是有一个区域来展示video的所以我们有个warpper将上述的container包裹起来。我们看如下的例子：&amp;lt;div class=&quot;warpper&quot;&amp;gt; &amp;lt;div class=&quot;video-container&quot;&amp;gt; &amp;lt;iframe src=&quot;&quot; frameborder=&quot;0&quot;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;/div&amp;gt;&amp;lt;/div&amp;gt;.warpper{ width:50%;}.video-container{ position: relative; padding-bottom: 56.25%; height: 0;}.vidoe-container iframe{ position: absolute; top: 0; left: 0; width: 100%; height: 100%; background-color: green;}与上面的例子相比，我们加了一warpper控制video的width。其他的都是类似的。pading-bottom的为56.25%这是将比例设定在16:9。如果我们将比例控制在4:3则，padding-bottom为75%。以上就是对于响应式video的分析，css中并没有考虑IE5,6,7等奇葩浏览器。这里我看到的更全的连接，给大家参考。链接" }, { "title": "CSStricks Time-如何让你的video响应式", "url": "/posts/CSS-tricks-video/", "categories": "Learning", "tags": "前端", "date": "2015-07-31 00:15:00 +0800", "snippet": "做前端的同学不知道对于CSS感觉怎么样，反正我的感觉是挺酸爽的。尤其是mobile first后，一个页面要适应多种客户端。虽然已经有想bootstrap.fundation之类的东西可以帮助我们，但是在一些时候要做到响应式还是挺麻烦的事情，有时候还有一些tricks的东西。最近在玩一些东西的时候，发现了一些，记录在这里。当我们在web page里要嵌入一个video的时候，如何做到让他能做到响应式呢，当页面的窗口大小变化的时候，video的大小也会发生相应的变化。如何做到呢？分以下的几种情况：当使用video tag的时候最简单的方法是使用以下的CSS:video{ max-width:100%; height:auto;}如此的简单暴力，直接设置了max-width，以及height就ok了。当时这种方式有个问题，就是当使用iframe或者object tag的时候，这样的方法就是不行了。因为当嵌入很多视频网站的video的时候，上述方法就不行了。那如何解决这样的问题呢？其实也是很简单的。就是将iframe 或者 object tag 用一个div标签包起来。设置这个div的padding-bottom为50% - 60%，postion 为relative。然后将iframe or tag 标签的width 和height标签设为100%，postion设为 absolute。这就迫使iframe or object 标签占据div的全尺寸。上代码：CSS:.video-container{ postion:relative; padding-top:30px; padding-bottom:56%; height:0; overflow:hidden;}.vide-container iframe,.vide-container object,.vide-container embeded{ postion:absolute; top:0; left:0; width:100%; height:100%;}html: &amp;lt;div class=&quot;video-container&quot;&amp;gt; &amp;lt;iframe src=&quot;http://player.vimeo.com/video/6284199?title=0&amp;amp;byline=0&amp;amp;portrait=0&quot; width=&quot;800&quot; height=&quot;450&quot; frameborder=&quot;0&quot;&amp;gt;&amp;lt;/iframe&amp;gt; &amp;lt;/iframe&amp;gt; &amp;lt;/div&amp;gt;我是看到这篇文章的发现这些tricks的。大家可以参考一下。" }, { "title": "开放的技术才有未来", "url": "/posts/talk1/", "categories": "Thinking", "tags": "前端", "date": "2015-03-23 19:15:00 +0800", "snippet": "大家好，好久时间没有更新了，大家也许会问，图表君干嘛去了，是不是不打算做了呢？当然不是了，图表君最近很忙，参与了一个高大上的项目，看过以前文章的同学可能知道了，对就是防治大气污染的一个项目中。也算是为了我国的环保行业做出一点贡献了吧。说起这个项目，具体的细节，这里就不多介绍了。图表君在这里主要是负责数据可视化方面的工作，简单说就是做图的，用得技术当然是前文介绍的RAVE了。以后有机会给大家分享下具体的图表的典型的例子，今天就不多说细节了。说说关于数据可视化技术的一些感悟吧，还有一些其他方面的思考。与其他的数据可视化技术相比，RAVE的设计思想是比较独特的，定义了一种对于图形的描述语言来描述图形，提供各个平台的解释引擎来渲染图形。这与其他的图形引擎相比，是比较独特的。现在流行的数据可视化引擎例如，D3，HightChart 都是Javascript的类库，在web端能够得到很好的展示，但是在desktop application，native app 上的支持上就要多花一些功夫了。当然了在数据分析界例如Python，R 他们各自的图形引擎系统，与传统的图库的概念类似（Excel 也有统计图形哦，其实也是一种数据可视化的方案）这里不一一介绍了。仅仅从这一点上看，RAVE的跨平台性要相对的好一点。但是同时由于这样的语言描述图形的特点，带来的问题是如果想要有更强的定制性，那么如果所定义的语法中无法支持，那么就彻底的没着了。但是D3之类的JS库的定制性能就更好，可以这么说只要了解JavaScript语言，看一下D3的手册，它的定制性会更高，实现的效果会更好。所以图表君觉得RAVE的定位似乎是在传统的图形引擎和完全可定制化的类库之间。相比于传统的引擎灵活性有所增加，但是不需要你对于Web前段的知识，有很多的了解。当然对于程序猿来说，图表君觉得还是D3来爽，随心所欲，我想让他怎么表现就怎么表现。所以图表君以后也会写一些D3的系列文章出来分享给大家。说了这么多，扯一扯其他的东西吧，为什们D3的东西会那么火，因为它是Open Source的。图表君一直认为开放的技术，才有未来。现实的例子比比皆是，看看这个星球上最伟大的开源项目-Linux，无数的天才为了它贡献代码，世界上大部分的服务器都运行着Linux的OS。所以开放得技术才有未来，看看github上各种欢乐的项目吧，闭门造车造不出什么好东西的，在牛B的设计，不开放没人用，最终会被历史所淘汰。技术如此，事也亦然。好了，胡言乱语了这么多。对于数据，图表君也是相当有兴趣，以后也会更多的介绍数据分析方面的知识，给大家。去年在Coursera上完成了Andrew Ng 的Machine Learning，也需要做些总结和复习，也会放到这里分享给大家，大家如果看兴趣可以去上上那个课，真心的不错。" }, { "title": "RAVE中的自定义axis的方法", "url": "/posts/RAVE6/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-03-17 19:15:00 +0800", "snippet": "在图表中往往有很纠结的地方，比如我们既想方便的做出一个图形，同时也想让图形具有很强的灵活性。所以要满足这样的需求也是挺难的。打个比方说在以往的图库的图形引擎中要更改一个自定义一些图，确实也是很挺困难的。但是RAVE提供的VizJSon的语法描述语言，所以它的灵活性就有相应的提升，那么如何表现呢？下面就是个很好的例子。在现实的需求中我们往往需要自定义一些轴上的信息，但是在data里又不方便直接的对于这样的信息进行定义，所以就存在了一个转化的问题。那么如何进行转换呢？以下就是一个很好的事件例子。在VizJson Reference Doc 中对于axis的描述中有这样的一段：tickLabelType: contentDefines the formatting for the axis tick label.The label will be constructed by appending these parts together. References to fields will be translated to the name of the field. This content array is similar to axis title or element label. The only different is that it will have a placeholder to insert the tick actual value. This placeholder is an entity with an argument and value such as{&quot;args&quot;: &quot;tick&quot;}For example if the attribute is defined as follows:&quot;tickLabel&quot;: [&quot;Price: &quot;, {&quot;args&quot;: &quot;tick&quot;}]than a tick value of 1000 will become “Price: 1000” Images can be added to tick label by providing a image referance in content array. This is as described in content attribute of label. Different image for each category can be added by providing a field referance with method as image as shown below. This field will contain referance to image resources as categories.&quot;tickLabel&quot;: [ {&quot;$ref&quot;: &quot;imgField&quot;,&quot;method&quot;: &quot;image&quot;}, &quot; &quot;, {&quot;args&quot;: &quot;tick&quot;}]Note: For numeric scale the tick value may not exactly match the value of data field so image defined at nearest matching data row index is used for the tick.Tick label actual values can be styled by defining the style along with argument. Rules for specifying style are same as for any other content part as described in content attribute of label.For example:&quot;tickLabel&quot;: [ {&quot;args&quot;: &quot;tick&quot;}, &quot;style&quot;: { &quot;fill&quot;: &quot;blue&quot;, &quot;font&quot;: { &quot;size&quot;: 18, &quot;style&quot;: &quot;italic&quot;, &quot;weight&quot;: &quot;bold&quot; } }]大致的意思就是说tickLabel这个属性对于axis中的label提供一些自定义的方式。只要插入一个placeholder{“args”：“tick”}中就可以将原有的lable引入进来。在这样的表述中提到了三种方式: 在现有的label统一加一个前缀字段。实现的方法就是在这个array里加一个字符串[“Price: “, {“args”: “tick”}] 利用image加入到现有的label中。实现的方式是在这个array中加入对于image的引用[{“$ref”:”image”,”method”:”image”}, “ “,{“args”:”tick”}] 同样可以对于tickLabel 改变它的style，通过改变其style property来到达。这里是官方的文档的描述。那么问题来了，如果我的目的不是要引入image，而是要做一个mapping的变换该如何操作呢。具体来说就是要讲：1 - abc12 - abc23 - abc34 - abc45 - abc5这样一一对应的方式进行对应。该如何定义？？要达到这样的目的我们就可以参考VizJson的ticklael image的定义方法。假如新定义的categories 的名字叫 reallabel。那么我们就是可以这样的定义ticklabel。&quot;tickLabel&quot;: [ {&quot;$ref&quot;: &quot;reallabel&quot;,&quot;method&quot;: &quot;data&quot;}]这样就利用自定义的label代替了原有的label。下边写一个例子能更好的说明这个问题。还有一点即使在RAVE 5.0 以后才支持这个属性。思考题1：如果有缺项怎么呢办，意思是要显示的label不是和原始数据一一对应的，中间有空项？答案：在对应的data rows里补null 同时改变原始的tickstyle 为透明色。这是一点tricks。思考题2：如何创建有null项的图，有空点，不连续的图。答案：只要在对应项中补null就可以了，例如 [[1,2],[2,null],[3,8] …]" }, { "title": "今天，我们不说图，聊聊理想主义", "url": "/posts/CJ/", "categories": "Thinking", "tags": "生活", "date": "2015-02-28 19:15:00 +0800", "snippet": "开年第一篇，说实话不知道该写什么为好，RAVE第一季，已经完成。如果大家跟下来想必也已经可以使用RAVE制作出一张Bar Chart了吧。如果开年就直接开始第二季，想想也有些无趣和烦躁。那么我们今天聊聊什么？聊聊柴静的最新记录片《穹顶之下，我们共同呼吸》吧。如果你还没有看过，那图表君强烈建议你看一下，一个多小时的时间不长也不短，希望大家能耐心的看完。说说图表君的感受吧，生活在废都，天气却和帝都类似，现在一年能看到100多个蓝天已经是赚到了。回忆小时候天天能对着天空数星星的情形，现在仿佛是一种奢望了。以前总觉得废都冬天的天是灰蒙蒙的，原来以为是雾，现在想想那是霾啊。长大了看着有不少同学出国了，天天晒蓝天照，好是羡慕。年纪大了一点，看身边的同事，给自己的孩子海淘奶粉，尿布，奶瓶等等。今年又有新闻看到，日本的电饭锅，马桶圈卖疯了。有时候会想这个国家怎么了？内心有时候也想，算了，用脚投票吧，什么时候能肉身翻墙吧，去外边享受下自由的空气和蓝天。直到看了柴女神的这个新作。忽然明白？你真的能走的了吗？你可以肉身翻出去，你的父母呢，你的兄弟呢，你的朋友们呢？一样还是要在雾霾天生活，一样要吃着不安全的食品，所以你走不了，或者说无论你走到哪，你都是一个中国人，无法改变。所以我是一个中国人，我爱我的父母，我的爱人，我的孩子，我爱我的国家，为了能让我的孩子能看到蓝天，能喝上干净的水，我要做点什么。可是我是一个普通人，我能做点什么呢？我能做到，短距离不开车，使用公共交通。我能做到，节约水，节约电，少使用一点能源。我能做到，拒绝污染环境企业的产品。我能做到，拿起电话举报污染环境的现象。我是一个普通人，我能做的不多，但是做总比不做强。我无法扭转国家的能源现状，但是我可以说出我的声音，不做沉默的麻木人。图表君目前工作中正在参与一个环境保护的项目，以前没觉得什么特别，就是一个项目而已。但今天图表君觉得自己的工作能为了我们的家园的蓝天作出点贡献还是不错的，我骄傲！网络上有很多对于柴静的新作的评价，大家可以搜搜看看。很多人有各个角度的评价，技术上的，商业上，炒作啦，内幕啦，政治啦的等等。但图表君作为一个理想主义内核的青年，我选择相信柴静。新年到了，希望大家共勉，一起努力，希望我们的天能更蓝，希望我们这个命运多舛的老国家越来越好。PS：从互联网产品的角度，看柴静的这个作品真是棒，keynote的演示，字体，颜色。speaker的语音，语速，语调，一级棒。知乎上有更加详尽的讨论大家有兴趣可以去搜搜。另外图表君也在考虑在环境保护（空气污染方面）做一些有意思的project。如何有类似想法的小伙伴，欢迎和图表君联系。" }, { "title": "今天，我们完成这个栅格图-RAVE（5）", "url": "/posts/Rave5/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-02-18 22:15:00 +0800", "snippet": "今天是大年三十，图表君祝大家羊年大吉，新年快乐。今天我们完成这个栅格图,也是我们RAVE 第一季 的最后一篇文章。在上一篇文章中给大家介绍了如何用美化栅格图。这篇文章我们再为这个图形再增加点其他元素。添加两个轴的信息对于一个完整的图形来说一般是需要有，坐标轴来表示其中的信息的，在RAVE中如何来添加这些信息呢？其实如果看看我们之前的代码片段，已经有这样的定义了。&quot;coordinates&quot;: { &quot;dimensions&quot;: [ { &quot;axis&quot;: {} }, { &quot;axis&quot;: {} } ], &quot;style&quot;: { &quot;fill&quot;: &quot;white&quot; }}在上边的代码段落中就定义了图表的轴的信息，例如，它有两个axis也就是说有两个轴，只不过现在我们并没有定义轴上的样式，所以axis里是一个空的object。现在我们来做些修改。我们需要两个轴有title,y轴上的坐标为黑色，X轴的坐标为银色。下边呢，就是我们的实现代码段。 &quot;coordinates&quot;: { &quot;dimensions&quot;: [ { &quot;axis&quot;: { &quot;lineStyle&quot;: {&quot;fill&quot;: &quot;black&quot;}, &quot;markStyle&quot;: {&quot;fill&quot;: &quot;white&quot;}, &quot;title&quot;: [ &quot;Win Games&quot; ] } }, { &quot;axis&quot;: { &quot;lineStyle&quot;: {&quot;fill&quot;: &quot;sliver&quot;}, &quot;markStyle&quot;: {&quot;fill&quot;: &quot;white&quot;}, &quot;title&quot;: [ &quot;Teams&quot; ] } } ], &quot;style&quot;: {&quot;fill&quot;: &quot;gray&quot;} }在这里lineStyle属性定义了坐标轴的颜色，title属性定义的x,y两个轴的名字。来看看图是什么样的。##添加图例和名字，作为一张图一定要有自己的名字，并且一张完整的图，一定有合适的图例来表达自己。那么如何添加呢？下边就是 &quot;legends&quot;: [ {} ], &quot;titles&quot;: [ { &quot;type&quot;: &quot;title&quot;, &quot;content&quot;: [ &quot;English premier league Top 5 2012-2013&quot; ], &quot;style&quot;: { &quot;fill&quot;: &quot;black&quot; } } ],在这里我们将图例以及图的名字添加好了。titles属性是对图的名字的描述，在它的content里是title的内容，style定义了它的颜色。同样增加了legends属性来表示图例，这里我使用的是默认的配置。所以给个空的object就ok了。这里是这个栅格图的源码，提供给大家进行参考。源码感谢大家对于多彩数据的支持，图表君在这里给大家拜年了，祝大家羊年工作进步，身体健康，万事如意。图表君在新的一年里，会尽力把多彩数据做好，给大家分享更多的内容，也欢迎大家把好的文章分享给图表君，大家学习交流。" }, { "title": "来，给他点颜色看看-RAVE（4）", "url": "/posts/Rave4/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-02-09 19:15:00 +0800", "snippet": "上一篇文章中给大家介绍了如何用RAVE画出一个栅格图来，但那个样子的栅格图实在太丑了，图表君表示无法忍受，那么今天就让我们一起给它点颜色看看，美化美化这个图来，让它看起来更漂亮点。为了区分开各个对位，在栅格图中，我们将各个柱用不同的颜色进行区分来达到这样的效果。这个该怎么做呢，只要在element里边，对于interval的颜色属性进行修改就OK了。具体来说我们来看下面一段代码。“color”:[ { &quot;id&quot;:&quot;colorId&quot;, &quot;field&quot;:{ &quot;$ref&quot;:&quot;categories&quot; } &quot;palette&quot;:[ &quot;#1183ad&quot;, &quot;#39b2ac&quot;, &quot;#60942c&quot;, &quot;#d4a600&quot;, &quot;#d15c00&quot;, &quot;#b2293d&quot;, &quot;#532f8c&quot; ] }]在上边的代码段落，定义了颜色的属性，并将颜色与data中的categories相关联。这样就给不同的栅格赋予了不同的颜色，在palette里就定义了各种颜色，按照先后属性给各个栅格改变颜色。得到图形就回变成这个样子。这样看是不是还有有点奇怪，这些栅格不应该靠在一起啊，那好我们现在让他们分开点，这个就更简单了，只要在elements里加一个style的属性控制一下它的宽度就ok了。来看代码。“style”:{ &quot;width&quot;:&quot;80%&quot;}完成后的图形就是这个样子的。width就变为原来的80%了。是不是很简单。这里是这个栅格图的源码，提供给大家进行参考。源码好了，颜色我们上完了，这篇文章就先写到这里吧，下面文章我们对它继续美化，让这个栅格图看起来更好一点。" }, { "title": "来,我们来画一个栅格图-RAVE（3）", "url": "/posts/Rave3/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-02-07 19:15:00 +0800", "snippet": "相信如果读了上一篇文章的各位亲们，现在已经顺利的将RAVE的SDK环境搭建起来了吧。那么现在我们就是利用起来，画出一个栅格图出来。说是要画图，其实就是定义VizJSon 文件，定义好这个文件放到RAVE SDK中那么图就可以渲染出来了。说了这么久的VizJson，那它是由哪几部分组成的呢？其实很简单就是两部分，一个是Data，一个是Grammer。 Data里定义了想要展示的数据，Grammar，顾名思义语法，定义了图形的展示方式。比如现在我们要展示一个这样的数据，2011到2012赛季，英超比赛的前5名球队的获胜的比赛数。以下是这些数据。{“MCI”:29,”MUN”:29,”ARS”:22,”TOT”:20,”NEW”:19}RAVE的Data定义：对于上述的数据，包括球队以及赢球数这两种数据。球队数据属于categories类型的数据，大家可以理解为枚举类型。赢球数为数值类型的数据。那么在Data中奖这个两类数据进行定义，在rows里记录具体的数据值。&quot;data&quot;:[{ &quot;id&quot;:&quot;data&quot;, &quot;fields&quot;: [ { &quot;id&quot;:&quot;name&quot;, &quot;label&quot;:&quot;name&quot;, &quot;categories&quot;: [ &quot;MCI&quot;, &quot;MUN&quot;, &quot;ARS&quot;, &quot;TOT&quot;, &quot;NEW&quot; ] }, { &quot;id&quot;:&quot;wins&quot;, &quot;label&quot;:&quot;Game Wins&quot; } ], &quot;rows&quot;: [ [ 0,29], [1,29], [2,22], [3,20], [4,19] ]}],大家可以看到，我在data中定义出了这两种数据。并在rows里将所有的数据记录，记录了下来。那么data这一部分的数据就定义完成了。（可能有些看官看不太懂。因为VizJson的定义，利用的都是Json的数据格式，大家如果想深入研究，可以到w3school里先看下Json的数据格式，其实也不用太过纠结，一步步慢慢来好了。）在对data这部分定义完成以后，那下边我们就要进行grammer部分的定义了。在之前，先给大家简单的介绍一下RAVE的grammer。在RAVE中定义了一些基本类型来绘制图形，例如interval（条），point(点)，edge（边），polygon（多边形），line（线），area（区域）等等。那么对于栅格图来说，我们就可以使用interval来绘制。好了，那我们来看看具体的代码吧。&quot;grammar&quot;:[ { &quot;coordinates&quot;: { &quot;dimensions&quot;: [ { &quot;axis&quot;: { } }, { &quot;axis&quot;: { } } ], &quot;style&quot;: { &quot;fill&quot;:&quot;white&quot; } }, &quot;elements&quot;: [ { &quot;type&quot;:&quot;interval&quot;, &quot;position&quot;: [ { &quot;field&quot;: { &quot;$ref&quot;:&quot;name&quot; } }, { &quot;field&quot;: { &quot;$ref&quot;:&quot;wins&quot; } } ] } ] }],可以看到在element里，我用internal来绘制每一个栅格，他们的位置，又是用position这个属性所定义的，第一field定义了x轴的位置，第二个field定义了Y轴的位置。那么画出来的图是什么样子呢，请看下边：是不是有些丑呢，反正图表君觉的不漂亮，不要紧。下一篇，我们来美化美化它，give it some color to see see。好了，这篇就先讲这么多吧，感兴趣的同学，动起手来，简单的做一个栅格图吧。" }, { "title": "工欲善其事，必先利其器 - RAVE(2)", "url": "/posts/Rave2/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-02-05 19:15:00 +0800", "snippet": "这是RAVE系列文章的第二篇，你可以在微信公众号：多彩数据（微信号：Data_Visualization)后台回复”数据”查看此系列的其他文章。上文书咱们简单介绍了下RAVE的特点，从这篇文章开始我们就一步步的介绍RAVE的知识，先从环境搭建开始。第一步需要获得RAVE的SDK，这个可以从RAVE的官网：link 上下载 。当然了，要使用SDK得确保你的机器上正确安装了JAVA 1.6 以上的版本。（对于非程序员的看官，这一节应该是有些难度，对于这个问题，图表君有两个建议。第一，找个附近的程序猿，帮你安装一下。第二个方法是图表君后边会搭建一个在线平台帮助大家学习使用RAVE，当然这个还需要一些时间，哪位土豪朋友，能资助台服务器给图表君那就极好了。）当下载好了RAVE的SDK以后，进入Bin 目录，点击 visboard.bat(Windows 平台下,在linux or Mac 平台下，运行 visboard.sh)就可以启动 RAVE的SDK了，如下图所示。这就是RAVE的IDE的窗口了，Windows上的界面与这个稍有不同。将编辑好的vizJson输入在左边的输入框中，点击submit。那相应的图形就能再右边的窗口上显示出来了。是不是很简单？在 SDK的菜单栏中，选择file - open，选择SDK目录下的Scenes文件夹，再选择里边的gallery文件夹，在这个文件夹里边有很多已经写好的VizJson的文件，打开这些文件，在右边的图形框里我们就能看到对应的图形。下图我们看到的就是一个。来个入门例子配置好了RAVE的SDK，下边我们看一个简单的例子，来体会下RAVE的图形能力。在上文提到的gallery 文件夹中，找到SimpleScatter.Json这个文件，我们可以在右边的图形区看到这个一个。如果现在我想在这个图形上加一条线把所有的点都连接起来，该怎么做呢？在RAVE中，这个很简单，只要将线加上去就好了啊。现在我们来实现它，在左边的编辑区，找到element的代码段，在 “type: point”的大括号前边，加上这么一段： { &quot;type&quot;: &quot;line&quot;, &quot;position&quot;: [ {&quot;field&quot;: {&quot;$ref&quot;: &quot;m1&quot;}}, {&quot;field&quot;: {&quot;$ref&quot;: &quot;m2&quot;}} ] },点击 submit，是不是所有的点都被一条线连接起来了？这就RAVE的强大之处，简单地修改vizJson的定义文件，那么就能获得想要的图形。大家可以自己的试一试，任何问题都可以和图表君进行交流。" }, { "title": "数据可视化工具巡礼-RAVE(1)", "url": "/posts/Rave1/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-02-02 19:15:00 +0800", "snippet": "今天开始分享更多干货。从什么开始呢？那就从RAVE开始吧，因为图表君对它最为熟悉了。好吧，第一个问题来了？什么是RAVE。RAVE 是 Rapidly Adaptive Visualization Engine 的简称。是IBM最新提出新一代的数据可视化图形引擎。IBM在其很多最新的产品上已经应用了RAVE作为图形引擎，例如IBM Cognos BI， IBM Watson 以及 BlueMix 等等。RAVE初探：与以往的数据可视化方案不同的是，以往数据可视化解决方案中总有图库的概念，在这些图库中预先定义了很多的图形，例如栅格图，线图，饼图，散点图，气泡图等等。从图库中选择需要的图形，用于展示想要的数据。那么就存在了一个问题了，如果要重新定义在图库中没有的一个图形，那么就得让开放人员重新开发，更新图库。这样是不是很麻烦？RAVE的概念完全不同，它最大的特点就是定义了一种描述图形的语言对图形进行描述。说的通俗点，就是RAVE提供了一门编程语言，用于实现图形。这样就提供了更大的定制性，只要熟悉RAVE，那就可以自己创造出符合要求的图形。除此之外，RAVE提供各种平台的各种SDK，支持Desktop(JAVA)，Web(Javascript)，IOS，Android，实现了对Desktop,web,Mobile的支持。RAVE的描述语言：上文书说到了，RAVE定义一种描述语言来描述图形。那么现在就来简单说道说道。RAVE利用Json的数据格式来说描述图形，RAVE将其称为VizJson。在VizJSon主要包含两个部分data和grammar。 data里定义了要展示的数据，Grammar里定义了图形的描述。定义好VizJson，调用RAVE的图形引擎，就能将图形展示出来了。今天我们开个头，具体的东西，以后慢慢给大家分享。下边看看用RAVE制作的一些图形。RAVE现在已经作为bluemix的图形引擎开放出来。好了，今天就写到这里，下一篇我们会继续探讨下RAVE的vizJSon,如何用这样的描述语言定义出一个图形。" }, { "title": "数据可视化101-到底该用什么图", "url": "/posts/Vs1/", "categories": "Learning", "tags": "前端, visualization", "date": "2015-01-29 19:15:00 +0800", "snippet": "本文是阅读Data Visualization with JavaScript (by Stephen A. Thomas) 时的摘要和心得体会。感谢阮一峰老师的Blog，让我发现了这本好书。一提到数据可视化，我们就会想到绚丽的图表，精巧的动画。如果我们没有很强的艺术功底，难道就做不好数据可视化了吗？不是。数据可视化的目的是什么？是帮助用户理解数据。如果简单的图表能达到这样的目的，那么它就是一个好的数据可视化解决案例。下边让我们来看看那些基本的图表。栅格图（Bar Chart）当你想要选择一个图表来表示数据时候，首先应该考虑栅格图是不是合适。因为它够简单。栅格图是最基本的一种图表形式，它用高度来表示数据之间的差异。适合表示少量的二维数据以及数据在一个维度上变化。线图(Line chart):对于少量的数据，使用栅格图可以很好的解决问题，但如果数据量变大，同时用户关心的是数据的变化趋势，这时线图会是一种更好的选择，并且在一个线图中也可以描述多个数据量。饼图（Pie Chart）：上边说的都是直角坐标系的图形，下边来说说极坐标系下的图形。在可视化家族内，饼图似乎并不受人待见，为什么呢？因为它并不直观，看看下边的例子：你能清楚的告诉我，这里那个颜色的表示的数最大吗？应该很难一眼看出来吧。但是如果转换为栅格图，我们再来看看。是不是一眼就能看出谁大谁小呢？这是为什们呢？因为人眼对于区域面积很难进行比较，尤其是当这些区域还是非矩形的。所以对于小量的数据，如果你的目的是比较多个值，那么还是考虑下栅格图吧。那难道饼图就是英雄无用武之地吗？也不是，当要表示一个数与整体之间的关系时，饼图就派上用场了。看看下面这个例子。这个饼图表现的是，世界贫困人口（每日生活费少于1.25刀）占总人口的比例，很清楚吧。当表示一个值与总体之间的比例关系的时候，用饼图是个好选择。散点图（scatter chart）利用栅格图，我们可以很好的表示出一维数据的大小关系。但是在现实的问题中，往往情况更加的复杂，如果我们想要在一张图中表示两维数据的大小关系和相关关系，应该怎么办呢，这个时候，散点图会是一个比较好的选择了。在一张图中，表示了两维数据（国家平均年龄，国家的医疗投入），同时也可以看出这两维数据的相关关系。气泡图（Bubble chart）气泡图可以视为是散点图的变形。如果我们想表示更多的维度（三个），那么在散点图的基础上，将第三个维度用点的大小来表示，那么这时散点图就变为了气泡图。下图就表示飓风的进程（经度，维度）以及风力大小（第三个维度）。雷达图（radar chart）：雷达图与以上的图形相比，相对少见些。但是如果一个数据有多个维度（超过4个），这时使用雷达图会比较合适，如果你的数据有以下这几个特点，可以考虑使用雷达图：*要表示的数据量不大，一般来说小于7个。*要表示的数据有多个维度，一般来说多于4个以上，如果少于4个考虑使用其他类型的图表。*每一个维度都是可以被度量的。一个典型的例子就是衡量一个NBA球队里球员的表现。在这个例子它的数据量不大（5名队员），每个队员的表现有多个维度（得分，助攻，篮板，断球，盖火锅）。这些维度都是可以被量化，度量的。那么这样的数据用雷达图可以很好的进行表示。" } ]
